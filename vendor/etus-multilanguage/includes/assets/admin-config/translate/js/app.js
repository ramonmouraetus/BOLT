/**
* @vue/shared v3.5.16
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function makeMap(str) {
  const map = /* @__PURE__ */ Object.create(null);
  for (const key of str.split(",")) map[key] = 1;
  return (val) => val in map;
}
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty$2 = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty$2.call(val, key);
const isArray = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isDate$1 = (val) => toTypeString(val) === "[object Date]";
const isFunction$3 = (val) => typeof val === "function";
const isString$1 = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject$3 = (val) => val !== null && typeof val === "object";
const isPromise$1 = (val) => {
  return (isObject$3(val) || isFunction$3(val)) && isFunction$3(val.then) && isFunction$3(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString$1(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction(
  (str) => {
    return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
  }
);
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize$1 = cacheStringFunction((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey = cacheStringFunction(
  (str) => {
    const s = str ? `on${capitalize$1(str)}` : ``;
    return s;
  }
);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, ...arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](...arg);
  }
};
const def = (obj, key, value, writable = false) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    writable,
    value
  });
};
const looseToNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
const toNumber = (val) => {
  const n = isString$1(val) ? Number(val) : NaN;
  return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
function normalizeStyle(value) {
  if (isArray(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString$1(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString$1(value) || isObject$3(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString$1(value)) {
    res = value;
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$3(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
function normalizeProps$1(props) {
  if (!props) return null;
  let { class: klass, style } = props;
  if (klass && !isString$1(klass)) {
    props.class = normalizeClass(klass);
  }
  if (style) {
    props.style = normalizeStyle(style);
  }
  return props;
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
function looseCompareArrays(a, b) {
  if (a.length !== b.length) return false;
  let equal = true;
  for (let i = 0; equal && i < a.length; i++) {
    equal = looseEqual(a[i], b[i]);
  }
  return equal;
}
function looseEqual(a, b) {
  if (a === b) return true;
  let aValidType = isDate$1(a);
  let bValidType = isDate$1(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
  }
  aValidType = isSymbol(a);
  bValidType = isSymbol(b);
  if (aValidType || bValidType) {
    return a === b;
  }
  aValidType = isArray(a);
  bValidType = isArray(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b) : false;
  }
  aValidType = isObject$3(a);
  bValidType = isObject$3(b);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a).length;
    const bKeysCount = Object.keys(b).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a) {
      const aHasKey = a.hasOwnProperty(key);
      const bHasKey = b.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
        return false;
      }
    }
  }
  return String(a) === String(b);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}
const isRef$1 = (val) => {
  return !!(val && val["__v_isRef"] === true);
};
const toDisplayString = (val) => {
  return isString$1(val) ? val : val == null ? "" : isArray(val) || isObject$3(val) && (val.toString === objectToString || !isFunction$3(val.toString)) ? isRef$1(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (isRef$1(val)) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce(
        (entries, [key, val2], i) => {
          entries[stringifySymbol(key, i) + " =>"] = val2;
          return entries;
        },
        {}
      )
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
    };
  } else if (isSymbol(val)) {
    return stringifySymbol(val);
  } else if (isObject$3(val) && !isArray(val) && !isPlainObject(val)) {
    return String(val);
  }
  return val;
};
const stringifySymbol = (v, i = "") => {
  var _a2;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    isSymbol(v) ? `Symbol(${(_a2 = v.description) != null ? _a2 : i})` : v
  );
};
/**
* @vue/reactivity v3.5.16
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this._on = 0;
    this.effects = [];
    this.cleanups = [];
    this._isPaused = false;
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = true;
      let i, l;
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].pause();
        }
      }
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].pause();
      }
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active) {
      if (this._isPaused) {
        this._isPaused = false;
        let i, l;
        if (this.scopes) {
          for (i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].resume();
          }
        }
        for (i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].resume();
        }
      }
    }
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    if (++this._on === 1) {
      this.prevScope = activeEffectScope;
      activeEffectScope = this;
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    if (this._on > 0 && --this._on === 0) {
      activeEffectScope = this.prevScope;
      this.prevScope = void 0;
    }
  }
  stop(fromParent) {
    if (this._active) {
      this._active = false;
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      this.effects.length = 0;
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      this.cleanups.length = 0;
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
    }
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn, failSilently = false) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  }
}
let activeSub;
const pausedQueueEffects = /* @__PURE__ */ new WeakSet();
class ReactiveEffect {
  constructor(fn) {
    this.fn = fn;
    this.deps = void 0;
    this.depsTail = void 0;
    this.flags = 1 | 4;
    this.next = void 0;
    this.cleanup = void 0;
    this.scheduler = void 0;
    if (activeEffectScope && activeEffectScope.active) {
      activeEffectScope.effects.push(this);
    }
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    if (this.flags & 64) {
      this.flags &= -65;
      if (pausedQueueEffects.has(this)) {
        pausedQueueEffects.delete(this);
        this.trigger();
      }
    }
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags & 2 && !(this.flags & 32)) {
      return;
    }
    if (!(this.flags & 8)) {
      batch(this);
    }
  }
  run() {
    if (!(this.flags & 1)) {
      return this.fn();
    }
    this.flags |= 2;
    cleanupEffect(this);
    prepareDeps(this);
    const prevEffect = activeSub;
    const prevShouldTrack = shouldTrack;
    activeSub = this;
    shouldTrack = true;
    try {
      return this.fn();
    } finally {
      cleanupDeps(this);
      activeSub = prevEffect;
      shouldTrack = prevShouldTrack;
      this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let link = this.deps; link; link = link.nextDep) {
        removeSub(link);
      }
      this.deps = this.depsTail = void 0;
      cleanupEffect(this);
      this.onStop && this.onStop();
      this.flags &= -2;
    }
  }
  trigger() {
    if (this.flags & 64) {
      pausedQueueEffects.add(this);
    } else if (this.scheduler) {
      this.scheduler();
    } else {
      this.runIfDirty();
    }
  }
  /**
   * @internal
   */
  runIfDirty() {
    if (isDirty(this)) {
      this.run();
    }
  }
  get dirty() {
    return isDirty(this);
  }
}
let batchDepth = 0;
let batchedSub;
let batchedComputed;
function batch(sub, isComputed = false) {
  sub.flags |= 8;
  if (isComputed) {
    sub.next = batchedComputed;
    batchedComputed = sub;
    return;
  }
  sub.next = batchedSub;
  batchedSub = sub;
}
function startBatch() {
  batchDepth++;
}
function endBatch() {
  if (--batchDepth > 0) {
    return;
  }
  if (batchedComputed) {
    let e = batchedComputed;
    batchedComputed = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= -9;
      e = next;
    }
  }
  let error;
  while (batchedSub) {
    let e = batchedSub;
    batchedSub = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= -9;
      if (e.flags & 1) {
        try {
          ;
          e.trigger();
        } catch (err) {
          if (!error) error = err;
        }
      }
      e = next;
    }
  }
  if (error) throw error;
}
function prepareDeps(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    link.version = -1;
    link.prevActiveLink = link.dep.activeLink;
    link.dep.activeLink = link;
  }
}
function cleanupDeps(sub) {
  let head;
  let tail = sub.depsTail;
  let link = tail;
  while (link) {
    const prev = link.prevDep;
    if (link.version === -1) {
      if (link === tail) tail = prev;
      removeSub(link);
      removeDep(link);
    } else {
      head = link;
    }
    link.dep.activeLink = link.prevActiveLink;
    link.prevActiveLink = void 0;
    link = prev;
  }
  sub.deps = head;
  sub.depsTail = tail;
}
function isDirty(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
      return true;
    }
  }
  if (sub._dirty) {
    return true;
  }
  return false;
}
function refreshComputed(computed2) {
  if (computed2.flags & 4 && !(computed2.flags & 16)) {
    return;
  }
  computed2.flags &= -17;
  if (computed2.globalVersion === globalVersion) {
    return;
  }
  computed2.globalVersion = globalVersion;
  if (!computed2.isSSR && computed2.flags & 128 && (!computed2.deps && !computed2._dirty || !isDirty(computed2))) {
    return;
  }
  computed2.flags |= 2;
  const dep = computed2.dep;
  const prevSub = activeSub;
  const prevShouldTrack = shouldTrack;
  activeSub = computed2;
  shouldTrack = true;
  try {
    prepareDeps(computed2);
    const value = computed2.fn(computed2._value);
    if (dep.version === 0 || hasChanged(value, computed2._value)) {
      computed2.flags |= 128;
      computed2._value = value;
      dep.version++;
    }
  } catch (err) {
    dep.version++;
    throw err;
  } finally {
    activeSub = prevSub;
    shouldTrack = prevShouldTrack;
    cleanupDeps(computed2);
    computed2.flags &= -3;
  }
}
function removeSub(link, soft = false) {
  const { dep, prevSub, nextSub } = link;
  if (prevSub) {
    prevSub.nextSub = nextSub;
    link.prevSub = void 0;
  }
  if (nextSub) {
    nextSub.prevSub = prevSub;
    link.nextSub = void 0;
  }
  if (dep.subs === link) {
    dep.subs = prevSub;
    if (!prevSub && dep.computed) {
      dep.computed.flags &= -5;
      for (let l = dep.computed.deps; l; l = l.nextDep) {
        removeSub(l, true);
      }
    }
  }
  if (!soft && !--dep.sc && dep.map) {
    dep.map.delete(dep.key);
  }
}
function removeDep(link) {
  const { prevDep, nextDep } = link;
  if (prevDep) {
    prevDep.nextDep = nextDep;
    link.prevDep = void 0;
  }
  if (nextDep) {
    nextDep.prevDep = prevDep;
    link.nextDep = void 0;
  }
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function cleanupEffect(e) {
  const { cleanup } = e;
  e.cleanup = void 0;
  if (cleanup) {
    const prevSub = activeSub;
    activeSub = void 0;
    try {
      cleanup();
    } finally {
      activeSub = prevSub;
    }
  }
}
let globalVersion = 0;
class Link {
  constructor(sub, dep) {
    this.sub = sub;
    this.dep = dep;
    this.version = dep.version;
    this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class Dep {
  constructor(computed2) {
    this.computed = computed2;
    this.version = 0;
    this.activeLink = void 0;
    this.subs = void 0;
    this.map = void 0;
    this.key = void 0;
    this.sc = 0;
  }
  track(debugInfo) {
    if (!activeSub || !shouldTrack || activeSub === this.computed) {
      return;
    }
    let link = this.activeLink;
    if (link === void 0 || link.sub !== activeSub) {
      link = this.activeLink = new Link(activeSub, this);
      if (!activeSub.deps) {
        activeSub.deps = activeSub.depsTail = link;
      } else {
        link.prevDep = activeSub.depsTail;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
      }
      addSub(link);
    } else if (link.version === -1) {
      link.version = this.version;
      if (link.nextDep) {
        const next = link.nextDep;
        next.prevDep = link.prevDep;
        if (link.prevDep) {
          link.prevDep.nextDep = next;
        }
        link.prevDep = activeSub.depsTail;
        link.nextDep = void 0;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
        if (activeSub.deps === link) {
          activeSub.deps = next;
        }
      }
    }
    return link;
  }
  trigger(debugInfo) {
    this.version++;
    globalVersion++;
    this.notify(debugInfo);
  }
  notify(debugInfo) {
    startBatch();
    try {
      if (false) ;
      for (let link = this.subs; link; link = link.prevSub) {
        if (link.sub.notify()) {
          ;
          link.sub.dep.notify();
        }
      }
    } finally {
      endBatch();
    }
  }
}
function addSub(link) {
  link.dep.sc++;
  if (link.sub.flags & 4) {
    const computed2 = link.dep.computed;
    if (computed2 && !link.dep.subs) {
      computed2.flags |= 4 | 16;
      for (let l = computed2.deps; l; l = l.nextDep) {
        addSub(l);
      }
    }
    const currentTail = link.dep.subs;
    if (currentTail !== link) {
      link.prevSub = currentTail;
      if (currentTail) currentTail.nextSub = link;
    }
    link.dep.subs = link;
  }
}
const targetMap = /* @__PURE__ */ new WeakMap();
const ITERATE_KEY = Symbol(
  ""
);
const MAP_KEY_ITERATE_KEY = Symbol(
  ""
);
const ARRAY_ITERATE_KEY = Symbol(
  ""
);
function track(target, type, key) {
  if (shouldTrack && activeSub) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = new Dep());
      dep.map = depsMap;
      dep.key = key;
    }
    {
      dep.track();
    }
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    globalVersion++;
    return;
  }
  const run = (dep) => {
    if (dep) {
      {
        dep.trigger();
      }
    }
  };
  startBatch();
  if (type === "clear") {
    depsMap.forEach(run);
  } else {
    const targetIsArray = isArray(target);
    const isArrayIndex = targetIsArray && isIntegerKey(key);
    if (targetIsArray && key === "length") {
      const newLength = Number(newValue);
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {
          run(dep);
        }
      });
    } else {
      if (key !== void 0 || depsMap.has(void 0)) {
        run(depsMap.get(key));
      }
      if (isArrayIndex) {
        run(depsMap.get(ARRAY_ITERATE_KEY));
      }
      switch (type) {
        case "add":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isArrayIndex) {
            run(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (isMap(target)) {
            run(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
  }
  endBatch();
}
function getDepFromReactive(object, key) {
  const depMap = targetMap.get(object);
  return depMap && depMap.get(key);
}
function reactiveReadArray(array) {
  const raw = toRaw(array);
  if (raw === array) return raw;
  track(raw, "iterate", ARRAY_ITERATE_KEY);
  return isShallow(array) ? raw : raw.map(toReactive);
}
function shallowReadArray(arr) {
  track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
  return arr;
}
const arrayInstrumentations = {
  __proto__: null,
  [Symbol.iterator]() {
    return iterator(this, Symbol.iterator, toReactive);
  },
  concat(...args) {
    return reactiveReadArray(this).concat(
      ...args.map((x) => isArray(x) ? reactiveReadArray(x) : x)
    );
  },
  entries() {
    return iterator(this, "entries", (value) => {
      value[1] = toReactive(value[1]);
      return value;
    });
  },
  every(fn, thisArg) {
    return apply(this, "every", fn, thisArg, void 0, arguments);
  },
  filter(fn, thisArg) {
    return apply(this, "filter", fn, thisArg, (v) => v.map(toReactive), arguments);
  },
  find(fn, thisArg) {
    return apply(this, "find", fn, thisArg, toReactive, arguments);
  },
  findIndex(fn, thisArg) {
    return apply(this, "findIndex", fn, thisArg, void 0, arguments);
  },
  findLast(fn, thisArg) {
    return apply(this, "findLast", fn, thisArg, toReactive, arguments);
  },
  findLastIndex(fn, thisArg) {
    return apply(this, "findLastIndex", fn, thisArg, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(fn, thisArg) {
    return apply(this, "forEach", fn, thisArg, void 0, arguments);
  },
  includes(...args) {
    return searchProxy(this, "includes", args);
  },
  indexOf(...args) {
    return searchProxy(this, "indexOf", args);
  },
  join(separator) {
    return reactiveReadArray(this).join(separator);
  },
  // keys() iterator only reads `length`, no optimisation required
  lastIndexOf(...args) {
    return searchProxy(this, "lastIndexOf", args);
  },
  map(fn, thisArg) {
    return apply(this, "map", fn, thisArg, void 0, arguments);
  },
  pop() {
    return noTracking(this, "pop");
  },
  push(...args) {
    return noTracking(this, "push", args);
  },
  reduce(fn, ...args) {
    return reduce(this, "reduce", fn, args);
  },
  reduceRight(fn, ...args) {
    return reduce(this, "reduceRight", fn, args);
  },
  shift() {
    return noTracking(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(fn, thisArg) {
    return apply(this, "some", fn, thisArg, void 0, arguments);
  },
  splice(...args) {
    return noTracking(this, "splice", args);
  },
  toReversed() {
    return reactiveReadArray(this).toReversed();
  },
  toSorted(comparer) {
    return reactiveReadArray(this).toSorted(comparer);
  },
  toSpliced(...args) {
    return reactiveReadArray(this).toSpliced(...args);
  },
  unshift(...args) {
    return noTracking(this, "unshift", args);
  },
  values() {
    return iterator(this, "values", toReactive);
  }
};
function iterator(self2, method, wrapValue) {
  const arr = shallowReadArray(self2);
  const iter = arr[method]();
  if (arr !== self2 && !isShallow(self2)) {
    iter._next = iter.next;
    iter.next = () => {
      const result = iter._next();
      if (result.value) {
        result.value = wrapValue(result.value);
      }
      return result;
    };
  }
  return iter;
}
const arrayProto = Array.prototype;
function apply(self2, method, fn, thisArg, wrappedRetFn, args) {
  const arr = shallowReadArray(self2);
  const needsWrap = arr !== self2 && !isShallow(self2);
  const methodFn = arr[method];
  if (methodFn !== arrayProto[method]) {
    const result2 = methodFn.apply(self2, args);
    return needsWrap ? toReactive(result2) : result2;
  }
  let wrappedFn = fn;
  if (arr !== self2) {
    if (needsWrap) {
      wrappedFn = function(item, index) {
        return fn.call(this, toReactive(item), index, self2);
      };
    } else if (fn.length > 2) {
      wrappedFn = function(item, index) {
        return fn.call(this, item, index, self2);
      };
    }
  }
  const result = methodFn.call(arr, wrappedFn, thisArg);
  return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
}
function reduce(self2, method, fn, args) {
  const arr = shallowReadArray(self2);
  let wrappedFn = fn;
  if (arr !== self2) {
    if (!isShallow(self2)) {
      wrappedFn = function(acc, item, index) {
        return fn.call(this, acc, toReactive(item), index, self2);
      };
    } else if (fn.length > 3) {
      wrappedFn = function(acc, item, index) {
        return fn.call(this, acc, item, index, self2);
      };
    }
  }
  return arr[method](wrappedFn, ...args);
}
function searchProxy(self2, method, args) {
  const arr = toRaw(self2);
  track(arr, "iterate", ARRAY_ITERATE_KEY);
  const res = arr[method](...args);
  if ((res === -1 || res === false) && isProxy(args[0])) {
    args[0] = toRaw(args[0]);
    return arr[method](...args);
  }
  return res;
}
function noTracking(self2, method, args = []) {
  pauseTracking();
  startBatch();
  const res = toRaw(self2)[method].apply(self2, args);
  endBatch();
  resetTracking();
  return res;
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
function hasOwnProperty$1(key) {
  if (!isSymbol(key)) key = String(key);
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
class BaseReactiveHandler {
  constructor(_isReadonly = false, _isShallow = false) {
    this._isReadonly = _isReadonly;
    this._isShallow = _isShallow;
  }
  get(target, key, receiver) {
    if (key === "__v_skip") return target["__v_skip"];
    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return isShallow2;
    } else if (key === "__v_raw") {
      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
        return target;
      }
      return;
    }
    const targetIsArray = isArray(target);
    if (!isReadonly2) {
      let fn;
      if (targetIsArray && (fn = arrayInstrumentations[key])) {
        return fn;
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty$1;
      }
    }
    const res = Reflect.get(
      target,
      key,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      isRef(target) ? target : receiver
    );
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (isShallow2) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject$3(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  }
}
class MutableReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(false, isShallow2);
  }
  set(target, key, value, receiver) {
    let oldValue = target[key];
    if (!this._isShallow) {
      const isOldValueReadonly = isReadonly(oldValue);
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
        if (isOldValueReadonly) {
          return false;
        } else {
          oldValue.value = value;
          return true;
        }
      }
    }
    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(
      target,
      key,
      value,
      isRef(target) ? target : receiver
    );
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
    }
    return result;
  }
  deleteProperty(target, key) {
    const hadKey = hasOwn(target, key);
    target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0);
    }
    return result;
  }
  has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  ownKeys(target) {
    track(
      target,
      "iterate",
      isArray(target) ? "length" : ITERATE_KEY
    );
    return Reflect.ownKeys(target);
  }
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(true, isShallow2);
  }
  set(target, key) {
    return true;
  }
  deleteProperty(target, key) {
    return true;
  }
}
const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : type === "clear" ? void 0 : this;
  };
}
function createInstrumentations(readonly2, shallow) {
  const instrumentations = {
    get(key) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!readonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "get", key);
        }
        track(rawTarget, "get", rawKey);
      }
      const { has } = getProto(rawTarget);
      const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
      if (has.call(rawTarget, key)) {
        return wrap(target.get(key));
      } else if (has.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
      } else if (target !== rawTarget) {
        target.get(key);
      }
    },
    get size() {
      const target = this["__v_raw"];
      !readonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
      return Reflect.get(target, "size", target);
    },
    has(key) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!readonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "has", key);
        }
        track(rawTarget, "has", rawKey);
      }
      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
    },
    forEach(callback, thisArg) {
      const observed = this;
      const target = observed["__v_raw"];
      const rawTarget = toRaw(target);
      const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
      !readonly2 && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value, key) => {
        return callback.call(thisArg, wrap(value), wrap(key), observed);
      });
    }
  };
  extend(
    instrumentations,
    readonly2 ? {
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear")
    } : {
      add(value) {
        if (!shallow && !isShallow(value) && !isReadonly(value)) {
          value = toRaw(value);
        }
        const target = toRaw(this);
        const proto = getProto(target);
        const hadKey = proto.has.call(target, value);
        if (!hadKey) {
          target.add(value);
          trigger(target, "add", value, value);
        }
        return this;
      },
      set(key, value) {
        if (!shallow && !isShallow(value) && !isReadonly(value)) {
          value = toRaw(value);
        }
        const target = toRaw(this);
        const { has, get } = getProto(target);
        let hadKey = has.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has.call(target, key);
        }
        const oldValue = get.call(target, key);
        target.set(key, value);
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value);
        }
        return this;
      },
      delete(key) {
        const target = toRaw(this);
        const { has, get } = getProto(target);
        let hadKey = has.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has.call(target, key);
        }
        get ? get.call(target, key) : void 0;
        const result = target.delete(key);
        if (hadKey) {
          trigger(target, "delete", key, void 0);
        }
        return result;
      },
      clear() {
        const target = toRaw(this);
        const hadItems = target.size !== 0;
        const result = target.clear();
        if (hadItems) {
          trigger(
            target,
            "clear",
            void 0,
            void 0
          );
        }
        return result;
      }
    }
  );
  const iteratorMethods = [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ];
  iteratorMethods.forEach((method) => {
    instrumentations[method] = createIterableMethod(method, readonly2, shallow);
  });
  return instrumentations;
}
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = createInstrumentations(isReadonly2, shallow);
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function shallowReactive(target) {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function shallowReadonly(target) {
  return createReactiveObject(
    target,
    true,
    shallowReadonlyHandlers,
    shallowReadonlyCollectionHandlers,
    shallowReadonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$3(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return value ? !!value["__v_raw"] : false;
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  if (!hasOwn(value, "__v_skip") && Object.isExtensible(value)) {
    def(value, "__v_skip", true);
  }
  return value;
}
const toReactive = (value) => isObject$3(value) ? reactive(value) : value;
const toReadonly = (value) => isObject$3(value) ? readonly(value) : value;
function isRef(r) {
  return r ? r["__v_isRef"] === true : false;
}
function ref(value) {
  return createRef(value, false);
}
function shallowRef(value) {
  return createRef(value, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, isShallow2) {
    this.dep = new Dep();
    this["__v_isRef"] = true;
    this["__v_isShallow"] = false;
    this._rawValue = isShallow2 ? value : toRaw(value);
    this._value = isShallow2 ? value : toReactive(value);
    this["__v_isShallow"] = isShallow2;
  }
  get value() {
    {
      this.dep.track();
    }
    return this._value;
  }
  set value(newValue) {
    const oldValue = this._rawValue;
    const useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
    newValue = useDirectValue ? newValue : toRaw(newValue);
    if (hasChanged(newValue, oldValue)) {
      this._rawValue = newValue;
      this._value = useDirectValue ? newValue : toReactive(newValue);
      {
        this.dep.trigger();
      }
    }
  }
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class CustomRefImpl {
  constructor(factory) {
    this["__v_isRef"] = true;
    this._value = void 0;
    const dep = this.dep = new Dep();
    const { get, set } = factory(dep.track.bind(dep), dep.trigger.bind(dep));
    this._get = get;
    this._set = set;
  }
  get value() {
    return this._value = this._get();
  }
  set value(newVal) {
    this._set(newVal);
  }
}
function customRef(factory) {
  return new CustomRefImpl(factory);
}
function toRefs(object) {
  const ret = isArray(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = propertyToRef(object, key);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this["__v_isRef"] = true;
    this._value = void 0;
  }
  get value() {
    const val = this._object[this._key];
    return this._value = val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
  get dep() {
    return getDepFromReactive(toRaw(this._object), this._key);
  }
}
class GetterRefImpl {
  constructor(_getter) {
    this._getter = _getter;
    this["__v_isRef"] = true;
    this["__v_isReadonly"] = true;
    this._value = void 0;
  }
  get value() {
    return this._value = this._getter();
  }
}
function toRef(source, key, defaultValue) {
  if (isRef(source)) {
    return source;
  } else if (isFunction$3(source)) {
    return new GetterRefImpl(source);
  } else if (isObject$3(source) && arguments.length > 1) {
    return propertyToRef(source, key, defaultValue);
  } else {
    return ref(source);
  }
}
function propertyToRef(source, key, defaultValue) {
  const val = source[key];
  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
}
class ComputedRefImpl {
  constructor(fn, setter, isSSR) {
    this.fn = fn;
    this.setter = setter;
    this._value = void 0;
    this.dep = new Dep(this);
    this.__v_isRef = true;
    this.deps = void 0;
    this.depsTail = void 0;
    this.flags = 16;
    this.globalVersion = globalVersion - 1;
    this.next = void 0;
    this.effect = this;
    this["__v_isReadonly"] = !setter;
    this.isSSR = isSSR;
  }
  /**
   * @internal
   */
  notify() {
    this.flags |= 16;
    if (!(this.flags & 8) && // avoid infinite self recursion
    activeSub !== this) {
      batch(this, true);
      return true;
    }
  }
  get value() {
    const link = this.dep.track();
    refreshComputed(this);
    if (link) {
      link.version = this.dep.version;
    }
    return this._value;
  }
  set value(newValue) {
    if (this.setter) {
      this.setter(newValue);
    }
  }
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  if (isFunction$3(getterOrOptions)) {
    getter = getterOrOptions;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, isSSR);
  return cRef;
}
const INITIAL_WATCHER_VALUE = {};
const cleanupMap = /* @__PURE__ */ new WeakMap();
let activeWatcher = void 0;
function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
  if (owner) {
    let cleanups = cleanupMap.get(owner);
    if (!cleanups) cleanupMap.set(owner, cleanups = []);
    cleanups.push(cleanupFn);
  }
}
function watch$1(source, cb, options = EMPTY_OBJ) {
  const { immediate, deep, once, scheduler, augmentJob, call } = options;
  const reactiveGetter = (source2) => {
    if (deep) return source2;
    if (isShallow(source2) || deep === false || deep === 0)
      return traverse(source2, 1);
    return traverse(source2);
  };
  let effect2;
  let getter;
  let cleanup;
  let boundCleanup;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => reactiveGetter(source);
    forceTrigger = true;
  } else if (isArray(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return reactiveGetter(s);
      } else if (isFunction$3(s)) {
        return call ? call(s, 2) : s();
      } else ;
    });
  } else if (isFunction$3(source)) {
    if (cb) {
      getter = call ? () => call(source, 2) : source;
    } else {
      getter = () => {
        if (cleanup) {
          pauseTracking();
          try {
            cleanup();
          } finally {
            resetTracking();
          }
        }
        const currentEffect = activeWatcher;
        activeWatcher = effect2;
        try {
          return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);
        } finally {
          activeWatcher = currentEffect;
        }
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    const depth = deep === true ? Infinity : deep;
    getter = () => traverse(baseGetter(), depth);
  }
  const scope = getCurrentScope();
  const watchHandle = () => {
    effect2.stop();
    if (scope && scope.active) {
      remove(scope.effects, effect2);
    }
  };
  if (once && cb) {
    const _cb = cb;
    cb = (...args) => {
      _cb(...args);
      watchHandle();
    };
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = (immediateFirstRun) => {
    if (!(effect2.flags & 1) || !effect2.dirty && !immediateFirstRun) {
      return;
    }
    if (cb) {
      const newValue = effect2.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {
        if (cleanup) {
          cleanup();
        }
        const currentWatcher = activeWatcher;
        activeWatcher = effect2;
        try {
          const args = [
            newValue,
            // pass undefined as the old value when it's changed for the first time
            oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
            boundCleanup
          ];
          oldValue = newValue;
          call ? call(cb, 3, args) : (
            // @ts-expect-error
            cb(...args)
          );
        } finally {
          activeWatcher = currentWatcher;
        }
      }
    } else {
      effect2.run();
    }
  };
  if (augmentJob) {
    augmentJob(job);
  }
  effect2 = new ReactiveEffect(getter);
  effect2.scheduler = scheduler ? () => scheduler(job, false) : job;
  boundCleanup = (fn) => onWatcherCleanup(fn, false, effect2);
  cleanup = effect2.onStop = () => {
    const cleanups = cleanupMap.get(effect2);
    if (cleanups) {
      if (call) {
        call(cleanups, 4);
      } else {
        for (const cleanup2 of cleanups) cleanup2();
      }
      cleanupMap.delete(effect2);
    }
  };
  if (cb) {
    if (immediate) {
      job(true);
    } else {
      oldValue = effect2.run();
    }
  } else if (scheduler) {
    scheduler(job.bind(null, true), true);
  } else {
    effect2.run();
  }
  watchHandle.pause = effect2.pause.bind(effect2);
  watchHandle.resume = effect2.resume.bind(effect2);
  watchHandle.stop = watchHandle;
  return watchHandle;
}
function traverse(value, depth = Infinity, seen) {
  if (depth <= 0 || !isObject$3(value) || value["__v_skip"]) {
    return value;
  }
  seen = seen || /* @__PURE__ */ new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  depth--;
  if (isRef(value)) {
    traverse(value.value, depth, seen);
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], depth, seen);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v) => {
      traverse(v, depth, seen);
    });
  } else if (isPlainObject(value)) {
    for (const key in value) {
      traverse(value[key], depth, seen);
    }
    for (const key of Object.getOwnPropertySymbols(value)) {
      if (Object.prototype.propertyIsEnumerable.call(value, key)) {
        traverse(value[key], depth, seen);
      }
    }
  }
  return value;
}
/**
* @vue/runtime-core v3.5.16
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const stack = [];
let isWarning = false;
function warn$1(msg, ...args) {
  if (isWarning) return;
  isWarning = true;
  pauseTracking();
  const instance = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(
      appWarnHandler,
      instance,
      11,
      [
        // eslint-disable-next-line no-restricted-syntax
        msg + args.map((a) => {
          var _a2, _b;
          return (_b = (_a2 = a.toString) == null ? void 0 : _a2.call(a)) != null ? _b : JSON.stringify(a);
        }).join(""),
        instance && instance.proxy,
        trace.map(
          ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
        ).join("\n"),
        trace
      ]
    );
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && // avoid spamming console during tests
    true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
  isWarning = false;
}
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last = normalizedStack[0];
    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i) => {
    logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open = ` at <${formatComponentName(
    vnode.component,
    vnode.type,
    isRoot
  )}`;
  const close = `>` + postfix;
  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
}
function formatProps(props) {
  const res = [];
  const keys = Object.keys(props);
  keys.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value, raw) {
  if (isString$1(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key}=${value}`];
  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
    return raw ? value : [`${key}=${value}`];
  } else if (isRef(value)) {
    value = formatProp(key, toRaw(value.value), true);
    return raw ? value : [`${key}=Ref<`, value, `>`];
  } else if (isFunction$3(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = toRaw(value);
    return raw ? value : [`${key}=`, value];
  }
}
function callWithErrorHandling(fn, instance, type, args) {
  try {
    return args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction$3(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise$1(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  if (isArray(fn)) {
    const values = [];
    for (let i = 0; i < fn.length; i++) {
      values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
    }
    return values;
  }
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || EMPTY_OBJ;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = `https://vuejs.org/error-reference/#runtime-${type}`;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    if (errorHandler) {
      pauseTracking();
      callWithErrorHandling(errorHandler, null, 10, [
        err,
        exposedInstance,
        errorInfo
      ]);
      resetTracking();
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);
}
function logError(err, type, contextVNode, throwInDev = true, throwInProd = false) {
  if (throwInProd) {
    throw err;
  } else {
    console.error(err);
  }
}
const queue = [];
let flushIndex = -1;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJob = queue[middle];
    const middleJobId = getId(middleJob);
    if (middleJobId < id || middleJobId === id && middleJob.flags & 2) {
      start = middle + 1;
    } else {
      end = middle;
    }
  }
  return start;
}
function queueJob(job) {
  if (!(job.flags & 1)) {
    const jobId = getId(job);
    const lastJob = queue[queue.length - 1];
    if (!lastJob || // fast path when the job id is larger than the tail
    !(job.flags & 2) && jobId >= getId(lastJob)) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(jobId), 0, job);
    }
    job.flags |= 1;
    queueFlush();
  }
}
function queueFlush() {
  if (!currentFlushPromise) {
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray(cb)) {
    if (activePostFlushCbs && cb.id === -1) {
      activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
    } else if (!(cb.flags & 1)) {
      pendingPostFlushCbs.push(cb);
      cb.flags |= 1;
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(instance, seen, i = flushIndex + 1) {
  for (; i < queue.length; i++) {
    const cb = queue[i];
    if (cb && cb.flags & 2) {
      if (instance && cb.id !== instance.uid) {
        continue;
      }
      queue.splice(i, 1);
      i--;
      if (cb.flags & 4) {
        cb.flags &= -2;
      }
      cb();
      if (!(cb.flags & 4)) {
        cb.flags &= -2;
      }
    }
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)].sort(
      (a, b) => getId(a) - getId(b)
    );
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      const cb = activePostFlushCbs[postFlushIndex];
      if (cb.flags & 4) {
        cb.flags &= -2;
      }
      if (!(cb.flags & 8)) cb();
      cb.flags &= -2;
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
function flushJobs(seen) {
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && !(job.flags & 8)) {
        if (false) ;
        if (job.flags & 4) {
          job.flags &= ~1;
        }
        callWithErrorHandling(
          job,
          job.i,
          job.i ? 15 : 14
        );
        if (!(job.flags & 4)) {
          job.flags &= ~1;
        }
      }
    }
  } finally {
    for (; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job) {
        job.flags &= -2;
      }
    }
    flushIndex = -1;
    queue.length = 0;
    flushPostFlushCbs();
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs();
    }
  }
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx) return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function withDirectives(vnode, directives) {
  if (currentRenderingInstance === null) {
    return vnode;
  }
  const instance = getComponentPublicInstance(currentRenderingInstance);
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i = 0; i < directives.length; i++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
    if (dir) {
      if (isFunction$3(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value);
      }
      bindings.push({
        dir,
        instance,
        value,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
const TeleportEndKey = Symbol("_vte");
const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
const isTeleportDeferred = (props) => props && (props.defer || props.defer === "");
const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
const isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
const resolveTarget = (props, select) => {
  const targetSelector = props && props.to;
  if (isString$1(targetSelector)) {
    if (!select) {
      return null;
    } else {
      const target = select(targetSelector);
      return target;
    }
  } else {
    return targetSelector;
  }
};
const TeleportImpl = {
  name: "Teleport",
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
    const {
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      o: { insert, querySelector, createText, createComment }
    } = internals;
    const disabled = isTeleportDisabled(n2.props);
    let { shapeFlag, children, dynamicChildren } = n2;
    if (n1 == null) {
      const placeholder = n2.el = createText("");
      const mainAnchor = n2.anchor = createText("");
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      const mount2 = (container2, anchor2) => {
        if (shapeFlag & 16) {
          if (parentComponent && parentComponent.isCE) {
            parentComponent.ce._teleportTarget = container2;
          }
          mountChildren(
            children,
            container2,
            anchor2,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      };
      const mountToTarget = () => {
        const target = n2.target = resolveTarget(n2.props, querySelector);
        const targetAnchor = prepareAnchor(target, n2, createText, insert);
        if (target) {
          if (namespace !== "svg" && isTargetSVG(target)) {
            namespace = "svg";
          } else if (namespace !== "mathml" && isTargetMathML(target)) {
            namespace = "mathml";
          }
          if (!disabled) {
            mount2(target, targetAnchor);
            updateCssVars(n2, false);
          }
        }
      };
      if (disabled) {
        mount2(container, mainAnchor);
        updateCssVars(n2, true);
      }
      if (isTeleportDeferred(n2.props)) {
        n2.el.__isMounted = false;
        queuePostRenderEffect(() => {
          mountToTarget();
          delete n2.el.__isMounted;
        }, parentSuspense);
      } else {
        mountToTarget();
      }
    } else {
      if (isTeleportDeferred(n2.props) && n1.el.__isMounted === false) {
        queuePostRenderEffect(() => {
          TeleportImpl.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        }, parentSuspense);
        return;
      }
      n2.el = n1.el;
      n2.targetStart = n1.targetStart;
      const mainAnchor = n2.anchor = n1.anchor;
      const target = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      if (namespace === "svg" || isTargetSVG(target)) {
        namespace = "svg";
      } else if (namespace === "mathml" || isTargetMathML(target)) {
        namespace = "mathml";
      }
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          currentContainer,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          currentContainer,
          currentAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          false
        );
      }
      if (disabled) {
        if (!wasDisabled) {
          moveTeleport(
            n2,
            container,
            mainAnchor,
            internals,
            1
          );
        } else {
          if (n2.props && n1.props && n2.props.to !== n1.props.to) {
            n2.props.to = n1.props.to;
          }
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(
            n2.props,
            querySelector
          );
          if (nextTarget) {
            moveTeleport(
              n2,
              nextTarget,
              null,
              internals,
              0
            );
          }
        } else if (wasDisabled) {
          moveTeleport(
            n2,
            target,
            targetAnchor,
            internals,
            1
          );
        }
      }
      updateCssVars(n2, disabled);
    }
  },
  remove(vnode, parentComponent, parentSuspense, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const {
      shapeFlag,
      children,
      anchor,
      targetStart,
      targetAnchor,
      target,
      props
    } = vnode;
    if (target) {
      hostRemove(targetStart);
      hostRemove(targetAnchor);
    }
    doRemove && hostRemove(anchor);
    if (shapeFlag & 16) {
      const shouldRemove = doRemove || !isTeleportDisabled(props);
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        unmount(
          child,
          parentComponent,
          parentSuspense,
          shouldRemove,
          !!child.dynamicChildren
        );
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }
  const { el, anchor, shapeFlag, children, props } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props)) {
    if (shapeFlag & 16) {
      for (let i = 0; i < children.length; i++) {
        move(
          children[i],
          container,
          parentAnchor,
          2
        );
      }
    }
  }
  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
  o: { nextSibling, parentNode, querySelector, insert, createText }
}, hydrateChildren) {
  const target = vnode.target = resolveTarget(
    vnode.props,
    querySelector
  );
  if (target) {
    const disabled = isTeleportDisabled(vnode.props);
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (disabled) {
        vnode.anchor = hydrateChildren(
          nextSibling(node),
          vnode,
          parentNode(node),
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        vnode.targetStart = targetNode;
        vnode.targetAnchor = targetNode && nextSibling(targetNode);
      } else {
        vnode.anchor = nextSibling(node);
        let targetAnchor = targetNode;
        while (targetAnchor) {
          if (targetAnchor && targetAnchor.nodeType === 8) {
            if (targetAnchor.data === "teleport start anchor") {
              vnode.targetStart = targetAnchor;
            } else if (targetAnchor.data === "teleport anchor") {
              vnode.targetAnchor = targetAnchor;
              target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
              break;
            }
          }
          targetAnchor = nextSibling(targetAnchor);
        }
        if (!vnode.targetAnchor) {
          prepareAnchor(target, vnode, createText, insert);
        }
        hydrateChildren(
          targetNode && nextSibling(targetNode),
          vnode,
          target,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      }
    }
    updateCssVars(vnode, disabled);
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
function updateCssVars(vnode, isDisabled) {
  const ctx = vnode.ctx;
  if (ctx && ctx.ut) {
    let node, anchor;
    if (isDisabled) {
      node = vnode.el;
      anchor = vnode.anchor;
    } else {
      node = vnode.targetStart;
      anchor = vnode.targetAnchor;
    }
    while (node && node !== anchor) {
      if (node.nodeType === 1) node.setAttribute("data-v-owner", ctx.uid);
      node = node.nextSibling;
    }
    ctx.ut();
  }
}
function prepareAnchor(target, vnode, createText, insert) {
  const targetStart = vnode.targetStart = createText("");
  const targetAnchor = vnode.targetAnchor = createText("");
  targetStart[TeleportEndKey] = targetAnchor;
  if (target) {
    insert(targetStart, target);
    insert(targetAnchor, target);
  }
  return targetAnchor;
}
const leaveCbKey = Symbol("_leaveCb");
const enterCbKey$1 = Symbol("_enterCb");
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionPropsValidators = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: TransitionHookValidator,
  onEnter: TransitionHookValidator,
  onAfterEnter: TransitionHookValidator,
  onEnterCancelled: TransitionHookValidator,
  // leave
  onBeforeLeave: TransitionHookValidator,
  onLeave: TransitionHookValidator,
  onAfterLeave: TransitionHookValidator,
  onLeaveCancelled: TransitionHookValidator,
  // appear
  onBeforeAppear: TransitionHookValidator,
  onAppear: TransitionHookValidator,
  onAfterAppear: TransitionHookValidator,
  onAppearCancelled: TransitionHookValidator
};
const recursiveGetSubtree = (instance) => {
  const subTree = instance.subTree;
  return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
};
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: BaseTransitionPropsValidators,
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      const child = findNonCommentChild(children);
      const rawProps = toRaw(props);
      const { mode } = rawProps;
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getInnerChild$1(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      let enterHooks = resolveTransitionHooks(
        innerChild,
        rawProps,
        state,
        instance,
        // #11061, ensure enterHooks is fresh after clone
        (hooks) => enterHooks = hooks
      );
      if (innerChild.type !== Comment) {
        setTransitionHooks(innerChild, enterHooks);
      }
      let oldInnerChild = instance.subTree && getInnerChild$1(instance.subTree);
      if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild) && recursiveGetSubtree(instance).type !== Comment) {
        let leavingHooks = resolveTransitionHooks(
          oldInnerChild,
          rawProps,
          state,
          instance
        );
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in" && innerChild.type !== Comment) {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            if (!(instance.job.flags & 8)) {
              instance.update();
            }
            delete leavingHooks.afterLeave;
            oldInnerChild = void 0;
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(
              state,
              oldInnerChild
            );
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el[leaveCbKey] = () => {
              earlyRemove();
              el[leaveCbKey] = void 0;
              delete enterHooks.delayedLeave;
              oldInnerChild = void 0;
            };
            enterHooks.delayedLeave = () => {
              delayedLeave();
              delete enterHooks.delayedLeave;
              oldInnerChild = void 0;
            };
          };
        } else {
          oldInnerChild = void 0;
        }
      } else if (oldInnerChild) {
        oldInnerChild = void 0;
      }
      return child;
    };
  }
};
function findNonCommentChild(children) {
  let child = children[0];
  if (children.length > 1) {
    for (const c of children) {
      if (c.type !== Comment) {
        child = c;
        break;
      }
    }
  }
  return child;
}
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance, postClone) {
  const {
    appear,
    mode,
    persisted = false,
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onEnterCancelled,
    onBeforeLeave,
    onLeave,
    onAfterLeave,
    onLeaveCancelled,
    onBeforeAppear,
    onAppear,
    onAfterAppear,
    onAppearCancelled
  } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook2 = (hook, args) => {
    hook && callWithAsyncErrorHandling(
      hook,
      instance,
      9,
      args
    );
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook2(hook, args);
    if (isArray(hook)) {
      if (hook.every((hook2) => hook2.length <= 1)) done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el[leaveCbKey]) {
        el[leaveCbKey](
          true
          /* cancelled */
        );
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
        leavingVNode.el[leaveCbKey]();
      }
      callHook2(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el[enterCbKey$1] = (cancelled) => {
        if (called) return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el]);
        } else {
          callHook2(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el[enterCbKey$1] = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove2) {
      const key2 = String(vnode.key);
      if (el[enterCbKey$1]) {
        el[enterCbKey$1](
          true
          /* cancelled */
        );
      }
      if (state.isUnmounting) {
        return remove2();
      }
      callHook2(onBeforeLeave, [el]);
      let called = false;
      const done = el[leaveCbKey] = (cancelled) => {
        if (called) return;
        called = true;
        remove2();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el]);
        } else {
          callHook2(onAfterLeave, [el]);
        }
        el[leaveCbKey] = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      const hooks2 = resolveTransitionHooks(
        vnode2,
        props,
        state,
        instance,
        postClone
      );
      if (postClone) postClone(hooks2);
      return hooks2;
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getInnerChild$1(vnode) {
  if (!isKeepAlive(vnode)) {
    if (isTeleport(vnode.type) && vnode.children) {
      return findNonCommentChild(vnode.children);
    }
    return vnode;
  }
  if (vnode.component) {
    return vnode.component.subTree;
  }
  const { shapeFlag, children } = vnode;
  if (children) {
    if (shapeFlag & 16) {
      return children[0];
    }
    if (shapeFlag & 32 && isFunction$3(children.default)) {
      return children.default();
    }
  }
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    vnode.transition = hooks;
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i = 0; i < children.length; i++) {
    let child = children[i];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
    if (child.type === Fragment) {
      if (child.patchFlag & 128) keyedFragmentCount++;
      ret = ret.concat(
        getTransitionRawChildren(child.children, keepComment, key)
      );
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i = 0; i < ret.length; i++) {
      ret[i].patchFlag = -2;
    }
  }
  return ret;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineComponent(options, extraOptions) {
  return isFunction$3(options) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()
  ) : options;
}
function markAsyncBoundary(instance) {
  instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
}
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray(rawRef)) {
    rawRef.forEach(
      (r, i) => setRef(
        r,
        oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    if (vnode.shapeFlag & 512 && vnode.type.__asyncResolved && vnode.component.subTree.component) {
      setRef(rawRef, oldRawRef, parentSuspense, vnode.component.subTree);
    }
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref3 } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  const rawSetupState = toRaw(setupState);
  const canSetSetupRef = setupState === EMPTY_OBJ ? () => false : (key) => {
    return hasOwn(rawSetupState, key);
  };
  if (oldRef != null && oldRef !== ref3) {
    if (isString$1(oldRef)) {
      refs[oldRef] = null;
      if (canSetSetupRef(oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction$3(ref3)) {
    callWithErrorHandling(ref3, owner, 12, [value, refs]);
  } else {
    const _isString = isString$1(ref3);
    const _isRef = isRef(ref3);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? canSetSetupRef(ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
          if (isUnmount) {
            isArray(existing) && remove(existing, refValue);
          } else {
            if (!isArray(existing)) {
              if (_isString) {
                refs[ref3] = [refValue];
                if (canSetSetupRef(ref3)) {
                  setupState[ref3] = refs[ref3];
                }
              } else {
                ref3.value = [refValue];
                if (rawRef.k) refs[rawRef.k] = ref3.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref3] = value;
          if (canSetSetupRef(ref3)) {
            setupState[ref3] = value;
          }
        } else if (_isRef) {
          ref3.value = value;
          if (rawRef.k) refs[rawRef.k] = value;
        } else ;
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
getGlobalThis().requestIdleCallback || ((cb) => setTimeout(cb, 1));
getGlobalThis().cancelIdleCallback || ((id) => clearTimeout(id));
const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      pauseTracking();
      const reset = setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      reset();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => {
  if (!isInSSRComponentSetup || lifecycle === "sp") {
    injectHook(lifecycle, (...args) => hook(...args), target);
  }
};
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook(
  "bu"
);
const onUpdated = createHook("u");
const onBeforeUnmount = createHook(
  "bum"
);
const onUnmounted = createHook("um");
const onServerPrefetch = createHook(
  "sp"
);
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
const COMPONENTS = "components";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(component) {
  if (isString$1(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    {
      const selfName = getComponentName(
        Component,
        false
      );
      if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize$1(camelize(name)))) {
        return Component;
      }
    }
    const res = (
      // local registration
      // check instance[type] first which is resolved for options API
      resolve(instance[type] || Component[type], name) || // global registration
      resolve(instance.appContext[type], name)
    );
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[camelize(name)] || registry[capitalize$1(camelize(name))]);
}
function renderList(source, renderItem, cache, index) {
  let ret;
  const cached = cache;
  const sourceIsArray = isArray(source);
  if (sourceIsArray || isString$1(source)) {
    const sourceIsReactiveArray = sourceIsArray && isReactive(source);
    let needsWrap = false;
    let isReadonlySource = false;
    if (sourceIsReactiveArray) {
      needsWrap = !isShallow(source);
      isReadonlySource = isReadonly(source);
      source = shallowReadArray(source);
    }
    ret = new Array(source.length);
    for (let i = 0, l = source.length; i < l; i++) {
      ret[i] = renderItem(
        needsWrap ? isReadonlySource ? toReadonly(toReactive(source[i])) : toReactive(source[i]) : source[i],
        i,
        void 0,
        cached
      );
    }
  } else if (typeof source === "number") {
    ret = new Array(source);
    for (let i = 0; i < source; i++) {
      ret[i] = renderItem(i + 1, i, void 0, cached);
    }
  } else if (isObject$3(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(
        source,
        (item, i) => renderItem(item, i, void 0, cached)
      );
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i = 0, l = keys.length; i < l; i++) {
        const key = keys[i];
        ret[i] = renderItem(source[key], key, i, cached);
      }
    }
  } else {
    ret = [];
  }
  return ret;
}
function createSlots$1(slots, dynamicSlots) {
  for (let i = 0; i < dynamicSlots.length; i++) {
    const slot = dynamicSlots[i];
    if (isArray(slot)) {
      for (let j = 0; j < slot.length; j++) {
        slots[slot[j].name] = slot[j].fn;
      }
    } else if (slot) {
      slots[slot.name] = slot.key ? (...args) => {
        const res = slot.fn(...args);
        if (res) res.key = slot.key;
        return res;
      } : slot.fn;
    }
  }
  return slots;
}
function renderSlot(slots, name, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) {
    if (name !== "default") props.name = name;
    return openBlock(), createBlock(
      Fragment,
      null,
      [createVNode("slot", props, fallback && fallback())],
      64
    );
  }
  let slot = slots[name];
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const slotKey = props.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  validSlotContent && validSlotContent.key;
  const rendered = createBlock(
    Fragment,
    {
      key: (slotKey && !isSymbol(slotKey) ? slotKey : `_${name}`) + // #7256 force differentiate fallback content from actual content
      (!validSlotContent && fallback ? "_fb" : "")
    },
    validSlotContent || (fallback ? fallback() : []),
    validSlotContent && slots._ === 1 ? 64 : -2
  );
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child)) return true;
    if (child.type === Comment) return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
function toHandlers(obj, preserveCaseIfNecessary) {
  const ret = {};
  for (const key in obj) {
    ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : toHandlerKey(key)] = obj[key];
  }
  return ret;
}
const getPublicInstance = (i) => {
  if (!i) return null;
  if (isStatefulComponent(i)) return getComponentPublicInstance(i);
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => i.props,
    $attrs: (i) => i.attrs,
    $slots: (i) => i.slots,
    $refs: (i) => i.refs,
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $host: (i) => i.ce,
    $emit: (i) => i.emit,
    $options: (i) => resolveMergedOptions(i),
    $forceUpdate: (i) => i.f || (i.f = () => {
      queueJob(i.update);
    }),
    $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i) => instanceWatch.bind(i)
  })
);
const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    if (key === "__v_skip") {
      return true;
    }
    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
      ) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance.attrs, "get", "");
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else ;
  },
  set({ _: instance }, key, value) {
    const { data, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({
    _: { data, setupState, accessCache, ctx, appContext, propsOptions }
  }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
function useSlots() {
  return getContext$1().slots;
}
function useAttrs() {
  return getContext$1().attrs;
}
function getContext$1() {
  const i = getCurrentInstance();
  return i.setupContext || (i.setupContext = createSetupContext(i));
}
function normalizePropsOrEmits(props) {
  return isArray(props) ? props.reduce(
    (normalized, p2) => (normalized[p2] = null, normalized),
    {}
  ) : props;
}
function mergeDefaults(raw, defaults) {
  const props = normalizePropsOrEmits(raw);
  for (const key in defaults) {
    if (key.startsWith("__skip")) continue;
    let opt = props[key];
    if (opt) {
      if (isArray(opt) || isFunction$3(opt)) {
        opt = props[key] = { type: opt, default: defaults[key] };
      } else {
        opt.default = defaults[key];
      }
    } else if (opt === null) {
      opt = props[key] = { default: defaults[key] };
    } else ;
    if (opt && defaults[`__skip_${key}`]) {
      opt.skipFactory = true;
    }
  }
  return props;
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(options.beforeCreate, instance, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render: render2,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction$3(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data = dataOptions.call(publicThis, publicThis);
    if (!isObject$3(data)) ;
    else {
      instance.data = reactive(data);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get = isFunction$3(opt) ? opt.bind(publicThis, publicThis) : isFunction$3(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set = !isFunction$3(opt) && isFunction$3(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c = computed({
        get,
        set
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: (v) => c.value = v
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction$3(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook$1(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render2 && instance.render === NOOP) {
    instance.render = render2;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components) instance.components = components;
  if (directives) instance.directives = directives;
  if (serverPrefetch) {
    markAsyncBoundary(instance);
  }
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
  if (isArray(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$3(opt)) {
      if ("default" in opt) {
        injected = inject$1(
          opt.from || key,
          opt.default,
          true
        );
      } else {
        injected = inject$1(opt.from || key);
      }
    } else {
      injected = inject$1(opt);
    }
    if (isRef(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v) => injected.value = v
      });
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook$1(hook, instance, type) {
  callWithAsyncErrorHandling(
    isArray(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
    instance,
    type
  );
}
function createWatcher(raw, ctx, publicThis, key) {
  let getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString$1(raw)) {
    const handler = ctx[raw];
    if (isFunction$3(handler)) {
      {
        watch(getter, handler);
      }
    }
  } else if (isFunction$3(raw)) {
    {
      watch(getter, raw.bind(publicThis));
    }
  } else if (isObject$3(raw)) {
    if (isArray(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = isFunction$3(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction$3(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else ;
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache,
    config: { optionMergeStrategies }
  } = instance.appContext;
  const cached = cache.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
      );
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  if (isObject$3(base)) {
    cache.set(base, resolved);
  }
  return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m) => mergeOptions(to, m, strats, true)
    );
  }
  for (const key in from) {
    if (asMixin && key === "expose") ;
    else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend(
      isFunction$3(to) ? to.call(this, this) : to,
      isFunction$3(from) ? from.call(this, this) : from
    );
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;
}
function mergeEmitsOrPropsOptions(to, from) {
  if (to) {
    if (isArray(to) && isArray(from)) {
      return [.../* @__PURE__ */ new Set([...to, ...from])];
    }
    return extend(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to),
      normalizePropsOrEmits(from != null ? from : {})
    );
  } else {
    return from;
  }
}
function mergeWatchOptions(to, from) {
  if (!to) return from;
  if (!from) return to;
  const merged = extend(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render2, hydrate) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction$3(rootComponent)) {
      rootComponent = extend({}, rootComponent);
    }
    if (rootProps != null && !isObject$3(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new WeakSet();
    const pluginCleanupFns = [];
    let isMounted = false;
    const app = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,
      get config() {
        return context.config;
      },
      set config(v) {
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin)) ;
        else if (plugin && isFunction$3(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app, ...options);
        } else if (isFunction$3(plugin)) {
          installedPlugins.add(plugin);
          plugin(app, ...options);
        } else ;
        return app;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          }
        }
        return app;
      },
      component(name, component) {
        if (!component) {
          return context.components[name];
        }
        context.components[name] = component;
        return app;
      },
      directive(name, directive) {
        if (!directive) {
          return context.directives[name];
        }
        context.directives[name] = directive;
        return app;
      },
      mount(rootContainer, isHydrate, namespace) {
        if (!isMounted) {
          const vnode = app._ceVNode || createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (namespace === true) {
            namespace = "svg";
          } else if (namespace === false) {
            namespace = void 0;
          }
          {
            render2(vnode, rootContainer, namespace);
          }
          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          return getComponentPublicInstance(vnode.component);
        }
      },
      onUnmount(cleanupFn) {
        pluginCleanupFns.push(cleanupFn);
      },
      unmount() {
        if (isMounted) {
          callWithAsyncErrorHandling(
            pluginCleanupFns,
            app._instance,
            16
          );
          render2(null, app._container);
          delete app._container.__vue_app__;
        }
      },
      provide(key, value) {
        context.provides[key] = value;
        return app;
      },
      runWithContext(fn) {
        const lastApp = currentApp$1;
        currentApp$1 = app;
        try {
          return fn();
        } finally {
          currentApp$1 = lastApp;
        }
      }
    };
    return app;
  };
}
let currentApp$1 = null;
function provide(key, value) {
  if (!currentInstance) ;
  else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject$1(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance || currentApp$1) {
    let provides = currentApp$1 ? currentApp$1._context.provides : instance ? instance.parent == null || instance.ce ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$3(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else ;
  }
}
const internalObjectProto = {};
const createInternalObject = () => Object.create(internalObjectProto);
const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = createInternalObject();
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs,
    vnode: { patchFlag }
  } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value,
              instance,
              false
            );
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance.attrs, "set", "");
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(
        options,
        rawCurrentProps,
        key,
        castValues[key],
        instance,
        !hasOwn(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && isFunction$3(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          const reset = setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(
            null,
            props
          );
          reset();
        }
      } else {
        value = defaultValue;
      }
      if (instance.ce) {
        instance.ce._setProp(key, value);
      }
    }
    if (opt[
      0
      /* shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[
        1
        /* shouldCastTrue */
      ] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
const mixinPropsCache = /* @__PURE__ */ new WeakMap();
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = asMixin ? mixinPropsCache : appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction$3(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      extend(normalized, props);
      if (keys) needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$3(comp)) {
      cache.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray(raw)) {
    for (let i = 0; i < raw.length; i++) {
      const normalizedKey = camelize(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray(opt) || isFunction$3(opt) ? { type: opt } : extend({}, opt);
        const propType = prop.type;
        let shouldCast = false;
        let shouldCastTrue = true;
        if (isArray(propType)) {
          for (let index = 0; index < propType.length; ++index) {
            const type = propType[index];
            const typeName = isFunction$3(type) && type.name;
            if (typeName === "Boolean") {
              shouldCast = true;
              break;
            } else if (typeName === "String") {
              shouldCastTrue = false;
            }
          }
        } else {
          shouldCast = isFunction$3(propType) && propType.name === "Boolean";
        }
        prop[
          0
          /* shouldCast */
        ] = shouldCast;
        prop[
          1
          /* shouldCastTrue */
        ] = shouldCastTrue;
        if (shouldCast || hasOwn(prop, "default")) {
          needCastKeys.push(normalizedKey);
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject$3(comp)) {
    cache.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$" && !isReservedProp(key)) {
    return true;
  }
  return false;
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value) => isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false) ;
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key)) continue;
    const value = rawSlots[key];
    if (isFunction$3(value)) {
      slots[key] = normalizeSlot(key, value, ctx);
    } else if (value != null) {
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const assignSlots = (slots, children, optimized) => {
  for (const key in children) {
    if (optimized || !isInternalKey(key)) {
      slots[key] = children[key];
    }
  }
};
const initSlots = (instance, children, optimized) => {
  const slots = instance.slots = createInternalObject();
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      assignSlots(slots, children, optimized);
      if (optimized) {
        def(slots, "_", type, true);
      }
    } else {
      normalizeObjectSlots(children, slots);
    }
  } else if (children) {
    normalizeVNodeSlots(instance, children);
  }
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        assignSlots(slots, children, optimized);
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
        delete slots[key];
      }
    }
  }
};
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target = getGlobalThis();
  target.__VUE__ = true;
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref3, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, namespace);
        }
        break;
      case Fragment:
        processFragment(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else ;
    }
    if (ref3 != null && parentComponent) {
      setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateText(n2.children),
        container,
        anchor
      );
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateComment(n2.children || ""),
        container,
        anchor
      );
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, namespace) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(
      n2.children,
      container,
      anchor,
      namespace,
      n2.el,
      n2.anchor
    );
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    if (n2.type === "svg") {
      namespace = "svg";
    } else if (n2.type === "math") {
      namespace = "mathml";
    }
    if (n1 == null) {
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      patchElement(
        n1,
        n2,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(
      vnode.type,
      namespace,
      props && props.is,
      props
    );
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(
        vnode.children,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(vnode, namespace),
        slotScopeIds,
        optimized
      );
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(el, key, null, props[key], namespace, parentComponent);
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value, namespace);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = needTransition(parentSuspense, transition);
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
    for (let i = start; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
      hostSetElementText(el, "");
    }
    if (dynamicChildren) {
      patchBlockChildren(
        n1.dynamicChildren,
        dynamicChildren,
        el,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds
      );
    } else if (!optimized) {
      patchChildren(
        n1,
        n2,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el, oldProps, newProps, parentComponent, namespace);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, namespace);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(el, key, prev, next, namespace, parentComponent);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el, oldProps, newProps, parentComponent, namespace);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64 | 128)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        true
      );
    }
  };
  const patchProps = (el, oldProps, newProps, parentComponent, namespace) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(
              el,
              key,
              oldProps[key],
              null,
              namespace,
              parentComponent
            );
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key)) continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(el, key, prev, next, namespace, parentComponent);
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        // #10007
        // such fragment like `<></>` will be compiled into
        // a fragment which doesn't have a children.
        // In this case fallback to an empty array
        n2.children || [],
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null || parentComponent && n2 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n1,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(
          n1,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(
          n2,
          container,
          anchor,
          namespace,
          optimized
        );
      } else {
        mountComponent(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          optimized
        );
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
    const instance = initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    );
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance, false, optimized);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
    } else {
      setupRenderEffect(
        instance,
        initialVNode,
        container,
        anchor,
        parentSuspense,
        namespace,
        optimized
      );
    }
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m, parent, root, type } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        {
          if (root.ce) {
            root.ce._injectChildStyle(type);
          }
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(
            null,
            subTree,
            container,
            anchor,
            instance,
            parentSuspense,
            namespace
          );
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u, parent, vnode } = instance;
        {
          const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
          if (nonHydratedAsyncRoot) {
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            }
            nonHydratedAsyncRoot.asyncDep.then(() => {
              if (!instance.isUnmounted) {
                componentUpdateFn();
              }
            });
            return;
          }
        }
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          namespace
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, next, vnode),
            parentSuspense
          );
        }
      }
    };
    instance.scope.on();
    const effect2 = instance.effect = new ReactiveEffect(componentUpdateFn);
    instance.scope.off();
    const update = instance.update = effect2.run.bind(effect2);
    const job = instance.job = effect2.runIfDirty.bind(effect2);
    job.i = instance;
    job.id = instance.uid;
    effect2.scheduler = () => queueJob(job);
    toggleRecurse(instance, true);
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs(instance);
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(
        c1[i],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c1,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(
            null,
            c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(
            prevChild,
            c2[newIndex],
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (moved) {
          if (j < 0 || i !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition2) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove22 = () => {
          if (vnode.ctx.isUnmounted) {
            hostRemove(el);
          } else {
            hostInsert(el, container, anchor);
          }
        };
        const performLeave = () => {
          leave(el, () => {
            remove22();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove22, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type,
      props,
      ref: ref3,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs,
      cacheIndex
    } = vnode;
    if (patchFlag === -2) {
      optimized = false;
    }
    if (ref3 != null) {
      pauseTracking();
      setRef(ref3, null, parentSuspense, vnode, true);
      resetTracking();
    }
    if (cacheIndex != null) {
      parentComponent.renderCache[cacheIndex] = void 0;
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          internals,
          doRemove
        );
      } else if (dynamicChildren && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const {
      bum,
      scope,
      job,
      subTree,
      um,
      m,
      a,
      parent,
      slots: { __: slotCacheKeys }
    } = instance;
    invalidateMount(m);
    invalidateMount(a);
    if (bum) {
      invokeArrayFns(bum);
    }
    if (parent && isArray(slotCacheKeys)) {
      slotCacheKeys.forEach((v) => {
        parent.renderCache[v] = void 0;
      });
    }
    scope.stop();
    if (job) {
      job.flags |= 8;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i = start; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    const el = hostNextSibling(vnode.anchor || vnode.el);
    const teleportEnd = el && el[TeleportEndKey];
    return teleportEnd ? hostNextSibling(teleportEnd) : el;
  };
  let isFlushing = false;
  const render2 = (vnode, container, namespace) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(
        container._vnode || null,
        vnode,
        container,
        null,
        null,
        null,
        namespace
      );
    }
    container._vnode = vnode;
    if (!isFlushing) {
      isFlushing = true;
      flushPreFlushCbs();
      flushPostFlushCbs();
      isFlushing = false;
    }
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  return {
    render: render2,
    hydrate,
    createApp: createAppAPI(render2)
  };
}
function resolveChildrenNamespace({ type, props }, currentNamespace) {
  return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
}
function toggleRecurse({ effect: effect2, job }, allowed) {
  if (allowed) {
    effect2.flags |= 32;
    job.flags |= 4;
  } else {
    effect2.flags &= -33;
    job.flags &= -5;
  }
}
function needTransition(parentSuspense, transition) {
  return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray(ch1) && isArray(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow && c2.patchFlag !== -2)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        c2.el = c1.el;
      }
      if (c2.type === Comment && !c2.el) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i, j, u, v, c;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p2[i] = j;
        result.push(i);
        continue;
      }
      u = 0;
      v = result.length - 1;
      while (u < v) {
        c = u + v >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p2[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = result.length;
  v = result[u - 1];
  while (u-- > 0) {
    result[u] = v;
    v = p2[v];
  }
  return result;
}
function locateNonHydratedAsyncRoot(instance) {
  const subComponent = instance.subTree.component;
  if (subComponent) {
    if (subComponent.asyncDep && !subComponent.asyncResolved) {
      return subComponent;
    } else {
      return locateNonHydratedAsyncRoot(subComponent);
    }
  }
}
function invalidateMount(hooks) {
  if (hooks) {
    for (let i = 0; i < hooks.length; i++)
      hooks[i].flags |= 8;
  }
}
const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = () => {
  {
    const ctx = inject$1(ssrContextKey);
    return ctx;
  }
};
function watchEffect(effect2, options) {
  return doWatch(effect2, null, options);
}
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, options = EMPTY_OBJ) {
  const { immediate, deep, flush, once } = options;
  const baseWatchOptions = extend({}, options);
  const runsImmediately = cb && immediate || !cb && flush !== "post";
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else if (!runsImmediately) {
      const watchStopHandle = () => {
      };
      watchStopHandle.stop = NOOP;
      watchStopHandle.resume = NOOP;
      watchStopHandle.pause = NOOP;
      return watchStopHandle;
    }
  }
  const instance = currentInstance;
  baseWatchOptions.call = (fn, type, args) => callWithAsyncErrorHandling(fn, instance, type, args);
  let isPre = false;
  if (flush === "post") {
    baseWatchOptions.scheduler = (job) => {
      queuePostRenderEffect(job, instance && instance.suspense);
    };
  } else if (flush !== "sync") {
    isPre = true;
    baseWatchOptions.scheduler = (job, isFirstRun) => {
      if (isFirstRun) {
        job();
      } else {
        queueJob(job);
      }
    };
  }
  baseWatchOptions.augmentJob = (job) => {
    if (cb) {
      job.flags |= 4;
    }
    if (isPre) {
      job.flags |= 2;
      if (instance) {
        job.id = instance.uid;
        job.i = instance;
      }
    }
  };
  const watchHandle = watch$1(source, cb, baseWatchOptions);
  if (isInSSRComponentSetup) {
    if (ssrCleanup) {
      ssrCleanup.push(watchHandle);
    } else if (runsImmediately) {
      watchHandle();
    }
  }
  return watchHandle;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString$1(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction$3(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const reset = setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  reset();
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
const getModelModifiers = (props, modelName) => {
  return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${camelize(modelName)}Modifiers`] || props[`${hyphenate(modelName)}Modifiers`];
};
function emit(instance, event, ...rawArgs) {
  if (instance.isUnmounted) return;
  const props = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modifiers = isModelListener2 && getModelModifiers(props, event.slice(7));
  if (modifiers) {
    if (modifiers.trim) {
      args = rawArgs.map((a) => isString$1(a) ? a.trim() : a);
    }
    if (modifiers.number) {
      args = rawArgs.map(looseToNumber);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
  props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(
      handler,
      instance,
      6,
      args
    );
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance,
      6,
      args
    );
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction$3(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$3(comp)) {
      cache.set(comp, null);
    }
    return null;
  }
  if (isArray(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend(normalized, raw);
  }
  if (isObject$3(comp)) {
    cache.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit: emit2,
    render: render2,
    renderCache,
    props,
    data,
    setupState,
    ctx,
    inheritAttrs
  } = instance;
  const prev = setCurrentRenderingInstance(instance);
  let result;
  let fallthroughAttrs;
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      const thisProxy = false ? new Proxy(proxyToUse, {
        get(target, key, receiver) {
          warn$1(
            `Property '${String(
              key
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
          );
          return Reflect.get(target, key, receiver);
        }
      }) : proxyToUse;
      result = normalizeVNode(
        render2.call(
          thisProxy,
          proxyToUse,
          renderCache,
          false ? shallowReadonly(props) : props,
          setupState,
          data,
          ctx
        )
      );
      fallthroughAttrs = attrs;
    } else {
      const render22 = Component;
      if (false) ;
      result = normalizeVNode(
        render22.length > 1 ? render22(
          false ? shallowReadonly(props) : props,
          false ? {
            get attrs() {
              markAttrsAccessed();
              return shallowReadonly(attrs);
            },
            slots,
            emit: emit2
          } : { attrs, slots, emit: emit2 }
        ) : render22(
          false ? shallowReadonly(props) : props,
          null
        )
      );
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root = cloneVNode(root, fallthroughAttrs, false, true);
      }
    }
  }
  if (vnode.dirs) {
    root = cloneVNode(root, null, false, true);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    setTransitionHooks(root, vnode.transition);
  }
  {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent) {
    const root = parent.subTree;
    if (root.suspense && root.suspense.activeBranch === vnode) {
      root.el = vnode.el;
    }
    if (root === vnode) {
      (vnode = parent.vnode).el = el;
      parent = parent.parent;
    } else {
      break;
    }
  }
}
const isSuspense = (type) => type.__isSuspense;
const SuspenseImpl = {};
const Suspense = SuspenseImpl;
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value, inVOnce = false) {
  isBlockTreeEnabled += value;
  if (value < 0 && currentBlock && inVOnce) {
    currentBlock.hasOnce = true;
  }
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(
    createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
    )
  );
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(
    createVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      true
    )
  );
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({
  ref: ref3,
  ref_key,
  ref_for
}) => {
  if (typeof ref3 === "number") {
    ref3 = "" + ref3;
  }
  return ref3 != null ? isString$1(ref3) || isRef(ref3) || isFunction$3(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString$1(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(
      type,
      props,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag = -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !isString$1(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject$3(style)) {
      if (isProxy(style) && !isArray(style)) {
        style = extend({}, style);
      }
      props.style = normalizeStyle(style);
    }
  }
  const shapeFlag = isString$1(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$3(type) ? 4 : isFunction$3(type) ? 2 : 0;
  return createBaseVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
function guardReactiveProps(props) {
  if (!props) return null;
  return isProxy(props) || isInternalObject(props) ? extend({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
  const { props, ref: ref3, patchFlag, children, transition } = vnode;
  const mergedProps = extraProps ? mergeProps$1(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref3 ? isArray(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref3,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children,
    target: vnode.target,
    targetStart: vnode.targetStart,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  if (transition && cloneTransition) {
    setTransitionHooks(
      cloned,
      transition.clone(cloned)
    );
  }
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (isVNode(child)) {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !isInternalObject(children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction$3(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps$1(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    ids: parent ? parent.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let setInSSRSetupState;
{
  const g = getGlobalThis();
  const registerGlobalSetter = (key, setter) => {
    let setters;
    if (!(setters = g[key])) setters = g[key] = [];
    setters.push(setter);
    return (v) => {
      if (setters.length > 1) setters.forEach((set) => set(v));
      else setters[0](v);
    };
  };
  internalSetCurrentInstance = registerGlobalSetter(
    `__VUE_INSTANCE_SETTERS__`,
    (v) => currentInstance = v
  );
  setInSSRSetupState = registerGlobalSetter(
    `__VUE_SSR_SETTERS__`,
    (v) => isInSSRComponentSetup = v
  );
}
const setCurrentInstance = (instance) => {
  const prev = currentInstance;
  internalSetCurrentInstance(instance);
  instance.scope.on();
  return () => {
    instance.scope.off();
    internalSetCurrentInstance(prev);
  };
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false, optimized = false) {
  isSSR && setInSSRSetupState(isSSR);
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children, optimized || isSSR);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isSSR && setInSSRSetupState(false);
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
  const { setup } = Component;
  if (setup) {
    pauseTracking();
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    const reset = setCurrentInstance(instance);
    const setupResult = callWithErrorHandling(
      setup,
      instance,
      0,
      [
        instance.props,
        setupContext
      ]
    );
    const isAsyncSetup = isPromise$1(setupResult);
    resetTracking();
    reset();
    if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {
      markAsyncBoundary(instance);
    }
    if (isAsyncSetup) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult);
        }).catch((e) => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult);
    }
  } else {
    finishComponentSetup(instance);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction$3(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject$3(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else ;
  finishComponentSetup(instance);
}
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    instance.render = Component.render || NOOP;
  }
  {
    const reset = setCurrentInstance(instance);
    pauseTracking();
    try {
      applyOptions(instance);
    } finally {
      resetTracking();
      reset();
    }
  }
}
const attrsProxyHandlers = {
  get(target, key) {
    track(target, "get", "");
    return target[key];
  }
};
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  {
    return {
      attrs: new Proxy(instance.attrs, attrsProxyHandlers),
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getComponentPublicInstance(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  } else {
    return instance.proxy;
  }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
  return isFunction$3(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance, Component, isRoot = false) {
  let name = getComponentName(Component);
  if (!name && Component.__file) {
    const match = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match) {
      name = match[1];
    }
  }
  if (!name && instance && instance.parent) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };
    name = inferFromRegistry(
      instance.components || instance.parent.type.components
    ) || inferFromRegistry(instance.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
  return isFunction$3(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  const c = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
  return c;
};
function h(type, propsOrChildren, children) {
  const l = arguments.length;
  if (l === 2) {
    if (isObject$3(propsOrChildren) && !isArray(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}
const version = "3.5.16";
/**
* @vue/runtime-dom v3.5.16
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let policy = void 0;
const tt = typeof window !== "undefined" && window.trustedTypes;
if (tt) {
  try {
    policy = /* @__PURE__ */ tt.createPolicy("vue", {
      createHTML: (val) => val
    });
  } catch (e) {
  }
}
const unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;
const svgNS = "http://www.w3.org/2000/svg";
const mathmlNS = "http://www.w3.org/1998/Math/MathML";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, namespace, is, props) => {
    const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, namespace, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling)) break;
      }
    } else {
      templateContainer.innerHTML = unsafeToTrustedHTML(
        namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content
      );
      const template = templateContainer.content;
      if (namespace === "svg" || namespace === "mathml") {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
const TRANSITION = "transition";
const ANIMATION = "animation";
const vtcKey = Symbol("_vtc");
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = /* @__PURE__ */ extend(
  {},
  BaseTransitionPropsValidators,
  DOMTransitionPropsValidators
);
const decorate$1 = (t) => {
  t.displayName = "Transition";
  t.props = TransitionPropsValidators;
  return t;
};
const Transition = /* @__PURE__ */ decorate$1(
  (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots)
);
const callHook = (hook, args = []) => {
  if (isArray(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const {
    name = "v",
    type,
    duration,
    enterFromClass = `${name}-enter-from`,
    enterActiveClass = `${name}-enter-active`,
    enterToClass = `${name}-enter-to`,
    appearFromClass = enterFromClass,
    appearActiveClass = enterActiveClass,
    appearToClass = enterToClass,
    leaveFromClass = `${name}-leave-from`,
    leaveActiveClass = `${name}-leave-active`,
    leaveToClass = `${name}-leave-to`
  } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const {
    onBeforeEnter,
    onEnter,
    onEnterCancelled,
    onLeave,
    onLeaveCancelled,
    onBeforeAppear = onBeforeEnter,
    onAppear = onEnter,
    onAppearCancelled = onEnterCancelled
  } = baseProps;
  const finishEnter = (el, isAppear, done, isCancelled) => {
    el._enterCancelled = isCancelled;
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el, done) => {
    el._isLeaving = false;
    removeTransitionClass(el, leaveFromClass);
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve2 = () => finishEnter(el, isAppear, done);
      callHook(hook, [el, resolve2]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve2);
        }
      });
    };
  };
  return extend(baseProps, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      el._isLeaving = true;
      const resolve2 = () => finishLeave(el, done);
      addTransitionClass(el, leaveFromClass);
      if (!el._enterCancelled) {
        forceReflow();
        addTransitionClass(el, leaveActiveClass);
      } else {
        addTransitionClass(el, leaveActiveClass);
        forceReflow();
      }
      nextFrame(() => {
        if (!el._isLeaving) {
          return;
        }
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type, leaveDuration, resolve2);
        }
      });
      callHook(onLeave, [el, resolve2]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false, void 0, true);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true, void 0, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject$3(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n = NumberOf(duration);
    return [n, n];
  }
}
function NumberOf(val) {
  const res = toNumber(val);
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
  (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el[vtcKey] = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
  const id = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id === el._endId) {
      resolve2();
    }
  };
  if (explicitTimeout != null) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
  if (!type) {
    return resolve2();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e) => {
    if (e.target === el && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
    getStyleProperties(`${TRANSITION}Property`).toString()
  );
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
}
function toMs(s) {
  if (s === "auto") return 0;
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
function patchClass(el, value, isSVG) {
  const transitionClasses = el[vtcKey];
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}
const vShowOriginalDisplay = Symbol("_vod");
const vShowHidden = Symbol("_vsh");
const vShow = {
  beforeMount(el, { value }, { transition }) {
    el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
    if (transition && value) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value);
    }
  },
  mounted(el, { value }, { transition }) {
    if (transition && value) {
      transition.enter(el);
    }
  },
  updated(el, { value, oldValue }, { transition }) {
    if (!value === !oldValue) return;
    if (transition) {
      if (value) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, () => {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value);
    }
  },
  beforeUnmount(el, { value }) {
    setDisplay(el, value);
  }
};
function setDisplay(el, value) {
  el.style.display = value ? el[vShowOriginalDisplay] : "none";
  el[vShowHidden] = !value;
}
const CSS_VAR_TEXT = Symbol("");
const displayRE = /(^|;)\s*display\s*:/;
function patchStyle(el, prev, next) {
  const style = el.style;
  const isCssString = isString$1(next);
  let hasControlledDisplay = false;
  if (next && !isCssString) {
    if (prev) {
      if (!isString$1(prev)) {
        for (const key in prev) {
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      } else {
        for (const prevStyle of prev.split(";")) {
          const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      }
    }
    for (const key in next) {
      if (key === "display") {
        hasControlledDisplay = true;
      }
      setStyle(style, key, next[key]);
    }
  } else {
    if (isCssString) {
      if (prev !== next) {
        const cssVarText = style[CSS_VAR_TEXT];
        if (cssVarText) {
          next += ";" + cssVarText;
        }
        style.cssText = next;
        hasControlledDisplay = displayRE.test(next);
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
  }
  if (vShowOriginalDisplay in el) {
    el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
    if (el[vShowHidden]) {
      style.display = "none";
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
  if (isArray(val)) {
    val.forEach((v) => setStyle(style, name, v));
  } else {
    if (val == null) val = "";
    if (name.startsWith("--")) {
      style.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style, name);
      if (importantRE.test(val)) {
        style.setProperty(
          hyphenate(prefixed),
          val.replace(importantRE, ""),
          "important"
        );
      } else {
        style[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style) {
    return prefixCache[rawName] = name;
  }
  name = capitalize$1(name);
  for (let i = 0; i < prefixes.length; i++) {
    const prefixed = prefixes[i] + name;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance, isBoolean = isSpecialBooleanAttr(key)) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    if (value == null || isBoolean && !includeBooleanAttr(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(
        key,
        isBoolean ? "" : isSymbol(value) ? String(value) : value
      );
    }
  }
}
function patchDOMProp(el, key, value, parentComponent, attrName) {
  if (key === "innerHTML" || key === "textContent") {
    if (value != null) {
      el[key] = key === "innerHTML" ? unsafeToTrustedHTML(value) : value;
    }
    return;
  }
  const tag = el.tagName;
  if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
  !tag.includes("-")) {
    const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
    const newValue = value == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      el.type === "checkbox" ? "on" : ""
    ) : String(value);
    if (oldValue !== newValue || !("_value" in el)) {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    el._value = value;
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value;
  } catch (e) {
  }
  needRemove && el.removeAttribute(attrName || key);
}
function addEventListener$1(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener$1(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
const veiKey = Symbol("_vei");
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el[veiKey] || (el[veiKey] = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(
        nextValue,
        instance
      );
      addEventListener$1(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener$1(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m;
    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(
      patchStopImmediatePropagation(e, invoker.value),
      instance,
      5,
      [e]
    );
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value) {
  if (isArray(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map(
      (fn) => (e2) => !e2._stopped && fn && fn(e2)
    );
  } else {
    return value;
  }
}
const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
const patchProp = (el, key, prevValue, nextValue, namespace, parentComponent) => {
  const isSVG = namespace === "svg";
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(el, key, nextValue);
    if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
      patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
    }
  } else if (
    // #11081 force set props for possible async custom element
    el._isVueCE && (/[A-Z]/.test(key) || !isString$1(nextValue))
  ) {
    patchDOMProp(el, camelize(key), nextValue, parentComponent, key);
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && isNativeOn(key) && isFunction$3(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate" || key === "autocorrect") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (key === "width" || key === "height") {
    const tag = el.tagName;
    if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
      return false;
    }
  }
  if (isNativeOn(key) && isString$1(value)) {
    return false;
  }
  return key in el;
}
const positionMap = /* @__PURE__ */ new WeakMap();
const newPositionMap = /* @__PURE__ */ new WeakMap();
const moveCbKey = Symbol("_moveCb");
const enterCbKey = Symbol("_enterCb");
const decorate = (t) => {
  delete t.props.mode;
  return t;
};
const TransitionGroupImpl = /* @__PURE__ */ decorate({
  name: "TransitionGroup",
  props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevChildren;
    let children;
    onUpdated(() => {
      if (!prevChildren.length) {
        return;
      }
      const moveClass = props.moveClass || `${props.name || "v"}-move`;
      if (!hasCSSTransform(
        prevChildren[0].el,
        instance.vnode.el,
        moveClass
      )) {
        prevChildren = [];
        return;
      }
      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      const movedChildren = prevChildren.filter(applyTranslation);
      forceReflow();
      movedChildren.forEach((c) => {
        const el = c.el;
        const style = el.style;
        addTransitionClass(el, moveClass);
        style.transform = style.webkitTransform = style.transitionDuration = "";
        const cb = el[moveCbKey] = (e) => {
          if (e && e.target !== el) {
            return;
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener("transitionend", cb);
            el[moveCbKey] = null;
            removeTransitionClass(el, moveClass);
          }
        };
        el.addEventListener("transitionend", cb);
      });
      prevChildren = [];
    });
    return () => {
      const rawProps = toRaw(props);
      const cssTransitionProps = resolveTransitionProps(rawProps);
      let tag = rawProps.tag || Fragment;
      prevChildren = [];
      if (children) {
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if (child.el && child.el instanceof Element) {
            prevChildren.push(child);
            setTransitionHooks(
              child,
              resolveTransitionHooks(
                child,
                cssTransitionProps,
                state,
                instance
              )
            );
            positionMap.set(
              child,
              child.el.getBoundingClientRect()
            );
          }
        }
      }
      children = slots.default ? getTransitionRawChildren(slots.default()) : [];
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (child.key != null) {
          setTransitionHooks(
            child,
            resolveTransitionHooks(child, cssTransitionProps, state, instance)
          );
        }
      }
      return createVNode(tag, null, children);
    };
  }
});
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
  const el = c.el;
  if (el[moveCbKey]) {
    el[moveCbKey]();
  }
  if (el[enterCbKey]) {
    el[enterCbKey]();
  }
}
function recordPosition(c) {
  newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
  const oldPos = positionMap.get(c);
  const newPos = newPositionMap.get(c);
  const dx = oldPos.left - newPos.left;
  const dy = oldPos.top - newPos.top;
  if (dx || dy) {
    const s = c.el.style;
    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
    s.transitionDuration = "0s";
    return c;
  }
}
function hasCSSTransform(el, root, moveClass) {
  const clone = el.cloneNode();
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.forEach((cls) => {
      cls.split(/\s+/).forEach((c) => c && clone.classList.remove(c));
    });
  }
  moveClass.split(/\s+/).forEach((c) => c && clone.classList.add(c));
  clone.style.display = "none";
  const container = root.nodeType === 1 ? root : root.parentNode;
  container.appendChild(clone);
  const { hasTransform } = getTransitionInfo(clone);
  container.removeChild(clone);
  return hasTransform;
}
const getModelAssigner = (vnode) => {
  const fn = vnode.props["onUpdate:modelValue"] || false;
  return isArray(fn) ? (value) => invokeArrayFns(fn, value) : fn;
};
function onCompositionStart(e) {
  e.target.composing = true;
}
function onCompositionEnd(e) {
  const target = e.target;
  if (target.composing) {
    target.composing = false;
    target.dispatchEvent(new Event("input"));
  }
}
const assignKey = Symbol("_assign");
const vModelText = {
  created(el, { modifiers: { lazy, trim, number } }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    const castToNumber = number || vnode.props && vnode.props.type === "number";
    addEventListener$1(el, lazy ? "change" : "input", (e) => {
      if (e.target.composing) return;
      let domValue = el.value;
      if (trim) {
        domValue = domValue.trim();
      }
      if (castToNumber) {
        domValue = looseToNumber(domValue);
      }
      el[assignKey](domValue);
    });
    if (trim) {
      addEventListener$1(el, "change", () => {
        el.value = el.value.trim();
      });
    }
    if (!lazy) {
      addEventListener$1(el, "compositionstart", onCompositionStart);
      addEventListener$1(el, "compositionend", onCompositionEnd);
      addEventListener$1(el, "change", onCompositionEnd);
    }
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(el, { value }) {
    el.value = value == null ? "" : value;
  },
  beforeUpdate(el, { value, oldValue, modifiers: { lazy, trim, number } }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    if (el.composing) return;
    const elValue = (number || el.type === "number") && !/^0\d/.test(el.value) ? looseToNumber(el.value) : el.value;
    const newValue = value == null ? "" : value;
    if (elValue === newValue) {
      return;
    }
    if (document.activeElement === el && el.type !== "range") {
      if (lazy && value === oldValue) {
        return;
      }
      if (trim && el.value.trim() === newValue) {
        return;
      }
    }
    el.value = newValue;
  }
};
const vModelCheckbox = {
  // #4096 array checkboxes need to be deep traversed
  deep: true,
  created(el, _, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    addEventListener$1(el, "change", () => {
      const modelValue = el._modelValue;
      const elementValue = getValue(el);
      const checked = el.checked;
      const assign = el[assignKey];
      if (isArray(modelValue)) {
        const index = looseIndexOf(modelValue, elementValue);
        const found = index !== -1;
        if (checked && !found) {
          assign(modelValue.concat(elementValue));
        } else if (!checked && found) {
          const filtered = [...modelValue];
          filtered.splice(index, 1);
          assign(filtered);
        }
      } else if (isSet(modelValue)) {
        const cloned = new Set(modelValue);
        if (checked) {
          cloned.add(elementValue);
        } else {
          cloned.delete(elementValue);
        }
        assign(cloned);
      } else {
        assign(getCheckboxValue(el, checked));
      }
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: setChecked,
  beforeUpdate(el, binding, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    setChecked(el, binding, vnode);
  }
};
function setChecked(el, { value, oldValue }, vnode) {
  el._modelValue = value;
  let checked;
  if (isArray(value)) {
    checked = looseIndexOf(value, vnode.props.value) > -1;
  } else if (isSet(value)) {
    checked = value.has(vnode.props.value);
  } else {
    if (value === oldValue) return;
    checked = looseEqual(value, getCheckboxValue(el, true));
  }
  if (el.checked !== checked) {
    el.checked = checked;
  }
}
const vModelRadio = {
  created(el, { value }, vnode) {
    el.checked = looseEqual(value, vnode.props.value);
    el[assignKey] = getModelAssigner(vnode);
    addEventListener$1(el, "change", () => {
      el[assignKey](getValue(el));
    });
  },
  beforeUpdate(el, { value, oldValue }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    if (value !== oldValue) {
      el.checked = looseEqual(value, vnode.props.value);
    }
  }
};
const vModelSelect = {
  // <select multiple> value need to be deep traversed
  deep: true,
  created(el, { value, modifiers: { number } }, vnode) {
    const isSetModel = isSet(value);
    addEventListener$1(el, "change", () => {
      const selectedVal = Array.prototype.filter.call(el.options, (o) => o.selected).map(
        (o) => number ? looseToNumber(getValue(o)) : getValue(o)
      );
      el[assignKey](
        el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]
      );
      el._assigning = true;
      nextTick(() => {
        el._assigning = false;
      });
    });
    el[assignKey] = getModelAssigner(vnode);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(el, { value }) {
    setSelected(el, value);
  },
  beforeUpdate(el, _binding, vnode) {
    el[assignKey] = getModelAssigner(vnode);
  },
  updated(el, { value }) {
    if (!el._assigning) {
      setSelected(el, value);
    }
  }
};
function setSelected(el, value) {
  const isMultiple2 = el.multiple;
  const isArrayValue = isArray(value);
  if (isMultiple2 && !isArrayValue && !isSet(value)) {
    return;
  }
  for (let i = 0, l = el.options.length; i < l; i++) {
    const option = el.options[i];
    const optionValue = getValue(option);
    if (isMultiple2) {
      if (isArrayValue) {
        const optionType = typeof optionValue;
        if (optionType === "string" || optionType === "number") {
          option.selected = value.some((v) => String(v) === String(optionValue));
        } else {
          option.selected = looseIndexOf(value, optionValue) > -1;
        }
      } else {
        option.selected = value.has(optionValue);
      }
    } else if (looseEqual(getValue(option), value)) {
      if (el.selectedIndex !== i) el.selectedIndex = i;
      return;
    }
  }
  if (!isMultiple2 && el.selectedIndex !== -1) {
    el.selectedIndex = -1;
  }
}
function getValue(el) {
  return "_value" in el ? el._value : el.value;
}
function getCheckboxValue(el, checked) {
  const key = checked ? "_trueValue" : "_falseValue";
  return key in el ? el[key] : checked;
}
const vModelDynamic = {
  created(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "created");
  },
  mounted(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "mounted");
  },
  beforeUpdate(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
  },
  updated(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "updated");
  }
};
function resolveDynamicModel(tagName, type) {
  switch (tagName) {
    case "SELECT":
      return vModelSelect;
    case "TEXTAREA":
      return vModelText;
    default:
      switch (type) {
        case "checkbox":
          return vModelCheckbox;
        case "radio":
          return vModelRadio;
        default:
          return vModelText;
      }
  }
}
function callModelHook(el, binding, vnode, prevVNode, hook) {
  const modelToUse = resolveDynamicModel(
    el.tagName,
    vnode.props && vnode.props.type
  );
  const fn = modelToUse[hook];
  fn && fn(el, binding, vnode, prevVNode);
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
};
const withModifiers = (fn, modifiers) => {
  const cache = fn._withMods || (fn._withMods = {});
  const cacheKey = modifiers.join(".");
  return cache[cacheKey] || (cache[cacheKey] = (event, ...args) => {
    for (let i = 0; i < modifiers.length; i++) {
      const guard = modifierGuards[modifiers[i]];
      if (guard && guard(event, modifiers)) return;
    }
    return fn(event, ...args);
  });
};
const keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
const withKeys = (fn, modifiers) => {
  const cache = fn._withKeys || (fn._withKeys = {});
  const cacheKey = modifiers.join(".");
  return cache[cacheKey] || (cache[cacheKey] = (event) => {
    if (!("key" in event)) {
      return;
    }
    const eventKey = hyphenate(event.key);
    if (modifiers.some(
      (k) => k === eventKey || keyNames[k] === eventKey
    )) {
      return fn(event);
    }
  });
};
const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
let renderer;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
const render = (...args) => {
  ensureRenderer().render(...args);
};
const createApp = (...args) => {
  const app = ensureRenderer().createApp(...args);
  const { mount: mount2 } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container) return;
    const component = app._component;
    if (!isFunction$3(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    if (container.nodeType === 1) {
      container.textContent = "";
    }
    const proxy = mount2(container, false, resolveRootNamespace(container));
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app;
};
function resolveRootNamespace(container) {
  if (container instanceof SVGElement) {
    return "svg";
  }
  if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
    return "mathml";
  }
}
function normalizeContainer(container) {
  if (isString$1(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
const presets = {
  light: {
    // Accent
    primary: "#154EC1",
    secondary: "#767C88",
    success: "#3D9209",
    info: "#158DE3",
    danger: "#E42222",
    warning: "#FFD43A",
    // Background Colors
    backgroundPrimary: "#f6f6f6",
    backgroundSecondary: "#FFFFFF",
    backgroundElement: "#ECF0F1",
    backgroundBorder: "#DEE5F2",
    // Text Colors
    textPrimary: "#262824",
    textInverted: "#FFFFFF",
    // Misc
    shadow: "rgba(0, 0, 0, 0.12)",
    focus: "#49A8FF",
    transparent: "rgba(0, 0, 0, 0)"
  },
  dark: {
    // Accent
    primary: "#3472F0",
    secondary: "#767C88",
    success: "#66BE33",
    info: "#3EAAF8",
    danger: "#F34030",
    warning: "#FFD952",
    // Background Colors
    backgroundPrimary: "#050A10",
    backgroundSecondary: "#1F262F",
    backgroundElement: "#131A22",
    backgroundBorder: "#3D4C58",
    // Text Colors
    textPrimary: "#F1F1F1",
    textInverted: "#0B121A",
    // Misc
    shadow: "rgba(255, 255, 255, 0.12)",
    focus: "#49A8FF",
    transparent: "rgba(0, 0, 0, 0)"
  }
};
const vaBreakpointSymbol = Symbol("vaBreakpoint");
const defaultThresholds = {
  xs: 0,
  sm: 640,
  md: 1024,
  lg: 1440,
  xl: 1920
};
const getBreakpointDefaultConfig = () => ({
  enabled: true,
  bodyClass: true,
  thresholds: defaultThresholds
});
const renderSlotNode$1 = (node, ctx = null) => {
  return withCtx(() => [node], ctx);
};
const makeVNode = (node) => {
  if (typeof node === "string") {
    return h(Text, node);
  }
  return isVNode(node) ? node : createBlock(node);
};
const renderSlots = (slots, ctx = null) => {
  return Object.keys(slots).reduce((acc, slotName) => {
    const slot = slots[slotName];
    acc[slotName] = typeof slot === "function" ? slot : renderSlotNode$1(slot, ctx);
    return acc;
  }, {});
};
const createRenderFn = (component) => {
  const originalRenderFn = component.render || component.ssrRender;
  if (!originalRenderFn) {
    return void 0;
  }
  const compiledRenderedFn = originalRenderFn.name === "_sfc_render" || originalRenderFn.name === "_sfc_ssrRender";
  return function(...args) {
    const ctx = args[0];
    const slots = ctx.$.slots;
    const customCtx = new Proxy(ctx, {
      get(target, key) {
        if (key === "$slots") {
          return renderSlots(slots);
        }
        return target[key];
      }
    });
    const thisArg = compiledRenderedFn ? void 0 : customCtx;
    return originalRenderFn.call(thisArg, customCtx, ...args.slice(1));
  };
};
const omit = (o, keys) => {
  return Object.keys(o).filter((key) => !keys.includes(key)).reduce((acc, key) => {
    acc[key] = o[key];
    return acc;
  }, {});
};
const CHILD_COMPONENT_PROP_PREFIX = "child:";
const CHILD_COMPONENTS_INJECT_KEY = "$va:childComponents";
const defineChildProps = (obj) => {
  return Object.keys(obj).reduce((acc, key) => {
    const childName = `${CHILD_COMPONENT_PROP_PREFIX}${key}`;
    acc[childName] = {
      type: Object,
      required: false,
      default: void 0
    };
    return acc;
  }, {});
};
const useChildComponents = (props) => {
  const childProps = computed(() => {
    const propNames = Object.keys(props);
    return propNames.reduce((acc, propName) => {
      if (propName.startsWith(CHILD_COMPONENT_PROP_PREFIX)) {
        const childName = propName.slice(CHILD_COMPONENT_PROP_PREFIX.length);
        acc[childName] = props[propName];
      }
      return acc;
    }, {});
  });
  provide(CHILD_COMPONENTS_INJECT_KEY, childProps);
};
const injectChildPropsFromParent = () => {
  var _a2;
  const childName = (_a2 = getCurrentInstance()) == null ? void 0 : _a2.attrs["va-child"];
  if (!childName) {
    return null;
  }
  const childProps = inject$1(CHILD_COMPONENTS_INJECT_KEY);
  if (!(childProps == null ? void 0 : childProps.value)) {
    return null;
  }
  return computed(() => childProps.value[childName]);
};
const KEBAB_CASE_REGEX = /([a-z0-9])([A-Z])/g;
const toKebabCase = (str) => str.replace(KEBAB_CASE_REGEX, "$1-$2").toLowerCase();
const findCamelCased = (obj, key) => {
  if (key in obj) {
    return obj[key];
  }
  return obj[toKebabCase(key)];
};
const createProps = (instance, propsFromConfig) => {
  const instanceProps = instance.props;
  const childPropsFromParent = injectChildPropsFromParent();
  return new Proxy(instanceProps, {
    get: (target, key) => {
      var _a2, _b;
      if (typeof key !== "string") {
        return target[key];
      }
      const childProp = (_a2 = childPropsFromParent == null ? void 0 : childPropsFromParent.value) == null ? void 0 : _a2[key];
      if (childProp !== void 0) {
        return childProp;
      }
      const incomingProps = instance.vnode.props || {};
      const originalProp = target[key];
      const incomingProp = findCamelCased(incomingProps, key);
      if (incomingProp !== void 0) {
        return originalProp;
      }
      const propFromConfig = (_b = propsFromConfig.value) == null ? void 0 : _b[key];
      if (propFromConfig !== void 0) {
        return propFromConfig;
      }
      return originalProp;
    }
  });
};
const createAttrs = (instance, propsFromConfig) => {
  const instanceAttrs = instance.attrs;
  return new Proxy(instanceAttrs, {
    get: (target, key) => {
      var _a2;
      if (typeof key !== "string") {
        return target[key];
      }
      if (key === "class") {
        return normalizeClass([propsFromConfig.value.class, instanceAttrs.class]);
      }
      if (key === "style") {
        return normalizeStyle([propsFromConfig.value.style, instanceAttrs.style]);
      }
      const attrFromConfig = (_a2 = propsFromConfig.value) == null ? void 0 : _a2[key];
      if (attrFromConfig !== void 0) {
        return attrFromConfig;
      }
      return target[key];
    },
    ownKeys(target) {
      return [.../* @__PURE__ */ new Set([...Object.keys(instanceAttrs), ...Object.keys(propsFromConfig.value)])];
    },
    getOwnPropertyDescriptor(target, key) {
      return Reflect.getOwnPropertyDescriptor(propsFromConfig.value, key) ?? Reflect.getOwnPropertyDescriptor(instanceAttrs, key);
    }
  });
};
const SLOT_PREFIX = "slot:";
const createSlots = (instance, propsFromConfig) => {
  const instanceSlots = instance.slots;
  const childPropsFromParent = injectChildPropsFromParent();
  const slotsFromConfig = computed(() => {
    return Object.keys(propsFromConfig.value).reduce((acc, key) => {
      if (key.startsWith(SLOT_PREFIX)) {
        acc[key.slice(SLOT_PREFIX.length)] = propsFromConfig.value[key];
      }
      return acc;
    }, {});
  });
  return new Proxy(instanceSlots, {
    get: (target, key) => {
      var _a2, _b;
      if (typeof key !== "string") {
        return target[key];
      }
      const prefixedKey = `${SLOT_PREFIX}${key}`;
      const childSlot = (_a2 = childPropsFromParent == null ? void 0 : childPropsFromParent.value) == null ? void 0 : _a2[prefixedKey];
      if (childSlot !== void 0) {
        return renderSlotNode$1(makeVNode(childSlot));
      }
      const originalSlot = target[key];
      if (originalSlot !== void 0) {
        return originalSlot;
      }
      const propFromConfig = (_b = slotsFromConfig.value) == null ? void 0 : _b[key];
      if (propFromConfig !== void 0) {
        return renderSlotNode$1(makeVNode(propFromConfig));
      }
      return originalSlot;
    },
    ownKeys(target) {
      return [.../* @__PURE__ */ new Set([...Object.keys(instanceSlots), ...Object.keys(slotsFromConfig.value)])];
    },
    getOwnPropertyDescriptor(target, key) {
      return Reflect.getOwnPropertyDescriptor(slotsFromConfig.value, key) ?? Reflect.getOwnPropertyDescriptor(instanceSlots, key);
    }
  });
};
const LocalConfigKey = "VaLocalConfig";
const CONFIGS_DEFAULT = computed(() => []);
function useLocalConfig() {
  return inject$1(LocalConfigKey, CONFIGS_DEFAULT);
}
function provideLocalConfig(config) {
  provide(LocalConfigKey, config);
}
function useLocalConfigProvider(config) {
  const prevChain = useLocalConfig();
  const nextChain = computed(() => [...prevChain.value, config.value]);
  provideLocalConfig(nextChain);
}
const nilValues = [null, void 0, ""];
const nullOrUndefined = [null, void 0];
const isNilValue = (value) => {
  return nilValues.includes(value);
};
const notNil = (value) => !isNilValue(value);
const isNil = (value) => {
  return nullOrUndefined.includes(value);
};
const processShim = typeof process !== "undefined" ? process : {};
const envShim = processShim.env || {};
const nodeEnv = envShim.NODE_ENV || "";
const isDev = typeof __DEV__ !== "undefined" ? __DEV__ : !["prod", "production"].includes(nodeEnv);
const warn = (...attrs) => {
  if (isDev) {
    console.warn(...attrs);
  }
  return false;
};
const throwError = (message) => {
  throw new Error(`[Vuestic] ${message}`);
};
let currentApp = null;
let prevRegisteredApp = null;
const setCurrentApp = (newApp) => {
  if ((prevRegisteredApp == null ? void 0 : prevRegisteredApp._instance) === null) {
    prevRegisteredApp = null;
  }
  if (newApp === null && prevRegisteredApp === null) {
    return;
  }
  prevRegisteredApp = currentApp;
  currentApp = newApp;
};
const getCurrentApp = () => currentApp;
const inject = (key, value = void 0) => {
  var _a2;
  const injectedFromApp = (_a2 = getCurrentApp()) == null ? void 0 : _a2._context.provides[key];
  const vm = getCurrentInstance();
  if (vm) {
    return inject$1(key, value);
  }
  return injectedFromApp ?? throwError("You're using Vuestic composable outside Vue app. Since you registered Vuestic in multiple apps, composables can not be used outside setup function anymore.");
};
const isObject$2 = (obj) => {
  return obj !== null && typeof obj === "object";
};
const cloneDeep = (source) => {
  if (source === null || typeof source !== "object") {
    return source;
  }
  if (Array.isArray(source)) {
    return source.map(cloneDeep);
  }
  if (source instanceof Date) {
    return new Date(source.getTime());
  }
  if (source instanceof RegExp) {
    return new RegExp(source.source, source.flags);
  }
  if (source instanceof Map) {
    return new Map(Array.from(source.entries()).map(([key, value]) => [key, cloneDeep(value)]));
  }
  if (source instanceof Set) {
    return new Set(Array.from(source.values()).map(cloneDeep));
  }
  if (isObject$2(source)) {
    return Object.keys(source).reduce((acc, key) => {
      acc[key] = cloneDeep(source[key]);
      return acc;
    }, {});
  }
  if (typeof source === "function") {
    return source;
  }
  return source;
};
const isObject$1 = (obj) => obj && typeof obj === "object" && !Array.isArray(obj);
const mergeDeep = (target, source) => {
  if (!isObject$1(target)) {
    target = {};
  }
  Object.keys(source).forEach((key) => {
    const targetValue = target[key];
    const sourceValue = source[key];
    if (sourceValue instanceof RegExp || sourceValue instanceof Date) {
      target[key] = sourceValue;
    } else if (isObject$1(targetValue) && isObject$1(sourceValue)) {
      target[key] = mergeDeep(Object.create(
        Object.getPrototypeOf(targetValue),
        Object.getOwnPropertyDescriptors(targetValue)
      ), sourceValue);
    } else {
      target[key] = sourceValue;
    }
  });
  return target;
};
const mergeDeepMultiple = (...objects) => {
  return objects.reduce((acc, obj) => mergeDeep(acc, obj), {});
};
const ColorsClassesPresets = [
  {
    prefix: "bg",
    property: "background-color"
  },
  {
    prefix: "text",
    property: ["color", "fill"]
  }
];
const getColorsClassesDefaultConfig = () => ColorsClassesPresets;
const makeColorsConfig = (values) => ({
  ...values,
  get variables() {
    return this.presets[this.currentPresetName];
  },
  set variables(value) {
    this.presets[this.currentPresetName] = value;
  }
});
const getColorDefaultConfig = () => makeColorsConfig({
  threshold: 150,
  presets: {
    light: presets.light,
    dark: presets.dark
  },
  currentPresetName: "light"
});
const defineIconAliases = (aliases) => aliases;
const VuesticIconAliases = defineIconAliases([
  {
    name: "va-unsorted",
    to: "swap_vert"
  },
  {
    name: "va-sort-asc",
    to: "va-arrow-up"
  },
  {
    name: "va-sort-desc",
    to: "va-arrow-down"
  },
  {
    name: "va-arrow-first",
    to: "mi-first_page"
  },
  {
    name: "va-arrow-last",
    to: "mi-last_page"
  },
  {
    name: "va-arrow-right",
    to: "mi-chevron_right"
  },
  {
    name: "va-arrow-left",
    to: "mi-chevron_left"
  },
  {
    name: "va-arrow-down",
    to: "mi-expand_more"
  },
  {
    name: "va-arrow-up",
    to: "mi-expand_less"
  },
  {
    name: "va-calendar",
    to: "mi-calendar_today"
  },
  {
    name: "va-delete",
    to: "mi-delete_outline"
  },
  {
    name: "va-check",
    to: "mi-check"
  },
  {
    name: "va-check-circle",
    to: "mi-check_circle"
  },
  {
    name: "va-warning",
    to: "mi-warning"
  },
  {
    name: "va-clear",
    to: "mi-highlight_off"
  },
  {
    name: "va-close",
    to: "mi-close"
  },
  {
    name: "va-loading",
    to: "mi-loop"
  },
  {
    name: "va-plus",
    to: "mi-add"
  },
  {
    name: "va-minus",
    to: "mi-remove"
  }
]);
const VuesticIconFonts = [
  {
    name: "mi-{icon}",
    class: "material-icons",
    resolve: ({ icon }) => ({ content: icon })
  },
  // Fallback
  {
    name: "{icon}",
    class: "material-icons",
    resolve: ({ icon }) => ({ content: icon })
  }
];
const createIconsConfig = (config) => {
  config.aliases = config.aliases || [];
  config.fonts = config.fonts || [];
  return [
    ...config.aliases,
    ...VuesticIconAliases,
    ...config.fonts,
    ...VuesticIconFonts
  ];
};
const getIconDefaultConfig = () => createIconsConfig({});
const getComponentsDefaultConfig = () => (
  // TODO: Should be handled in size service
  {
    VaIcon: {
      sizesConfig: {
        defaultSize: 18,
        sizes: {
          small: 14,
          medium: 18,
          large: 24
        }
      }
    },
    VaRating: {
      sizesConfig: {
        defaultSize: 18,
        sizes: {
          small: 14,
          medium: 18,
          large: 24
        }
      }
    },
    all: {},
    presets: {
      VaButton: {
        default: {
          backgroundOpacity: 1,
          hoverBehavior: "mask",
          hoverOpacity: 0.15,
          pressedBehavior: "mask",
          pressedOpacity: 0.13
        },
        primary: {
          backgroundOpacity: 0.1,
          hoverBehavior: "opacity",
          hoverOpacity: 0.07,
          pressedBehavior: "opacity",
          pressedOpacity: 0.13
        },
        secondary: {
          backgroundOpacity: 0,
          hoverBehavior: "opacity",
          hoverOpacity: 0.07,
          pressedBehavior: "opacity",
          pressedOpacity: 0.13
        },
        plain: {
          plain: true,
          hoverBehavior: "mask",
          hoverOpacity: 0.15,
          pressedBehavior: "mask",
          pressedOpacity: 0.13
        },
        plainOpacity: {
          plain: true,
          textOpacity: 0.6,
          hoverBehavior: "opacity",
          hoverOpacity: 1,
          pressedBehavior: "opacity",
          pressedOpacity: 0.9
        }
      },
      VaInputWrapper: {
        solid: {
          background: "backgroundElement"
        },
        bordered: {
          class: "va-input-wrapper--bordered",
          background: "backgroundElement"
        }
      },
      VaCheckbox: {
        solid: {
          style: "--va-checkbox-background: var(--va-background-element)"
        }
      },
      VaRadio: {
        solid: {
          style: "--va-radio-background: var(--va-background-element)"
        }
      },
      VaMenu: {
        context: {
          cursor: true,
          placement: "right-start",
          trigger: "right-click"
        }
      }
    }
  }
);
const getI18nConfigDefaults = () => ({
  // PROPS
  /** Select search field default text */
  search: "Search",
  /** Select no options text */
  noOptions: "Items not found",
  /** Modal Ok button default text */
  ok: "OK",
  /** Modal Cancel button default text */
  cancel: "Cancel",
  /** FileUpload default button text */
  uploadFile: "Upload file",
  /** FileUpload default undo button text */
  undo: "Undo",
  /** FileUpload default dropzone text */
  dropzone: "Drop files here to upload",
  /** FileUpload default file deleted alert text */
  fileDeleted: "File deleted",
  // Aria attributes
  /** Alert close button aria-label */
  closeAlert: "close alert",
  backToTop: "back to top",
  toggleDropdown: "toggle dropdown",
  carousel: "carousel",
  goPreviousSlide: "go previous slide",
  goNextSlide: "go next slide",
  goSlide: "go slide {index}",
  slideOf: "slide {index} of {length}",
  close: "close",
  openColorPicker: "open color picker",
  colorSelection: "color selection",
  colorName: "color {color}",
  decreaseCounter: "decrease counter",
  increaseCounter: "increase counter",
  selectAllRows: "select all rows",
  sortColumnBy: "sort column by {name}",
  selectRowByIndex: "select row {index}",
  resetDate: "reset date",
  nextPeriod: "next period",
  switchView: "switch view",
  previousPeriod: "previous period",
  removeFile: "remove file",
  reset: "reset",
  pagination: "pagination",
  goToTheFirstPage: "go to the first page",
  goToPreviousPage: "go to the previous page",
  goToSpecificPage: "go to the {page} page",
  goToSpecificPageInput: "enter the page number to go",
  goNextPage: "go next page",
  goLastPage: "go last page",
  /** Rating aria-label */
  currentRating: "current rating {value} of {max}",
  /** Rating item aria-label */
  voteRating: "vote rating {value} of {max}",
  /** Select search input aria-label */
  optionsFilter: "options filter",
  splitPanels: "split panels",
  movePaginationLeft: "move pagination left",
  movePaginationRight: "move pagination right",
  resetTime: "reset time",
  closeToast: "close toast",
  /**
   * Select aria-label selected option prefix
   *
   * @example
   *
   * `Selected option: {option}` or `Selected option: Animal`
   */
  selectedOption: "Selected option",
  /** Select aria-label if no option is selected */
  noSelectedOption: "Option is not selected",
  breadcrumbs: "breadcrumbs",
  counterValue: "counter value",
  selectedDate: "selected date",
  selectedTime: "selected time",
  progressState: "progress state",
  color: "color",
  /** Stepper next button text */
  next: "Next",
  /** Stepper previous button text */
  back: "Previous",
  /** Stepper finish button text */
  finish: "Finish",
  step: "step",
  progress: "progress",
  /** Skeleton aria label */
  loading: "Loading",
  /** Slider aria label */
  sliderValue: "Current slider value is {value}",
  /** Switch aria label */
  switch: "Switch",
  /** Input aria label */
  inputField: "Input field",
  /** File Input message when file type is incorrect */
  fileTypeIncorrect: "File type is incorrect",
  /** Select aria label */
  select: "Select an option"
});
const GLOBAL_CONFIG = Symbol("GLOBAL_CONFIG");
const getDefaultConfig = () => ({
  colors: getColorDefaultConfig(),
  icons: getIconDefaultConfig(),
  components: getComponentsDefaultConfig(),
  breakpoint: getBreakpointDefaultConfig(),
  i18n: getI18nConfigDefaults(),
  colorsClasses: getColorsClassesDefaultConfig(),
  /**
   * global config variable to pass nuxt-link component to vuestic-ui via @vuestic/nuxt
   * TODO: give a try to integrate inertia js router components via this option
   * TODO: if this try won't be success, may be remake to provide/inject
   */
  routerComponent: void 0
});
const createGlobalConfig = (defaultConfig = {}) => {
  const globalConfig = ref(mergeDeep(getDefaultConfig(), defaultConfig));
  const getGlobalConfig = () => globalConfig.value;
  const setGlobalConfig = (updater) => {
    const config = typeof updater === "function" ? updater(globalConfig.value) : updater;
    globalConfig.value = cloneDeep(config);
  };
  const mergeGlobalConfig = (updater) => {
    const config = typeof updater === "function" ? updater(globalConfig.value) : updater;
    globalConfig.value = mergeDeep(cloneDeep(globalConfig.value), config);
  };
  return {
    getGlobalConfig,
    setGlobalConfig,
    mergeGlobalConfig,
    globalConfig
  };
};
const provideForCurrentApp = (provide2) => {
  var _a2, _b;
  const provides = ((_a2 = getCurrentInstance()) == null ? void 0 : _a2.appContext.provides) || ((_b = getCurrentApp()) == null ? void 0 : _b._context.provides);
  if (!provides) {
    throw new Error("Vue app not found for provide");
  }
  provides[GLOBAL_CONFIG] = provide2;
  return provide2;
};
function useGlobalConfig() {
  let injected = inject(GLOBAL_CONFIG);
  if (!injected) {
    injected = createGlobalConfig();
    provideForCurrentApp(injected);
  }
  return injected;
}
const withPresetProp = (props) => "preset" in props;
const getPresetProp = (props) => withPresetProp(props) ? props.preset : void 0;
const useComponentConfigProps = (component, originalProps) => {
  const localConfig = useLocalConfig();
  const { globalConfig } = useGlobalConfig();
  const componentName2 = component.name;
  const getPresetProps = (presetPropValue) => {
    return (presetPropValue instanceof Array ? presetPropValue : [presetPropValue]).reduce((acc, presetName) => {
      var _a2, _b, _c;
      const presetProps = (_c = (_b = (_a2 = globalConfig.value.components) == null ? void 0 : _a2.presets) == null ? void 0 : _b[componentName2]) == null ? void 0 : _c[presetName];
      if (!presetProps) {
        return acc;
      }
      const extendedPresets = getPresetProp(presetProps);
      return {
        ...acc,
        ...extendedPresets ? getPresetProps(extendedPresets) : void 0,
        ...presetProps
      };
    }, {});
  };
  const parentInjectedProps = injectChildPropsFromParent();
  return computed(() => {
    var _a2, _b;
    const globalConfigProps = {
      ...(_a2 = globalConfig.value.components) == null ? void 0 : _a2.all,
      ...(_b = globalConfig.value.components) == null ? void 0 : _b[componentName2]
    };
    const localConfigProps = localConfig.value.reduce((finalConfig, config) => {
      const componentConfigProps = config[componentName2];
      return componentConfigProps ? { ...finalConfig, ...componentConfigProps } : finalConfig;
    }, {});
    const presetProp = [
      originalProps,
      parentInjectedProps == null ? void 0 : parentInjectedProps.value,
      localConfigProps,
      globalConfigProps
    ].filter(notNil).map(getPresetProp).filter(notNil).at(0);
    const presetProps = presetProp ? getPresetProps(presetProp) : void 0;
    return { ...globalConfigProps, ...localConfigProps, ...presetProps };
  });
};
const createSetupFn = (component) => {
  return (originalProps, ctx) => {
    var _a2;
    const instance = getCurrentInstance();
    const propsFromConfig = useComponentConfigProps(component, originalProps);
    const attrsFromConfig = computed(() => {
      return omit(propsFromConfig.value, Object.keys(originalProps));
    });
    const props = createProps(instance, propsFromConfig);
    const attrs = createAttrs(instance, attrsFromConfig);
    const slots = createSlots(instance, propsFromConfig);
    instance.props = props;
    instance.attrs = attrs;
    instance.slots = slots;
    const setupState = (_a2 = component.setup) == null ? void 0 : _a2.call(component, shallowReadonly(props), {
      ...ctx,
      attrs,
      slots
    });
    if (typeof setupState === "object" && !instance.exposed) {
      ctx.expose(setupState);
    }
    return setupState;
  };
};
const createProxyComponent = (component) => {
  const setupFn = createSetupFn(component);
  const renderFn = createRenderFn(component);
  return new Proxy(component, {
    get(target, key) {
      if (!(key in component)) {
        return Reflect.get(target, key);
      }
      if (key === "setup") {
        return setupFn;
      }
      if (key === "render" || key === "ssrRender") {
        return renderFn;
      }
      return Reflect.get(target, key);
    }
  });
};
const CLASS_COMPONENT_KEY = "__c";
const patchClassComponent = (component) => {
  component[CLASS_COMPONENT_KEY] = createProxyComponent(component[CLASS_COMPONENT_KEY]);
  return component;
};
const withConfigTransport = (component) => {
  if ("setup" in component) {
    return createProxyComponent(component);
  } else if (CLASS_COMPONENT_KEY in component) {
    return patchClassComponent(component);
  } else {
    component.setup = () => ({
      /* Fake setup function */
    });
    return createProxyComponent(component);
  }
};
const withConfigTransport$1 = withConfigTransport;
const sizesConfig = {
  defaultSize: 48,
  sizes: {
    small: 32,
    medium: 48,
    large: 64
  }
};
const fontSizesConfig = {
  defaultSize: 1,
  sizes: {
    small: 0.75,
    medium: 1,
    large: 1.25
  }
};
const useSizeProps = {
  size: {
    type: [String, Number],
    default: "",
    validator: (size2) => {
      return typeof size2 === "string" || typeof size2 === "number";
    }
  },
  sizesConfig: {
    type: Object,
    default: () => sizesConfig
  },
  fontSizesConfig: {
    type: Object,
    default: () => fontSizesConfig
  }
};
const fontRegex = /(?<fontSize>\d+)(?<extension>px|rem)/i;
const convertToRem = (px) => px / 16 - 0.5;
const sizeToAbsolute = (size2) => {
  if (typeof size2 === "number") {
    return `${size2}px`;
  }
  return String(size2);
};
const doHaveSizesConfig = (props) => "sizesConfig" in props;
const useSizeRef = (props) => {
  const sizePropName = "size";
  return computed(() => {
    let sizePropValue = props[sizePropName];
    if (doHaveSizesConfig(props)) {
      const { defaultSize, sizes } = props.sizesConfig;
      if (isNilValue(sizePropValue)) {
        sizePropValue = defaultSize;
      }
      if (sizes) {
        const sizeFromConfig = sizes[sizePropValue];
        if (sizeFromConfig) {
          return sizeToAbsolute(sizeFromConfig);
        }
      }
    }
    return sizeToAbsolute(sizePropValue);
  });
};
const useSize = (props, componentName2 = ((_a2) => (_a2 = getCurrentInstance()) == null ? void 0 : _a2.type.name)()) => {
  const { getGlobalConfig } = useGlobalConfig();
  const sizesConfigGlobal = computed(() => {
    var _a2, _b;
    return componentName2 ? (_b = (_a2 = getGlobalConfig().components) == null ? void 0 : _a2[componentName2]) == null ? void 0 : _b.sizesConfig : void 0;
  });
  const sizeComputed = computed(() => {
    var _a2, _b, _c;
    const { defaultSize, sizes } = props.sizesConfig;
    const defaultSizeGlobal = (_a2 = sizesConfigGlobal.value) == null ? void 0 : _a2.defaultSize;
    if (!props.size) {
      return `${defaultSize || defaultSizeGlobal}px`;
    }
    if (typeof props.size === "string") {
      const sizeFromGlobalConfig = (_c = (_b = sizesConfigGlobal.value) == null ? void 0 : _b.sizes) == null ? void 0 : _c[props.size];
      const sizeFromProps = sizes[props.size];
      if (sizeFromProps) {
        return `${sizeFromProps}px`;
      }
      if (sizeFromGlobalConfig) {
        return `${sizeFromGlobalConfig}px`;
      }
      return props.size;
    }
    return `${props.size}px`;
  });
  const fontSizeInRem = computed(() => {
    const { defaultSize, sizes } = props.fontSizesConfig;
    if (!props.size) {
      return defaultSize;
    }
    if (typeof props.size === "string") {
      if (props.size in sizes) {
        return sizes[props.size];
      }
      const fontSizeParsed = props.size.match(fontRegex);
      if (!fontSizeParsed || !fontSizeParsed.groups) {
        throw new Error("Size prop should be either valid string or number");
      }
      const { extension, fontSize } = fontSizeParsed.groups;
      return extension === "rem" ? +fontSize : convertToRem(+fontSize);
    }
    return convertToRem(props.size);
  });
  const fontSizeComputed = computed(() => `${fontSizeInRem.value}rem`);
  return {
    sizeComputed,
    fontSizeComputed,
    fontSizeInRem
  };
};
const useComponentPresetProp = {
  preset: {
    type: [String, Array],
    default: void 0
  }
};
const isMatchRegex = (str, regex) => {
  return regex.test(str);
};
const regexGroupsValues = (str, regex) => {
  if (typeof regex !== "string" && regex.global) {
    return [...str.matchAll(regex)].map((g) => g.slice(1));
  }
  const match = str.match(regex) || [];
  if (!match) {
    return [];
  }
  if (match.length > 1) {
    return match.slice(1);
  }
  return match;
};
const dynamicSegmentRegex = /{[^}]*}/g;
const dynamicSegmentStringToRegex = (template) => {
  return template.replace(dynamicSegmentRegex, "(.*)");
};
const dynamicSegmentsNames = (template) => {
  return (template.match(dynamicSegmentRegex) || []).map((g) => g.replace(/{|}/g, ""));
};
const dynamicSegmentsValues = (str, template) => {
  return regexGroupsValues(str, dynamicSegmentStringToRegex(template));
};
const dynamicSegments = (str, template) => {
  const params = dynamicSegmentsNames(template);
  const values = dynamicSegmentsValues(str, template);
  return params.reduce((acc, paramValue, i) => ({ ...acc, [paramValue]: values[i] }), {});
};
const strictMatch = (str, regex) => {
  return (str.match(regex) || [])[0] === str;
};
const isMatchDynamicSegments = (str, template) => {
  const templateRegex = dynamicSegmentStringToRegex(template);
  return strictMatch(str, new RegExp(templateRegex));
};
const isIconConfigurationString = (config) => {
  return typeof config.name === "string";
};
const isIconConfigurationRegex = (config) => {
  return config.name instanceof RegExp;
};
const isMatchConfiguration = (iconName, iconConfiguration) => {
  if (isIconConfigurationString(iconConfiguration)) {
    return isMatchDynamicSegments(iconName, iconConfiguration.name);
  }
  if (isIconConfigurationRegex(iconConfiguration)) {
    return isMatchRegex(iconName, iconConfiguration.name);
  }
  return false;
};
const resolveIconConfigurationString = (iconName, iconConfiguration) => {
  const args = dynamicSegments(iconName, iconConfiguration.name);
  return iconConfiguration.resolve && iconConfiguration.resolve(args);
};
const resolveIconConfigurationRegex = (iconName, iconConfig) => {
  if (iconConfig.name.global) {
    throw new Error(`Bad icon config with name ${iconConfig.name}. Please, don't use global regex as name.`);
  }
  const args = regexGroupsValues(iconName, iconConfig.name);
  return iconConfig.resolveFromRegex && iconConfig.resolveFromRegex(...args);
};
const resolveIconConfiguration = (iconName, iconConfiguration) => {
  if (isIconConfigurationString(iconConfiguration)) {
    return resolveIconConfigurationString(iconName, iconConfiguration);
  }
  if (isIconConfigurationRegex(iconConfiguration)) {
    return resolveIconConfigurationRegex(iconName, iconConfiguration);
  }
  throw Error("Unknown icon config");
};
const findMatchedIconConfiguration = (iconName, globalIconConfig, namesToIgnore = []) => {
  const matchedConfig = globalIconConfig.find((config) => {
    if (namesToIgnore.includes(config.name.toString())) {
      return false;
    }
    return isMatchConfiguration(iconName, config);
  });
  if (!matchedConfig) {
    throw new Error(`Can not find icon config from ${iconName}. Please provide default config.`);
  }
  return matchedConfig;
};
const findIconConfiguration = (iconName, globalIconConfig, namesToIgnore = []) => {
  if (!iconName) {
    return;
  }
  const matchedIconConfiguration = findMatchedIconConfiguration(iconName, globalIconConfig, namesToIgnore);
  const resolvedIconConfiguration = mergeDeep(resolveIconConfiguration(iconName, matchedIconConfiguration), matchedIconConfiguration);
  namesToIgnore = [...namesToIgnore, matchedIconConfiguration.name.toString()];
  return mergeDeep(
    findIconConfiguration(resolvedIconConfiguration.to, globalIconConfig, namesToIgnore),
    resolvedIconConfiguration
  );
};
const iconPropsFromIconConfiguration = (iconConfiguration) => {
  const junkKeys = ["name", "to", "resolve", "resolveFromRegex"];
  const configuration = iconConfiguration;
  junkKeys.forEach((key) => {
    delete configuration[key];
  });
  return configuration;
};
const getIconConfiguration = (name, iconConfig) => {
  const configuration = findIconConfiguration(name, iconConfig);
  if (configuration === void 0) {
    return {};
  }
  return iconPropsFromIconConfiguration(configuration);
};
const useIcon = () => {
  const { globalConfig } = useGlobalConfig();
  return {
    getIcon: (name) => getIconConfiguration(name, globalConfig.value.icons)
  };
};
const defineVuesticPlugin = (fabric) => fabric;
const VaAppCachePluginKey = Symbol("VaAppCachePlugin");
const CachePlugin = defineVuesticPlugin(() => ({
  install(app) {
    const cache = {
      colorContrast: {}
    };
    app.provide(VaAppCachePluginKey, cache);
  }
}));
const useCache = () => {
  const cache = inject(VaAppCachePluginKey);
  if (!cache) {
    return {
      colorContrast: {}
    };
  }
  return cache;
};
const useReactiveComputed = (obj) => {
  const objectRef = typeof obj === "function" ? computed(obj) : computed(obj);
  const proxy = new Proxy(objectRef, {
    get(target, p2, receiver) {
      if (typeof objectRef.value !== "object") {
        return void 0;
      }
      return unref(Reflect.get(objectRef.value, p2, receiver));
    },
    set(target, p2, value) {
      if (isRef(objectRef.value[p2]) && !isRef(value)) {
        objectRef.value[p2].value = value;
      } else {
        objectRef.value[p2] = value;
      }
      return true;
    },
    deleteProperty(target, p2) {
      return Reflect.deleteProperty(objectRef.value, p2);
    },
    has(target, p2) {
      if (typeof objectRef.value !== "object") {
        return false;
      }
      return Reflect.has(objectRef.value, p2);
    },
    ownKeys() {
      if (typeof objectRef.value !== "object") {
        return [];
      }
      return Object.keys(objectRef.value);
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: true,
        configurable: true
      };
    }
  });
  return reactive(proxy);
};
const capitalize = (str) => str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
const wordsRegex = /[A-Z0-9]*(?:[^\-_|A-Z|\s.])*/gm;
const getWords = (str) => {
  var _a2;
  return ((_a2 = str.match(wordsRegex)) == null ? void 0 : _a2.map((word) => word.trim().split(/([0-9]+)|([a-zA-Z]+)/g)).flat().filter(Boolean)) || [];
};
const camelCaseToKebabCase = (str) => {
  return getWords(str).map((word) => word.toLowerCase()).join("-");
};
const kebabCaseToCamelCase = (str) => {
  return getWords(str).map((word, index) => index === 0 ? word.toLowerCase() : capitalize(word)).join("");
};
const startCase = (str) => {
  return getWords(str).map(capitalize).join(" ");
};
const HEX_TEST_REGEX = /^#([A-Fa-f0-9]{3,4}|[A-Fa-f0-9]{6,8})$/;
const RGB_TEST_REGEX = /^rgba?\(([\d.]+, ?){2}[\d.]+(, ?[\d.]+)?\)$/;
const HSL_TEST_REGEX = /hsla?\([\d.]+(deg|rad|turn|grad)?(,?\s?[\d.]+%?){2}(,?\s?(\/\s?)?[\d.]+%?)?\)/;
const isColor = (strColor) => {
  return HEX_TEST_REGEX.test(strColor) || RGB_TEST_REGEX.test(strColor) || HSL_TEST_REGEX.test(strColor);
};
const isHSLObject = (obj) => {
  if (typeof obj !== "object" || obj === null) {
    return false;
  }
  return "h" in obj && "s" in obj && "l" in obj;
};
const isRGBObject = (obj) => {
  if (typeof obj !== "object" || obj === null) {
    return false;
  }
  return "r" in obj && "g" in obj && "b" in obj;
};
const tryParseHex = (color) => {
  if (!HEX_TEST_REGEX.test(color)) {
    return null;
  }
  const hex = color.replace("#", "");
  const isShort = hex.length < 6;
  const [r, g, b, a] = isShort ? hex.split("").map((char) => parseInt(char + char, 16)) : hex.match(/.{2}/g).map((hex2) => parseInt(hex2, 16));
  return { r, g, b, a: a ?? 1 };
};
const tryParseRgb = (color) => {
  if (!RGB_TEST_REGEX.test(color)) {
    return null;
  }
  const [r, g, b, a = 1] = color.match(/[\d.]+/g).map(Number);
  return { r, g, b, a };
};
const tryParseHsla = (color) => {
  if (!HSL_TEST_REGEX.test(color)) {
    return null;
  }
  const [h2, s, l, a = "1"] = color.match(/[\d.]+%?/g);
  return {
    h: Number(h2),
    s: Number(s.replace("%", "")),
    l: Number(l.replace("%", "")),
    a: a.endsWith("%") ? Number(a.replace("%", "")) / 100 : Number(a)
  };
};
const rgbaToHsla = (rgba) => {
  const r = rgba.r / 255;
  const g = rgba.g / 255;
  const b = rgba.b / 255;
  const max2 = Math.max(r, g, b);
  const min2 = Math.min(r, g, b);
  let h2 = 0;
  let s = 0;
  const l = (max2 + min2) / 2;
  if (max2 !== min2) {
    const d = max2 - min2;
    s = l > 0.5 ? d / (2 - max2 - min2) : d / (max2 + min2);
    switch (max2) {
      case r:
        h2 = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h2 = (b - r) / d + 2;
        break;
      case b:
        h2 = (r - g) / d + 4;
        break;
    }
    h2 *= 60;
  }
  return { h: Math.round(h2), s: Math.round(s * 100), l: Math.round(l * 100), a: rgba.a };
};
const hueToRgb = (p2, q, t) => {
  if (t < 0) {
    t += 1;
  }
  if (t > 1) {
    t -= 1;
  }
  if (t < 1 / 6) {
    return p2 + (q - p2) * 6 * t;
  }
  if (t < 1 / 2) {
    return q;
  }
  if (t < 2 / 3) {
    return p2 + (q - p2) * (2 / 3 - t) * 6;
  }
  return p2;
};
const hslaToRgba = (hsla) => {
  const h2 = hsla.h / 360;
  const s = hsla.s / 100;
  const l = hsla.l / 100;
  const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
  const p2 = 2 * l - q;
  const r = hueToRgb(p2, q, h2 + 1 / 3);
  const g = hueToRgb(p2, q, h2);
  const b = hueToRgb(p2, q, h2 - 1 / 3);
  return { r: Math.round(r * 255), g: Math.round(g * 255), b: Math.round(b * 255), a: hsla.a };
};
const parseColorToHSL = (color) => {
  if (isHSLObject(color)) {
    return { ...color };
  }
  if (isRGBObject(color)) {
    return rgbaToHsla(color);
  }
  const rgb = tryParseHex(color) ?? tryParseRgb(color);
  if (rgb) {
    return rgbaToHsla(rgb);
  }
  const hsl = tryParseHsla(color);
  if (hsl) {
    return hsl;
  }
  throw new Error(`Color ${color} is not valid. Please, provide valid color.`);
};
const hslToString = ({ h: h2, s, l, a }) => {
  return `hsla(${h2},${s}%,${l}%,${a ?? 1})`;
};
const parseColorToRGB = (color) => {
  if (isRGBObject(color)) {
    return { ...color };
  }
  if (isHSLObject(color)) {
    return hslaToRgba(color);
  }
  const hsl = tryParseHsla(color);
  if (hsl) {
    return hslaToRgba(hsl);
  }
  const rgb = tryParseHex(color) ?? tryParseRgb(color);
  if (rgb) {
    return rgb;
  }
  throw new Error(`Color ${color} is not valid. Please, provide valid color.`);
};
const rgbToString = ({ r, g, b, a }) => {
  if (a === 1) {
    return `rgb(${r},${g},${b})`;
  }
  return `rgba(${r},${g},${b},${a ?? 1})`;
};
const colorToString = (color) => {
  if (isHSLObject(color)) {
    return hslToString(color);
  }
  if (isRGBObject(color)) {
    return rgbToString(color);
  }
  if (typeof color === "string") {
    return color;
  }
  throw new Error(`Color ${color} is not valid. Please, provide valid color.`);
};
const setHSLA = (color, { h: h2, s, l, a }) => {
  const parsedColor = parseColorToHSL(color);
  parsedColor.a = parsedColor.a ?? 1;
  parsedColor.h = h2 ?? parsedColor.h;
  parsedColor.s = s ?? parsedColor.s;
  parsedColor.l = l ?? parsedColor.l;
  parsedColor.a = a ?? parsedColor.a;
  if (parsedColor.h < 0) {
    parsedColor.h = 360 + parsedColor.h;
  }
  if (parsedColor.h > 360) {
    parsedColor.h = parsedColor.h - 360;
  }
  parsedColor.s = Math.max(0, Math.min(100, parsedColor.s));
  parsedColor.l = Math.max(0, Math.min(100, parsedColor.l));
  parsedColor.a = Math.max(0, Math.min(1, parsedColor.a));
  return parsedColor;
};
const shiftHSLA = (color, { h: h2, s, l, a }) => {
  const parsedColor = parseColorToHSL(color);
  parsedColor.a = parsedColor.a ?? 1;
  parsedColor.h += h2 ?? 0;
  parsedColor.s += s ?? 0;
  parsedColor.l += l ?? 0;
  parsedColor.a += a ?? 0;
  if (parsedColor.h < 0) {
    parsedColor.h = 360 + parsedColor.h;
  }
  if (parsedColor.h > 360) {
    parsedColor.h = parsedColor.h - 360;
  }
  parsedColor.s = Math.max(0, Math.min(100, parsedColor.s));
  parsedColor.l = Math.max(0, Math.min(100, parsedColor.l));
  parsedColor.a = Math.max(0, Math.min(1, parsedColor.a));
  return parsedColor;
};
const isCSSVariable = (strColor) => /var\(--.+\)/.test(strColor);
const cssVariableName = (colorName) => `--va-${camelCaseToKebabCase(colorName)}`;
const normalizeColorName = (colorName) => kebabCaseToCamelCase(colorName);
const colorToRgba = (color, opacity) => {
  const { r, g, b } = parseColorToRGB(color);
  return rgbToString({ r, g, b, a: opacity });
};
const getColorLightness = (color) => {
  const { r, g, b } = parseColorToRGB(color);
  return Math.sqrt(r * r * 0.241 + g * g * 0.691 + b * b * 0.068);
};
const getBoxShadowColor = (color, opacity = 0.4) => {
  return colorToRgba(color, opacity);
};
const getBoxShadowColorFromBg = (background, opacity = 0.4) => {
  return colorToRgba(background, opacity);
};
const getHoverColor = (color, opacity = 0.2) => {
  return colorToRgba(color, opacity);
};
const getFocusColor = (color, opacity = 0.3) => {
  return colorToRgba(color, opacity);
};
const shiftHSLAColor = (color, shift2) => {
  return hslToString(shiftHSLA(parseColorToHSL(color), shift2));
};
const setHSLAColor = (color, shift2) => {
  return hslToString(setHSLA(parseColorToHSL(color), shift2));
};
const shiftGradientColor = (color) => {
  const newColor = parseColorToHSL(color);
  if (newColor.s < 10) {
    return shiftHSLAColor(newColor, { h: 2, s: 5, l: 10 });
  }
  if (newColor.s < 30) {
    return shiftHSLAColor(newColor, { s: -14, l: 11 });
  }
  if (newColor.h >= 0 && newColor.h < 44 || newColor.h >= 285) {
    return shiftHSLAColor(newColor, { h: 11, s: 27, l: 8 });
  }
  if (newColor.h >= 44 && newColor.h < 85) {
    return shiftHSLAColor(newColor, { h: 3, l: 9 });
  }
  if (newColor.h >= 85 && newColor.h < 165) {
    return shiftHSLAColor(newColor, { h: 16, l: 14 });
  }
  if (newColor.h >= 165 && newColor.h < 285) {
    return shiftHSLAColor(newColor, { h: -15, s: 3, l: 2 });
  }
  throw new Error("This method should handle all colors. But it didn't for some reason.");
};
const getGradientBackground = (color) => {
  const colorLeft = shiftGradientColor(color);
  return `linear-gradient(to right, ${colorLeft}, ${colorToString(color)})`;
};
const getStateMaskGradientBackground = (color, maskColor, maskOpacity) => {
  const mask = colorToRgba(maskColor, maskOpacity);
  return `linear-gradient(0deg, ${mask}, ${mask}), ${color}`;
};
const applyColors$1 = (color1, color2) => {
  const c1 = parseColorToRGB(color1);
  const c2 = parseColorToRGB(color2);
  const weight = c2.a;
  if (weight === 1) {
    return rgbToString(c2);
  }
  if (weight === 0) {
    return rgbToString(c1);
  }
  return rgbToString({
    r: Math.round(c1.r * (1 - weight) + c2.r * weight),
    g: Math.round(c1.g * (1 - weight) + c2.g * weight),
    b: Math.round(c1.b * (1 - weight) + c2.b * weight),
    a: c1.a
  });
};
const isColorTransparent = (color) => {
  if (!color) {
    return false;
  }
  if (color === "transparent") {
    return true;
  }
  return parseColorToRGB(color).a <= 0.1;
};
const useColorProps = {
  color: {
    type: String,
    default: ""
  }
};
const useColors = () => {
  const gc = useGlobalConfig();
  if (!gc) {
    throw new Error("useColors must be used in setup function or Vuestic GlobalConfigPlugin is not registered!");
  }
  const { globalConfig } = gc;
  const colors = useReactiveComputed({
    get: () => globalConfig.value.colors.presets[globalConfig.value.colors.currentPresetName],
    set: (v) => {
      setColors(v);
    }
  });
  const setColors = (colors2) => {
    globalConfig.value.colors.presets[globalConfig.value.colors.currentPresetName] = {
      ...globalConfig.value.colors.variables,
      ...colors2
    };
  };
  const getColors = () => {
    return colors;
  };
  const getColor = (prop, defaultColor, preferVariables) => {
    if (!defaultColor) {
      defaultColor = colors.primary;
    }
    if (prop === "transparent") {
      return "#ffffff00";
    }
    if (prop === "currentColor") {
      return prop;
    }
    if (prop == null ? void 0 : prop.startsWith("on")) {
      const colorName = prop.slice(2);
      if (colors[normalizeColorName(colorName)]) {
        return getColor(getTextColor(getColor(colorName)), void 0, preferVariables);
      }
    }
    if (!prop) {
      prop = getColor(defaultColor);
    }
    const colorValue = colors[prop] || colors[normalizeColorName(prop)];
    if (colorValue) {
      return preferVariables ? `var(${cssVariableName(prop)})` : colorValue;
    }
    if (isColor(prop)) {
      return prop;
    }
    if (preferVariables && isCSSVariable(prop)) {
      return prop;
    }
    warn(`'${prop}' is not a proper color! Use HEX or default color themes
      names (https://vuestic.dev/en/styles/colors#default-color-themes)`);
    return getColor(defaultColor);
  };
  const getComputedColor = (color) => {
    return computed({
      get() {
        return getColor(color);
      },
      set(v) {
        setColors({ [color]: v });
      }
    });
  };
  const colorsToCSSVariable = (colors2, prefix2 = "va") => {
    return Object.keys(colors2).filter((key) => colors2[key] !== void 0).reduce((acc, colorName) => {
      acc[`--${prefix2}-${camelCaseToKebabCase(colorName)}`] = getColor(colors2[colorName], void 0, true);
      acc[`--${prefix2}-on-${camelCaseToKebabCase(colorName)}`] = getColor(getTextColor(getColor(colors2[colorName])), void 0, true);
      return acc;
    }, {});
  };
  const cache = useCache();
  const getColorLightnessFromCache = (color) => {
    if (typeof color !== "string") {
      return getColorLightness(color);
    }
    if (!cache.colorContrast[color]) {
      cache.colorContrast[color] = getColorLightness(color);
    }
    return cache.colorContrast[color];
  };
  const computedDarkColor = computed(() => {
    return getColorLightnessFromCache(getColor("textPrimary")) > 255 / 2 ? "textInverted" : "textPrimary";
  });
  const computedLightColor = computed(() => {
    return getColorLightnessFromCache(getColor("textPrimary")) > 255 / 2 ? "textPrimary" : "textInverted";
  });
  const getTextColor = (color, darkColor, lightColor) => {
    const onColorName = `on${capitalize$1(String(color))}`;
    if (colors[onColorName]) {
      return colors[onColorName];
    }
    darkColor = darkColor || computedDarkColor.value;
    lightColor = lightColor || computedLightColor.value;
    return getColorLightnessFromCache(color) > globalConfig.value.colors.threshold ? darkColor : lightColor;
  };
  const currentPresetName = computed({
    get: () => globalConfig.value.colors.currentPresetName,
    set: (v) => {
      applyPreset(v);
    }
  });
  const presets2 = computed(() => globalConfig.value.colors.presets);
  const applyPreset = (presetName) => {
    globalConfig.value.colors.currentPresetName = presetName;
    if (!globalConfig.value.colors.presets[presetName]) {
      return warn(`Preset ${presetName} does not exist`);
    }
  };
  return {
    colors,
    currentPresetName,
    presets: presets2,
    applyPreset,
    setColors,
    getColors,
    getColor,
    getComputedColor,
    getBoxShadowColor,
    getBoxShadowColorFromBg,
    getHoverColor,
    getFocusColor,
    getGradientBackground,
    getTextColor,
    shiftHSLAColor,
    setHSLAColor,
    colorsToCSSVariable,
    colorToRgba,
    getStateMaskGradientBackground
  };
};
const _sfc_main$1Z = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaIcon"
  },
  __name: "VaIcon",
  props: {
    ...useSizeProps,
    ...useComponentPresetProp,
    name: { type: String, default: "" },
    tag: { type: String },
    component: { type: Object },
    color: { type: String },
    rotation: { type: [String, Number] },
    spin: { type: [String, Boolean] },
    flip: {
      type: String,
      default: "off",
      validator: (value) => ["off", "horizontal", "vertical", "both"].includes(value)
    }
  },
  setup(__props) {
    const props = __props;
    const { getColor } = useColors();
    const { sizeComputed } = useSize(props);
    const { getIcon } = useIcon();
    const iconConfig = computed(() => getIcon(props.name));
    const computedTag = computed(() => props.component || props.tag || iconConfig.value.component || iconConfig.value.tag || "i");
    const attrs = useAttrs();
    const computedAttrs = computed(() => ({ ...iconConfig.value.attrs, ...omit(attrs, ["class"]) }));
    const getSpinClass = (spin) => {
      if (spin === void 0 || spin === false) {
        return;
      }
      return spin === "counter-clockwise" ? "va-icon--spin-reverse" : "va-icon--spin";
    };
    const computedClass = computed(() => [
      iconConfig.value.class,
      getSpinClass(props.spin ?? iconConfig.value.spin)
    ]);
    const transformStyle = computed(() => {
      const rotation = props.rotation ? `rotate(${props.rotation}deg)` : "";
      const flipY = props.flip === "vertical" || props.flip === "both" ? -1 : 1;
      const flipX = props.flip === "horizontal" || props.flip === "both" ? -1 : 1;
      const scale = props.flip === "off" ? "" : `scale(${flipY}, ${flipX})`;
      return `${scale} ${rotation}`.trim();
    });
    const computedStyle = computed(() => ({
      transform: transformStyle.value,
      cursor: attrs.onClick ? "pointer" : null,
      color: props.color ? getColor(props.color, void 0, true) : iconConfig.value.color,
      fontSize: sizeComputed.value,
      height: sizeComputed.value,
      lineHeight: sizeComputed.value
    }));
    const tabindexComputed = computed(() => attrs.tabindex ?? -1);
    const ariaHiddenComputed = computed(() => attrs.role !== "button" || tabindexComputed.value < 0);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(computedTag.value), mergeProps$1({
        class: ["va-icon", computedClass.value],
        style: computedStyle.value,
        "aria-hidden": ariaHiddenComputed.value,
        notranslate: ""
      }, computedAttrs.value), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default", {}, () => [
            iconConfig.value.content ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createTextVNode(toDisplayString(iconConfig.value.content), 1)
            ], 64)) : createCommentVNode("", true)
          ])
        ]),
        _: 3
      }, 16, ["class", "style", "aria-hidden"]);
    };
  }
});
const VaIcon = withConfigTransport$1(_sfc_main$1Z);
const getGlobalObject = () => {
  const vm = getCurrentInstance();
  const app = vm == null ? void 0 : vm.appContext.app;
  const { globalProperties } = app.config;
  if ("$vaGlobalVariable" in globalProperties) {
    return globalProperties.$vaGlobalVariable;
  }
  globalProperties.$vaGlobalVariable = reactive({});
  return globalProperties.$vaGlobalVariable;
};
const useAppGlobal = (key, defaultValue) => {
  const globalObject = getGlobalObject();
  if (!(key in globalObject)) {
    globalObject[key] = defaultValue;
  }
  return computed({
    get: () => globalObject[key],
    set: (value) => {
      globalObject[key] = value;
    }
  });
};
const useComponentUuid = () => {
  const vm = getCurrentInstance();
  const counter2 = useAppGlobal("uuidCounter", 0);
  vm.$vaUuid = vm.$vaUuid || `va-${counter2.value++}`;
  return `va-${counter2.value}`;
};
const useMessageListAria = (props) => {
  const id = useComponentUuid();
  const messageListId = `message-list-${id}`;
  const messageListAttributes = computed(() => ({
    id: messageListId,
    role: "alert"
  }));
  const doHaveMessages = computed(() => {
    if (typeof props.modelValue === "string" && props.modelValue.length > 0) {
      return true;
    }
    if (Array.isArray(props.modelValue) && props.modelValue.length > 0) {
      return true;
    }
    return false;
  });
  const childAttributes = computed(() => ({
    "aria-describedby": doHaveMessages.value ? messageListId : void 0,
    "aria-invalid": props.hasError
  }));
  return {
    messageListAttributes,
    childAttributes
  };
};
const useNumericProp = (key) => {
  const props = getCurrentInstance().props;
  const numericComputed = computed(() => {
    const numeric = props == null ? void 0 : props[key];
    if (numeric === void 0) {
      return numeric;
    }
    return Number(numeric);
  });
  return numericComputed;
};
const _hoisted_1$1a = { class: "va-message-list__list" };
const _sfc_main$1Y = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaMessageList",
    inheritAttrs: false
  },
  __name: "VaMessageList",
  props: {
    modelValue: {
      type: [String, Array],
      default: ""
    },
    limit: { type: [Number, String], default: 1 },
    color: { type: String },
    hasError: { type: Boolean, default: false }
  },
  setup(__props, { expose: __expose }) {
    const props = __props;
    const { getColor } = useColors();
    const { childAttributes, messageListAttributes } = useMessageListAria(props);
    const limitComputed = useNumericProp("limit");
    const messages = computed(() => {
      if (!props.modelValue) {
        return [];
      }
      if (!Array.isArray(props.modelValue)) {
        return [props.modelValue];
      }
      return props.modelValue.slice(0, limitComputed.value);
    });
    const computedStyle = computed(() => props.color ? { color: getColor(props.color) } : {});
    __expose({
      messages
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        renderSlot(_ctx.$slots, "default", normalizeProps$1(guardReactiveProps({ ariaAttributes: unref(childAttributes), messages: messages.value, attrs: _ctx.$attrs }))),
        renderSlot(_ctx.$slots, "messages", normalizeProps$1(guardReactiveProps({ ariaAttributes: unref(messageListAttributes), messages: messages.value })), () => [
          messages.value.length > 0 ? (openBlock(), createElementBlock("div", mergeProps$1({
            key: 0,
            class: "va-message-list",
            style: computedStyle.value
          }, unref(messageListAttributes)), [
            createBaseVNode("ul", _hoisted_1$1a, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(messages.value, (message, index) => {
                return openBlock(), createElementBlock("li", {
                  key: index,
                  class: "va-message-list__message"
                }, [
                  renderSlot(_ctx.$slots, "message", normalizeProps$1(guardReactiveProps({ messages: messages.value, message })), () => [
                    __props.hasError ? (openBlock(), createBlock(unref(VaIcon), {
                      key: 0,
                      class: "va-message-list__icon",
                      name: "va-warning",
                      size: 16
                    })) : createCommentVNode("", true),
                    createTextVNode(toDisplayString(message), 1)
                  ])
                ]);
              }), 128))
            ])
          ], 16)) : createCommentVNode("", true)
        ])
      ], 64);
    };
  }
});
const VaMessageList = withConfigTransport$1(_sfc_main$1Y);
function useSyncProp(propName, props, emit2, defaultValue) {
  const vm = getCurrentInstance();
  const isPropPassed = computed(() => {
    const t = props[propName];
    if (!(vm == null ? void 0 : vm.vnode.props)) {
      return t !== void 0;
    }
    return propName in vm.vnode.props && vm.vnode.props[propName] !== void 0;
  });
  if (defaultValue === void 0) {
    return [
      computed({
        set(value) {
          emit2(`update:${propName}`, value);
        },
        get() {
          return props[propName];
        }
      })
    ];
  }
  const currentValue = props[propName];
  const statefulValue = ref(currentValue === void 0 ? defaultValue : currentValue);
  watch(() => props[propName], (newVal) => {
    if (newVal === void 0) {
      return;
    }
    statefulValue.value = newVal;
  });
  return [
    computed({
      set(value) {
        statefulValue.value = value;
        emit2(`update:${propName}`, value);
      },
      get() {
        if (isPropPassed.value) {
          return props[propName];
        }
        return statefulValue.value;
      }
    })
  ];
}
const isComputedRef = (value) => {
  return typeof value === "object" && "_setter" in value;
};
const watchSetter = (ref2, cb) => {
  if (!isComputedRef(ref2)) {
    return;
  }
  const originalSetter = ref2._setter;
  ref2._setter = (newValue) => {
    cb(newValue);
    originalSetter(newValue);
  };
};
const isFunction$2 = (value) => typeof value === "function";
const isString = (value) => typeof value === "string";
const FormServiceKey = Symbol("FormService");
const useFormChild = (context) => {
  const formContext = inject$1(FormServiceKey, null);
  if (!formContext) {
    return {
      forceDirty: ref(false),
      forceHideErrorMessages: ref(false),
      forceHideErrors: ref(false),
      forceHideLoading: ref(false),
      fields: computed(() => []),
      registerField: () => {
      },
      unregisterField: () => {
      },
      immediate: computed(() => false)
    };
  }
  const uid2 = useComponentUuid();
  onMounted(() => {
    formContext.registerField(uid2, context);
  });
  onBeforeUnmount(() => {
    formContext.unregisterField(uid2);
  });
  return formContext;
};
const normalizeValidationRules = (rules = [], callArguments = null) => {
  if (isString(rules)) {
    rules = [rules];
  }
  return rules.map((rule) => isFunction$2(rule) ? rule(callArguments) : rule);
};
const useValidationProps = {
  name: { type: String, default: void 0 },
  rules: { type: Array, default: () => [] },
  dirty: { type: Boolean, default: false },
  error: { type: Boolean, default: void 0 },
  errorMessages: { type: [Array, String], default: void 0 },
  errorCount: { type: [String, Number], default: 1 },
  success: { type: Boolean, default: false },
  messages: { type: [Array, String], default: () => [] },
  immediateValidation: { type: Boolean, default: false },
  modelValue: {}
};
const useValidationEmits = ["update:error", "update:errorMessages", "update:dirty"];
const isPromise = (value) => {
  return typeof value === "object" && typeof value.then === "function";
};
const useDirtyValue = (value, props, emit2) => {
  const isDirty2 = ref(props.dirty || false);
  watchSetter(value, () => {
    isDirty2.value = true;
    emit2("update:dirty", true);
  });
  watch(value, (newValue, oldValue) => {
    if (newValue === oldValue) {
      isDirty2.value = true;
    }
  }, { deep: true });
  watch(() => props.dirty, (newValue) => {
    if (isDirty2.value === newValue) {
      return;
    }
    isDirty2.value = newValue;
  });
  return { isDirty: isDirty2 };
};
const useTouched = () => {
  const isTouched = ref(false);
  const onBlur = () => {
    isTouched.value = true;
  };
  return { isTouched, onBlur };
};
const useOncePerTick = (fn) => {
  let canBeCalled = true;
  return (...args) => {
    if (!canBeCalled) {
      return;
    }
    canBeCalled = false;
    const result = fn(...args);
    nextTick(() => {
      canBeCalled = true;
    });
    return result;
  };
};
const useValidation = (props, emit2, options) => {
  const { reset, focus } = options;
  const [isError] = useSyncProp("error", props, emit2, false);
  const [errorMessages] = useSyncProp("errorMessages", props, emit2, []);
  const isLoading = ref(false);
  const { isTouched, onBlur } = useTouched();
  const validationAriaAttributes = computed(() => ({
    "aria-invalid": isError.value,
    "aria-errormessage": typeof errorMessages.value === "string" ? errorMessages.value : errorMessages.value.join(", ")
  }));
  const resetValidation = () => {
    errorMessages.value = [];
    isError.value = false;
    isDirty2.value = false;
    isTouched.value = false;
    isLoading.value = false;
  };
  const processResults = (results) => {
    let error = false;
    let eMessages = [];
    results.forEach((result) => {
      if (isString(result)) {
        eMessages = [...eMessages, result];
        error = true;
      } else if (result === false) {
        error = true;
      }
    });
    errorMessages.value = eMessages;
    isError.value = error;
    return !error;
  };
  const validateAsync = async () => {
    if (!props.rules || !props.rules.length) {
      return true;
    }
    const results = normalizeValidationRules(props.rules.flat(), options.value.value);
    const asyncPromiseResults = results.filter((result) => isPromise(result));
    const syncRules = results.filter((result) => !isPromise(result));
    if (!asyncPromiseResults.length) {
      return processResults(syncRules);
    }
    isLoading.value = true;
    return Promise.all(asyncPromiseResults).then((asyncResults) => {
      return processResults([...syncRules, ...asyncResults]);
    }).finally(() => {
      isLoading.value = false;
    });
  };
  const validate = useOncePerTick(() => {
    if (!props.rules || !props.rules.length) {
      return true;
    }
    const rules = props.rules.flat();
    const results = normalizeValidationRules(rules, options.value.value);
    const asyncPromiseResults = results.filter((result) => isPromise(result));
    const syncRules = results.filter((result) => !isPromise(result));
    const isSyncedError = syncRules.some((result) => isString(result) ? result : result === false);
    if (asyncPromiseResults.length && !isSyncedError) {
      isLoading.value = true;
      Promise.all(asyncPromiseResults).then((asyncResults) => {
        processResults([...syncRules, ...asyncResults]);
        isLoading.value = false;
      });
      return isSyncedError;
    }
    return processResults(syncRules);
  });
  watchEffect(() => validate());
  const { isDirty: isDirty2 } = useDirtyValue(options.value, props, emit2);
  const {
    // Renamed to forceHideError because it's not clear what it does
    forceHideErrors,
    forceHideLoading,
    forceHideErrorMessages,
    forceDirty,
    immediate: isFormImmediate
  } = useFormChild({
    isTouched,
    isDirty: isDirty2,
    isValid: computed(() => !isError.value),
    isLoading,
    errorMessages,
    validate,
    validateAsync,
    resetValidation,
    focus,
    reset: () => {
      reset();
      resetValidation();
      validate();
    },
    value: computed(() => options.value || props.modelValue),
    name: toRef(props, "name")
  });
  const immediateValidation = computed(() => props.immediateValidation || isFormImmediate.value);
  let canValidate = true;
  const withoutValidation = (cb) => {
    canValidate = false;
    cb();
    nextTick(() => {
      canValidate = true;
    });
  };
  watch(options.value, () => {
    if (!canValidate) {
      return;
    }
    return validate();
  }, { immediate: immediateValidation.value });
  return {
    isDirty: isDirty2,
    isValid: computed(() => !isError.value),
    isError,
    isTouched,
    isLoading: computed({
      get: () => {
        if (forceHideErrors.value) {
          return false;
        }
        if (immediateValidation.value) {
          return isLoading.value;
        }
        if (isTouched.value || isDirty2.value || forceDirty.value) {
          return isLoading.value;
        }
        return false;
      },
      set(value) {
        isLoading.value = value;
      }
    }),
    computedError: computed(() => {
      if (forceHideErrors.value) {
        return false;
      }
      if (immediateValidation.value) {
        return isError.value;
      }
      if (isTouched.value || isDirty2.value || forceDirty.value) {
        return isError.value;
      }
      return false;
    }),
    computedErrorMessages: computed(() => forceHideErrorMessages.value ? [] : errorMessages.value),
    listeners: { onBlur },
    validate,
    resetValidation,
    withoutValidation,
    validationAriaAttributes
  };
};
const _hoisted_1$19 = { class: "va-message-list-wrapper" };
const _sfc_main$1X = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaMessageListWrapper"
  },
  __name: "VaMessageListWrapper",
  props: {
    ...useValidationProps
  },
  setup(__props) {
    const props = __props;
    const messagesColor = computed(() => {
      if (props.error) {
        return "danger";
      }
      if (props.success) {
        return "success";
      }
      return "";
    });
    const hasError = toRef(props, "error");
    const messagesComputed = computed(() => props.error ? props.errorMessages : props.messages);
    const errorLimit = computed(() => props.error ? Number(props.errorCount) : 99);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$19, [
        createVNode(unref(VaMessageList), {
          color: messagesColor.value,
          limit: errorLimit.value,
          "has-error": hasError.value,
          "model-value": messagesComputed.value,
          "inherit-slots": ["message"]
        }, {
          default: withCtx((bind) => [
            renderSlot(_ctx.$slots, "default", normalizeProps$1(guardReactiveProps(bind)))
          ]),
          _: 3
        }, 8, ["color", "limit", "has-error", "model-value"])
      ]);
    };
  }
});
const useGlobalConfigProvider = (next) => {
  const { globalConfig, mergeGlobalConfig, setGlobalConfig, getGlobalConfig } = useGlobalConfig();
  const nextChain = computed(() => {
    var _a2;
    const gcCopy = cloneDeep(globalConfig.value);
    const compiledCopy = {
      ...gcCopy,
      colors: makeColorsConfig(gcCopy.colors)
    };
    const config = mergeDeep(compiledCopy, next.value);
    if ((_a2 = next.value.colors) == null ? void 0 : _a2.variables) {
      Object.keys(next.value.colors.variables).forEach((key) => {
        config.colors.variables[key] = next.value.colors.variables[key];
      });
    }
    return config;
  });
  provide(GLOBAL_CONFIG, {
    mergeGlobalConfig,
    setGlobalConfig,
    getGlobalConfig,
    globalConfig: nextChain
  });
  return nextChain;
};
const toNode = (v, attrs) => {
  if (!v) {
    return null;
  }
  if (!("type" in v) || v.type === Text || typeof v === "string") {
    return h("div", attrs, v);
  }
  if (v.type === Comment) {
    return v;
  }
  if ("$el" in v) {
    return toNode(v.$el, attrs);
  }
  if (v.type === Suspense) {
    return h(v.ssContent, attrs);
  }
  if (v.type === Teleport) {
    if (v.children === null) {
      return v;
    }
    const anchor = toNode(v.children[0], attrs);
    if (anchor) {
      v.children[0] = h(anchor, attrs);
    }
    return v;
  }
  if (v.type === Fragment) {
    if (v.children === null) {
      return v;
    }
    if (v.children.length === 1) {
      return h(Fragment, v.props, [toNode(v.children[0], attrs)]);
    }
    return h("div", attrs, v);
  }
  if (typeof v.type.render === "function") {
    const component = h(v, attrs);
    if (Array.isArray(component.children) && component.children.length > 1) {
      return h("div", attrs, component.children);
    }
  }
  return h(v, attrs);
};
const renderSlotNode = (slot, slotBind = {}, nodeAttributes = {}) => {
  const children = slot == null ? void 0 : slot(slotBind);
  if (!children) {
    return null;
  }
  const nonCommentChildren = children.filter((v) => v.type !== Comment);
  if (nonCommentChildren.length === 0) {
    return null;
  }
  if (nonCommentChildren.length === 1) {
    return toNode(nonCommentChildren[0], nodeAttributes);
  }
  return h("div", {
    ...nodeAttributes,
    class: normalizeClass([nodeAttributes.class, "va-headless-wrapper"])
  }, children);
};
const renderSlotNodes = (slot, slotBind = {}, nodeAttributes = {}) => {
  const children = slot == null ? void 0 : slot(slotBind);
  if (!children) {
    return null;
  }
  return children.map((v) => toNode(v, nodeAttributes));
};
const CssVarsRenderer = /* @__PURE__ */ defineComponent({
  name: "VaCssVarsRenderer",
  inheritAttrs: false,
  setup(props, { slots, attrs }) {
    const { colorsToCSSVariable, colors } = useColors();
    const style = computed(() => {
      return colorsToCSSVariable(colors);
    });
    return () => h(Fragment, attrs, renderSlotNodes(slots.default, {}, {
      style: style.value
    }) || void 0);
  }
});
const _sfc_main$1W = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaConfig",
    inheritAttrs: false
  },
  __name: "VaConfig",
  props: {
    ...useComponentPresetProp,
    components: { type: Object, default: () => ({}) },
    colors: { type: Object },
    i18n: { type: Object }
  },
  setup(__props) {
    const props = __props;
    const prevChain = useLocalConfig();
    const nextChain = computed(() => [...prevChain.value, props.components]);
    provideLocalConfig(nextChain);
    useGlobalConfigProvider(computed(() => {
      const config = {};
      if (props.colors) {
        config.colors = props.colors;
      }
      if (props.i18n) {
        config.i18n = props.i18n;
      }
      return config;
    }));
    const doRenderCssVars = computed(() => {
      return Boolean(props.colors);
    });
    return (_ctx, _cache) => {
      return doRenderCssVars.value ? (openBlock(), createBlock(unref(CssVarsRenderer), normalizeProps$1(mergeProps$1({ key: 0 }, _ctx.$attrs)), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16)) : renderSlot(_ctx.$slots, "default", { key: 1 });
    };
  }
});
const _hoisted_1$18 = {
  class: "va-separator",
  "aria-hidden": "true"
};
const _sfc_main$1V = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaSeparator"
  },
  __name: "VaSeparator",
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$18);
    };
  }
});
const _hoisted_1$17 = {
  class: "va-spacer",
  "aria-hidden": "true"
};
const _sfc_main$1U = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaSpacer"
  },
  __name: "VaSpacer",
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$17);
    };
  }
});
const getScrollbarSize = (element) => {
  if (!element) {
    return 0;
  }
  const scrollbarWidth = element.offsetWidth - element.clientWidth;
  const scrollbarHeight = element.offsetHeight - element.clientHeight;
  return Math.max(scrollbarWidth, scrollbarHeight);
};
const useElementRect = (element) => {
  const rect = ref({ top: 0, left: 0, width: 0, height: 0, bottom: 0, right: 0 });
  let resizeObserver;
  let mutationObserver;
  const updateRect = () => {
    if (element.value) {
      rect.value = element.value.getBoundingClientRect();
    }
  };
  onMounted(() => {
    resizeObserver = new ResizeObserver(updateRect);
    mutationObserver = new MutationObserver(updateRect);
    element.value && resizeObserver.observe(element.value);
    element.value && mutationObserver.observe(element.value, { attributes: true, childList: true, subtree: true });
    window.addEventListener("resize", updateRect);
    window.addEventListener("scroll", updateRect);
    updateRect();
  });
  onBeforeUnmount(() => {
    resizeObserver == null ? void 0 : resizeObserver.disconnect();
    mutationObserver == null ? void 0 : mutationObserver.disconnect();
    window.removeEventListener("resize", updateRect);
    window.removeEventListener("scroll", updateRect);
    resizeObserver = void 0;
    mutationObserver = void 0;
  });
  return rect;
};
const isServer = () => typeof window === "undefined";
const isClient = () => !isServer();
const getWindow$1 = () => typeof window === "undefined" ? void 0 : window;
const fakeGlobal = {};
const getGlobal = () => {
  if (isServer()) {
    if (typeof globalThis === "undefined") {
      return fakeGlobal;
    }
    return globalThis;
  } else {
    return window;
  }
};
const useClientOnly = (cb) => {
  const isMounted = computed(isClient);
  const result = ref(null);
  watch(isMounted, () => {
    if (isMounted.value) {
      result.value = cb();
    }
  }, { immediate: true });
  return result;
};
const useWindow = () => useClientOnly(() => window);
const unwrapEl = (el) => {
  if (!el) {
    return;
  }
  if (typeof el !== "object") {
    return;
  }
  el = unref(el);
  if (!el) {
    return;
  }
  if (typeof el.$el !== "undefined") {
    return el.$el;
  }
  return el;
};
const addEventListener = (target, ...args) => {
  if (!target || typeof target !== "object") {
    return;
  }
  if ("addEventListener" in target && typeof target.addEventListener === "function") {
    target.addEventListener(...args);
    return;
  }
  if ("parentElement" in target) {
    addEventListener(target.parentElement, ...args);
  }
};
const removeEventListener = (target, ...args) => {
  if (!target || typeof target !== "object") {
    return;
  }
  if ("removeEventListener" in target && typeof target.removeEventListener === "function") {
    target.removeEventListener(...args);
    return;
  }
  if ("parentElement" in target) {
    removeEventListener(target.parentElement, ...args);
  }
};
const useEvent = (event, listener, target) => {
  const source = target && typeof target !== "boolean" ? target : useWindow();
  const capture = typeof target === "boolean" ? target : false;
  watch(source, (newValue, oldValue) => {
    if (!Array.isArray(event)) {
      addEventListener(unwrapEl(unref(newValue)), event, listener, capture);
      removeEventListener(unwrapEl(unref(oldValue)), event, listener, capture);
    } else {
      event.forEach((e) => {
        addEventListener(unwrapEl(unref(newValue)), e, listener, capture);
        removeEventListener(unwrapEl(unref(oldValue)), e, listener, capture);
      });
    }
  }, { immediate: true });
};
const normalizeElements = (elements) => {
  if (Array.isArray(elements)) {
    return elements.map(unref);
  }
  const unrefArray = unref(elements);
  return Array.isArray(unrefArray) ? unrefArray : [unrefArray];
};
const useResizeObserver = (elementsList, cb) => {
  let resizeObserver;
  const observeAll = (elements) => {
    elements.forEach((element) => {
      const unrefElement2 = unref(element);
      if (!unrefElement2) {
        return;
      }
      if (!(unrefElement2 instanceof Element)) {
        console.error("Vuestic: Trying to observe non-HTMLElement", {
          target: unrefElement2,
          array: elementsList
        });
        throw new Error("Vuestic: Unable to observe non-HTMLElement");
      }
      unrefElement2 && (resizeObserver == null ? void 0 : resizeObserver.observe(unrefElement2));
    });
  };
  watch(elementsList, (newValue) => {
    resizeObserver == null ? void 0 : resizeObserver.disconnect();
    observeAll(normalizeElements(newValue));
  });
  onMounted(() => {
    resizeObserver = new ResizeObserver(cb);
    observeAll(normalizeElements(elementsList));
  });
  onBeforeUnmount(() => resizeObserver == null ? void 0 : resizeObserver.disconnect());
  return resizeObserver;
};
const _sfc_main$1T = /* @__PURE__ */ defineComponent({
  __name: "VaStickyScrollbar",
  props: {
    el: {},
    direction: { default: "horizontal" },
    offset: { default: 0 }
  },
  setup(__props) {
    const props = __props;
    const currentEl = ref(null);
    const offsetProp = useNumericProp("offset");
    const parentElement = computed(() => {
      var _a2;
      if (props.el) {
        return props.el;
      }
      return ((_a2 = currentEl.value) == null ? void 0 : _a2.parentNode) ?? null;
    });
    const parentRect = useElementRect(parentElement);
    const stickyScrollWrapperStyle = computed(() => {
      const el = parentElement.value;
      if (!el) {
        return {};
      }
      const parentEl = el;
      const scrollSize = getScrollbarSize(parentEl);
      const { bottom, left, right, top } = parentRect.value;
      if (props.direction === "vertical") {
        if (left > window.innerWidth) {
          return { display: "none" };
        }
        if (right < window.innerWidth) {
          return { display: "none" };
        }
        return {
          position: "fixed",
          top: `${top}px`,
          right: 0,
          height: `${parentEl.clientHeight}px`,
          overflowY: "auto",
          overflowX: "hidden"
        };
      }
      if (top > window.innerHeight) {
        return { display: "none" };
      }
      if (bottom < window.innerHeight) {
        return { display: "none" };
      }
      return {
        position: "fixed",
        top: `${Math.min(bottom, window.innerHeight) - scrollSize - Number(offsetProp.value)}px`,
        width: `${parentEl.clientWidth}px`,
        overflowX: "auto",
        overflowY: "hidden"
      };
    });
    useEvent("scroll", (e) => {
      var _a2, _b;
      if (!currentEl.value) {
        return;
      }
      if (props.direction === "horizontal") {
        (_a2 = parentElement.value) == null ? void 0 : _a2.scrollTo({
          left: currentEl.value.scrollLeft
        });
      } else {
        (_b = parentElement.value) == null ? void 0 : _b.scrollTo({
          top: currentEl.value.scrollTop
        });
      }
    }, currentEl);
    useEvent("scroll", (e) => {
      var _a2, _b, _c, _d;
      if (!currentEl.value) {
        return;
      }
      if (props.direction === "horizontal") {
        if (((_a2 = parentElement.value) == null ? void 0 : _a2.scrollLeft) === currentEl.value.scrollLeft) {
          return;
        }
        currentEl.value.scrollTo({
          left: (_b = parentElement.value) == null ? void 0 : _b.scrollLeft
        });
      } else {
        if (((_c = parentElement.value) == null ? void 0 : _c.scrollTop) === currentEl.value.scrollTop) {
          return;
        }
        currentEl.value.scrollTo({
          top: (_d = parentElement.value) == null ? void 0 : _d.scrollTop
        });
      }
    }, parentElement);
    const scrollWidth = ref(0);
    const scrollHeight = ref(0);
    useResizeObserver(computed(() => {
      if (!parentElement.value) {
        return [];
      }
      return [...parentElement.value.children];
    }), () => {
      scrollWidth.value = parentElement.value.scrollWidth;
      scrollHeight.value = parentElement.value.scrollHeight;
    });
    const fakeContentStyle = computed(() => {
      if (props.direction === "vertical") {
        return {
          width: "1px",
          height: `${scrollHeight.value}px`
        };
      }
      return {
        height: "1px",
        width: `${scrollWidth.value}px`
      };
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        style: normalizeStyle(stickyScrollWrapperStyle.value),
        ref_key: "currentEl",
        ref: currentEl
      }, [
        createBaseVNode("div", {
          style: normalizeStyle(fakeContentStyle.value)
        }, null, 4)
      ], 4);
    };
  }
});
const useIsMounted = () => {
  const isMounted = ref(false);
  onMounted(() => {
    isMounted.value = true;
  });
  onBeforeUnmount(() => {
    isMounted.value = false;
  });
  return isMounted;
};
const useTemplateRef = (key) => {
  const vm = getCurrentInstance();
  let _trigger = () => {
  };
  const el = customRef((track2, trigger2) => {
    _trigger = trigger2;
    return {
      get() {
        var _a2;
        track2();
        return (_a2 = vm.proxy) == null ? void 0 : _a2.$refs[key];
      },
      set(value) {
      }
    };
  });
  onMounted(_trigger);
  onUpdated(_trigger);
  return el;
};
const parseRgba = (rgba) => {
  let values;
  if (rgba.startsWith("rgba")) {
    values = rgba.substring(5, rgba.length - 1).split(",");
  } else {
    values = rgba.substring(4, rgba.length - 1).split(",");
  }
  values[0] = Number(values[0]);
  values[1] = Number(values[1]);
  values[2] = Number(values[2]);
  if (values[3] === void 0) {
    values[3] = 1;
  } else {
    values[3] = Number(values[3]);
  }
  return values;
};
const toHex = (color) => {
  return "#" + (color[0] | 1 << 8).toString(16).slice(1) + (color[1] | 1 << 8).toString(16).slice(1) + (color[2] | 1 << 8).toString(16).slice(1) + (color[3] * 255 | 1 << 8).toString(16).slice(1);
};
const getParentsWithBackground = (el) => {
  const parents = [];
  let currentEl = el;
  while (currentEl) {
    if (!(currentEl instanceof HTMLElement) || !currentEl) {
      return parents;
    }
    const { backgroundColor, willChange } = window.getComputedStyle(currentEl);
    const bgWillChange = willChange.includes("background");
    const parsedColor = parseRgba(backgroundColor);
    if (parsedColor[3] === 1 && !bgWillChange) {
      parents.push(currentEl);
      return parents;
    }
    if (parsedColor[3] !== 0 || bgWillChange) {
      parents.push(currentEl);
    }
    currentEl = currentEl.parentElement;
  }
  return parents;
};
const WATCHER_CLASS = "va-background-watcher";
const watchElementBackground = (el, cb) => {
  el.className = WATCHER_CLASS + " " + el.className;
  el.addEventListener("transitionend", (e) => {
    if (e.target !== el) {
      return;
    }
    cb();
  });
  return () => {
    el.className = el.className.replace(WATCHER_CLASS, "");
    el.removeEventListener("transitionend", cb);
  };
};
const watchElementsBackground = (els, cb) => {
  const unwatchers = els.map((el) => watchElementBackground(el, cb));
  return () => {
    unwatchers.forEach((unwatch) => unwatch());
  };
};
const applyColors = (color1, color2) => {
  const weight = color2[3];
  if (weight === 1) {
    return color2;
  }
  if (weight === 0) {
    return color1;
  }
  const c1 = Math.round(color1[0] * (1 - weight) + color2[0] * weight);
  const c2 = Math.round(color1[1] * (1 - weight) + color2[1] * weight);
  const c3 = Math.round(color1[2] * (1 - weight) + color2[2] * weight);
  return [c1, c2, c3, 1];
};
const getColorFromElements = (els) => {
  let currentColor = [0, 0, 0, 0];
  for (let i = els.length - 1; i >= 0; i--) {
    currentColor = applyColors(currentColor, parseRgba(window.getComputedStyle(els[i]).backgroundColor));
  }
  return currentColor;
};
const useElementBackground = (el) => {
  const color = ref("#000000");
  let unWatchAll = () => void 0;
  watchEffect(() => {
    unWatchAll();
    if (el.value) {
      const parents = getParentsWithBackground(el.value);
      unWatchAll = watchElementsBackground(parents, () => {
        color.value = toHex(getColorFromElements(parents));
      });
      color.value = toHex(getColorFromElements(parents));
    }
  });
  return color;
};
const extractGlobalProperties = (app) => app.config.globalProperties;
const defineGlobalProperty = (app, key, v) => {
  const globalProperties = extractGlobalProperties(app);
  globalProperties[key] = v;
};
const getGlobalProperty = (app, key) => {
  return extractGlobalProperties(app)[key];
};
const GlobalConfigPlugin = defineVuesticPlugin((config = {}) => ({
  install(app) {
    const globalConfig = createGlobalConfig(config);
    if (config == null ? void 0 : config.componentsAll) {
      console.warn("Global config -> `componentsAll` was moved to Global config -> components.all. Please replace this to make it work. More info here: https://github.com/epicmaxco/vuestic-ui/issues/1967");
    }
    app.provide(GLOBAL_CONFIG, globalConfig);
    defineGlobalProperty(app, "$vaConfig", globalConfig);
  }
}));
const addOrUpdateStyleElement = (id, getStyles) => {
  if (isServer()) {
    return;
  }
  let stylesElement = document.getElementById(id);
  if (stylesElement) {
    stylesElement.innerHTML = getStyles();
  } else {
    stylesElement = document.createElement("style");
    stylesElement.setAttribute("type", "text/css");
    stylesElement.setAttribute("id", id);
    stylesElement.innerHTML = getStyles();
    document.head.append(stylesElement);
  }
};
const removeStyleElement = (id) => {
  var _a2;
  (_a2 = document.getElementById(id)) == null ? void 0 : _a2.remove();
};
const generateCSSVariable = (key, value) => {
  return `${cssVariableName(key)}: ${value};
`;
};
const STYLE_ROOT_ATTR = "data-va-app";
const getStyleElementId = (id) => `va-color-variables-${id}`;
const createColorConfigPlugin = (app, config) => {
  const { colors: configColors, getTextColor, getColor, currentPresetName } = useColors();
  const renderCSSVariables = (colors = configColors) => {
    if (!colors) {
      return;
    }
    const colorNames = Object.keys(colors);
    const renderedColors = colorNames.map((key) => `${cssVariableName(key)}: ${colors[key]}`).join(";");
    const renderedOnColors = colorNames.map((key) => `${cssVariableName(`on-${key}`)}: ${getColor(getTextColor(colors[key]))}`).join(";");
    return `${renderedColors};${renderedOnColors}`;
  };
  const renderCSSVariablesStyleContent = (colors = configColors, selector = ":root, :host") => {
    const colorNames = Object.keys(colors);
    let result = `${selector} {
`;
    colorNames.forEach((key) => {
      result += generateCSSVariable(key, colors[key]);
    });
    colorNames.forEach((key) => {
      result += generateCSSVariable(`on-${key}`, getColor(getTextColor(colors[key])));
    });
    result += "}\n";
    return result;
  };
  const uniqueId = computed(() => app._uid);
  const stylesRootSelector = computed(() => ":root, :host");
  const updateColors = (newValue) => {
    if (!newValue || isServer()) {
      return;
    }
    const styleContent = renderCSSVariablesStyleContent(newValue, stylesRootSelector.value);
    addOrUpdateStyleElement(getStyleElementId(uniqueId.value), () => styleContent);
  };
  function getAppStylesRootAttribute() {
    return { [STYLE_ROOT_ATTR]: uniqueId.value };
  }
  const origMount = app.mount;
  app.mount = function(...args) {
    const result = origMount.apply(this, args);
    const appRootElement = app._container;
    const existingStylesId = appRootElement.getAttribute(STYLE_ROOT_ATTR);
    if (existingStylesId && existingStylesId !== uniqueId.value.toString()) {
      removeStyleElement(getStyleElementId(existingStylesId));
    }
    appRootElement.setAttribute(STYLE_ROOT_ATTR, uniqueId.value.toString());
    return result;
  };
  watch(configColors, (newValue) => {
    updateColors(newValue);
  }, { immediate: true, deep: true });
  return {
    colors: configColors,
    currentPresetName,
    getAppStylesRootAttribute,
    renderCSSVariables,
    updateColors,
    renderCSSVariablesStyleContent
  };
};
const ColorConfigPlugin = defineVuesticPlugin((config) => ({
  install(app) {
    defineGlobalProperty(app, "$vaColorConfig", createColorConfigPlugin(app));
  }
}));
let counter = 0;
const getRandomString = (stringLength = 4) => {
  return Math.random().toString(36).substring(2, stringLength + 2);
};
const generateUniqueId = () => {
  return `${getRandomString(8)}-${getRandomString(4)}-${getRandomString(4)}-${++counter}`;
};
function useWindowSize() {
  const windowSizes = reactive({
    width: void 0,
    height: void 0
  });
  const setCurrentWindowSizes = () => {
    windowSizes.width = window == null ? void 0 : window.innerWidth;
    windowSizes.height = window == null ? void 0 : window.innerHeight;
  };
  const isMounted = computed(isClient);
  watch(isMounted, (newValue) => {
    if (!newValue) {
      return;
    }
    setCurrentWindowSizes();
  }, { immediate: true });
  useEvent("resize", setCurrentWindowSizes, true);
  return { windowSizes };
}
const useDocument = () => useClientOnly(() => document);
const createBreakpointConfigPlugin = (app) => {
  var _a2;
  const globalConfig = (_a2 = getGlobalProperty(app, "$vaConfig")) == null ? void 0 : _a2.globalConfig;
  if (!globalConfig) {
    warn("createBreakpointConfigPlugin: globalConfig is not defined!");
    return {};
  }
  const breakpointConfig = computed(() => {
    const breakpoint = globalConfig.value.breakpoint;
    if (!breakpoint) {
      warn("createBreakpointConfigPlugin: breakpointConfig is not defined!");
    }
    return breakpoint ?? {};
  });
  if (!breakpointConfig.value.enabled) {
    return {};
  }
  if (!breakpointConfig.value.thresholds || !Object.values(breakpointConfig.value.thresholds).length) {
    warn("createBreakpointConfigPlugin: there are no defined thresholds!");
    return {};
  }
  const { windowSizes } = useWindowSize();
  const isMounted = computed(isClient);
  const currentBreakpoint = computed(() => {
    if (!isMounted.value || !windowSizes.width) {
      return;
    }
    return Object.entries(breakpointConfig.value.thresholds).reduce((acc, [key, value]) => {
      if (windowSizes.width >= value) {
        acc = key;
      }
      return acc;
    }, "xs");
  });
  const screenClasses = computed(() => Object.keys(breakpointConfig.value.thresholds).reduce((acc, threshold) => {
    acc[threshold] = `va-screen-${threshold}`;
    return acc;
  }, {}));
  const generateHelpersMediaCss = () => {
    let result = "";
    Object.values(breakpointConfig.value.thresholds).forEach((thresholdValue, index) => {
      result += `@media screen and (min-width: ${thresholdValue}px) {`;
      result += `:root { --va-media-ratio: ${(index + 1) * 0.2} }`;
      result += "}\n";
    });
    return result;
  };
  const uniqueId = computed(generateUniqueId);
  addOrUpdateStyleElement(`va-helpers-media-${uniqueId.value}`, generateHelpersMediaCss);
  const getDocument = useDocument();
  watch(currentBreakpoint, (newValue) => {
    if (!newValue || !breakpointConfig.value.bodyClass || !getDocument.value) {
      return;
    }
    getDocument.value.body.classList.forEach((className) => {
      if (Object.values(screenClasses.value).includes(className)) {
        getDocument.value.body.classList.remove(className);
      }
    });
    getDocument.value.body.classList.add(screenClasses.value[newValue]);
  }, { immediate: true });
  const breakpointHelpers = computed(() => {
    const isXs = currentBreakpoint.value === "xs";
    const isSm = currentBreakpoint.value === "sm";
    const isMd = currentBreakpoint.value === "md";
    const isLg = currentBreakpoint.value === "lg";
    const isXl = currentBreakpoint.value === "xl";
    return {
      xs: isXs,
      sm: isSm,
      md: isMd,
      lg: isLg,
      xl: isXl,
      smUp: isSm || isMd || isLg || isXl,
      mdUp: isMd || isLg || isXl,
      lgUp: isLg || isXl,
      smDown: isXs || isSm,
      mdDown: isXs || isSm || isMd,
      lgDown: isXs || isSm || isMd || isLg
    };
  });
  return useReactiveComputed(() => ({
    width: windowSizes.width,
    height: windowSizes.height,
    current: currentBreakpoint.value,
    thresholds: breakpointConfig.value.thresholds,
    ...breakpointHelpers.value
  }));
};
const BreakpointConfigPlugin = defineVuesticPlugin(() => ({
  install(app) {
    const breakpointConfig = createBreakpointConfigPlugin(app);
    app.provide(vaBreakpointSymbol, breakpointConfig);
    defineGlobalProperty(app, "$vaBreakpoint", breakpointConfig);
  }
}));
const GAP = 5;
const toastInstances = ref([]);
const getNodeProps$2 = (vNode) => {
  var _a2;
  return ((_a2 = vNode.component) == null ? void 0 : _a2.props) || {};
};
const getTranslateValue = (item) => {
  if (item.el) {
    return item.el.offsetHeight + GAP;
  }
  return 0;
};
const useToastService = (props) => {
  const currentInstance2 = getCurrentInstance();
  const yOffset = computed(() => {
    const currentIndex = toastInstances.value.findIndex((instance) => instance === currentInstance2.vnode);
    if (currentIndex === -1) {
      return 0;
    }
    return toastInstances.value.slice(currentIndex + 1).reduce((acc, instance) => {
      const {
        position: itemPosition
      } = getNodeProps$2(instance);
      const { position } = props;
      if (position === itemPosition) {
        return getTranslateValue(instance) + acc;
      }
      return acc;
    }, 0);
  });
  onMounted(() => {
    toastInstances.value.unshift(currentInstance2.vnode);
  });
  onBeforeUnmount(() => {
    toastInstances.value = toastInstances.value.filter((item) => item !== currentInstance2.vnode);
  });
  return {
    yOffset,
    updateYOffset: () => {
      toastInstances.value = toastInstances.value.filter((item) => item !== currentInstance2.vnode);
    }
  };
};
const useTimer = () => {
  let timer;
  const start = (...args) => {
    timer = window.setTimeout(...args);
    return timer;
  };
  const clear = () => timer && window.clearTimeout(timer);
  return {
    start,
    clear
  };
};
const isTranslationKey = (value) => value.startsWith("$t:");
const useTranslationProp = (defaultValue) => {
  return { type: String, default: defaultValue };
};
const applyI18nTemplate = (key, values) => {
  if (!values) {
    return key;
  }
  Object.keys(values).forEach((valueKey) => {
    key = key.replace(`{${valueKey}}`, String(values[valueKey]));
  });
  return key;
};
const useTranslation = () => {
  const { globalConfig } = useGlobalConfig();
  const config = computed(() => globalConfig.value.i18n);
  function t(key, values) {
    var _a2;
    const $t = (_a2 = getCurrentInstance()) == null ? void 0 : _a2.appContext.config.globalProperties.$t;
    if (typeof $t === "function") {
      const translated2 = $t(`vuestic.${key}`, values);
      if (translated2) {
        return translated2;
      }
    }
    const translated = config.value[key];
    if (!translated) {
      warn(`${key} not found in VuesticUI i18n config`);
      return key;
    }
    return applyI18nTemplate(translated, values) || key;
  }
  function tp(key, values) {
    if (!key) {
      return "";
    }
    if (isTranslationKey(key)) {
      return t(key.slice(3), values);
    }
    return applyI18nTemplate(key, values) || key;
  }
  return {
    tp,
    t
  };
};
const useTextColor = (componentColor, isTransparent = false) => {
  const { props } = getCurrentInstance();
  const { getColor, getTextColor } = useColors();
  const textColorComputed = computed(() => {
    if (props.textColor) {
      return getColor(props.textColor);
    }
    const bg = componentColor ? unref(componentColor) : props.color;
    if (!bg) {
      return "currentColor";
    }
    const componentColorHex = getColor(bg);
    if (isColorTransparent(componentColorHex)) {
      return "currentColor";
    }
    return unref(isTransparent) ? componentColorHex : getColor(getTextColor(componentColorHex));
  });
  return { textColorComputed };
};
const _hoisted_1$16 = ["role", "aria-live"];
const _hoisted_2$y = { class: "va-toast__group" };
const _hoisted_3$n = ["textContent"];
const _hoisted_4$e = { class: "va-toast__content" };
const _hoisted_5$a = ["innerHTML"];
const _hoisted_6$5 = ["textContent"];
const _hoisted_7$3 = {
  key: 1,
  class: "va-toast__content"
};
const _sfc_main$1S = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaToast"
  },
  __name: "VaToast",
  props: {
    ...useComponentPresetProp,
    title: { type: String, default: "" },
    offsetY: { type: [Number, String], default: 16 },
    offsetX: { type: [Number, String], default: 16 },
    message: { type: [String, Function], default: "" },
    dangerouslyUseHtmlString: { type: Boolean, default: false },
    icon: { type: String, default: "close" },
    customClass: { type: String, default: "" },
    duration: { type: [Number, String], default: 5e3 },
    color: { type: String, default: "primary" },
    closeable: { type: Boolean, default: true },
    onClose: { type: Function },
    onClick: { type: Function },
    multiLine: { type: Boolean, default: false },
    position: {
      type: String,
      default: "top-right",
      validator: (value) => ["top-right", "top-center", "top-left", "bottom-right", "bottom-center", "bottom-left"].includes(value)
    },
    render: { type: Function },
    ariaCloseLabel: useTranslationProp("$t:close"),
    role: { type: String, default: void 0 },
    inline: { type: Boolean, default: false }
  },
  emits: ["on-click", "on-close"],
  setup(__props, { emit: __emit }) {
    const VaToastRenderer = /* @__PURE__ */ defineComponent({
      name: "VaToastRenderer",
      props: {
        render: { type: Function, required: true }
      },
      setup: (props2) => () => props2.render()
    });
    const { tp } = useTranslation();
    const props = __props;
    const emit2 = __emit;
    const rootElement = shallowRef();
    const { getColor } = useColors();
    const { textColorComputed } = useTextColor(computed(() => getColor(props.color)));
    const offsetYComputed = useNumericProp("offsetY");
    const offsetXComputed = useNumericProp("offsetX");
    const durationComputed = useNumericProp("duration");
    const visible = ref(false);
    const {
      yOffset,
      updateYOffset
    } = useToastService(props);
    const positionObject = computed(() => ({
      vertical: props.position.includes("top") ? "top" : "bottom",
      horizontal: props.position.includes("center") ? "center" : props.position.includes("right") ? "right" : "left"
    }));
    const getPositionStyle = () => {
      const vertical = positionObject.value.vertical;
      const horizontal = positionObject.value.horizontal;
      if (horizontal === "center") {
        return {
          [vertical]: `${offsetYComputed.value + yOffset.value}px`,
          left: "50%",
          "--va-toast-x-shift": "-50%"
        };
      }
      return {
        [vertical]: `${offsetYComputed.value + yOffset.value}px`,
        [horizontal]: `${offsetXComputed.value}px`
      };
    };
    const toastClasses = computed(() => [
      props.customClass,
      props.multiLine ? "va-toast--multiline" : "",
      props.inline ? "va-toast--inline" : "",
      [`va-toast--${props.position}`]
    ]);
    const toastStyles = computed(() => ({
      ...getPositionStyle(),
      backgroundColor: getColor(props.color),
      color: textColorComputed.value
    }));
    const computedAriaLive = computed(() => {
      if (props.role === "status") {
        return "polite";
      } else {
        return "assertive";
      }
    });
    const computedMessage = computed(() => typeof props.message === "function" ? props.message() : props.message);
    const destroyElement = () => {
      var _a2, _b;
      (_a2 = rootElement.value) == null ? void 0 : _a2.removeEventListener("transitionend", destroyElement);
      (_b = rootElement.value) == null ? void 0 : _b.remove();
    };
    const onToastClick = () => {
      if (typeof props.onClick === "function") {
        props.onClick();
      } else {
        emit2("on-click");
      }
    };
    const onToastClose = () => {
      visible.value = false;
      updateYOffset();
    };
    const onHidden = () => {
      if (typeof props.onClose === "function") {
        props.onClose();
      } else {
        emit2("on-close");
      }
      destroyElement();
    };
    const timer = useTimer();
    const clearTimer = timer.clear;
    const startTimer = () => {
      if (durationComputed.value > 0) {
        timer.start(() => visible.value && onToastClose(), durationComputed.value);
      }
    };
    onMounted(() => {
      visible.value = true;
      startTimer();
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Transition, {
        name: "va-toast-fade",
        onAfterLeave: onHidden
      }, {
        default: withCtx(() => [
          withDirectives(createBaseVNode("div", {
            ref_key: "rootElement",
            ref: rootElement,
            role: _ctx.$props.role ?? _ctx.$props.closeable ? "alertdialog" : "alert",
            "aria-live": computedAriaLive.value,
            "aria-atomic": "true",
            class: normalizeClass(["va-toast", toastClasses.value]),
            style: normalizeStyle(toastStyles.value),
            onMouseenter: _cache[0] || (_cache[0] = //@ts-ignore
            (...args) => unref(clearTimer) && unref(clearTimer)(...args)),
            onMouseleave: startTimer,
            onClick: onToastClick
          }, [
            createBaseVNode("div", _hoisted_2$y, [
              _ctx.$props.title ? (openBlock(), createElementBlock("h2", {
                key: 0,
                class: "va-toast__title",
                textContent: toDisplayString(_ctx.$props.title)
              }, null, 8, _hoisted_3$n)) : createCommentVNode("", true),
              withDirectives(createBaseVNode("div", _hoisted_4$e, [
                _ctx.$props.dangerouslyUseHtmlString ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  innerHTML: computedMessage.value
                }, null, 8, _hoisted_5$a)) : (openBlock(), createElementBlock("p", {
                  key: 1,
                  textContent: toDisplayString(computedMessage.value)
                }, null, 8, _hoisted_6$5))
              ], 512), [
                [vShow, _ctx.$props.message]
              ]),
              _ctx.$props.render ? (openBlock(), createElementBlock("div", _hoisted_7$3, [
                createVNode(unref(VaToastRenderer), {
                  render: _ctx.$props.render
                }, null, 8, ["render"])
              ])) : createCommentVNode("", true),
              _ctx.$props.closeable ? (openBlock(), createBlock(_sfc_main$1Z, {
                key: 2,
                class: "va-toast__close-icon",
                role: "button",
                "aria-label": unref(tp)(_ctx.$props.ariaCloseLabel),
                tabindex: "0",
                size: "1rem",
                name: _ctx.$props.icon,
                onClick: withModifiers(onToastClose, ["stop"]),
                onKeydown: withKeys(withModifiers(onToastClose, ["stop"]), ["enter"])
              }, null, 8, ["aria-label", "name", "onKeydown"])) : createCommentVNode("", true)
            ])
          ], 46, _hoisted_1$16), [
            [vShow, visible.value]
          ])
        ]),
        _: 1
      });
    };
  }
});
const VaToast = withConfigTransport(_sfc_main$1S);
let seed = 1;
getGlobal().vaToastInstances = [];
const getNodeProps$1 = (vNode) => {
  var _a2;
  return ((_a2 = vNode.component) == null ? void 0 : _a2.props) || {};
};
const closeNotification = (targetInstance, destroyElementFn) => {
  if (!targetInstance) {
    return;
  }
  if (!getGlobal().vaToastInstances.length) {
    seed = 1;
    return;
  }
  const targetInstanceIndex = getGlobal().vaToastInstances.findIndex((instance) => instance === targetInstance);
  if (targetInstanceIndex < 0) {
    return;
  }
  destroyElementFn();
  getGlobal().vaToastInstances = getGlobal().vaToastInstances.reduce((acc, instance, index) => {
    if (instance === targetInstance) {
      return acc;
    }
    return [...acc, instance];
  }, []);
  if (!getGlobal().vaToastInstances.length) {
    seed = 1;
  }
};
const destroy$1 = (el, node) => {
  if (el) {
    render(null, el);
    el.remove();
  }
  el = null;
};
const mount$1 = (component, {
  props,
  children,
  element,
  appContext
} = {}) => {
  let el = element;
  let vNode;
  const onClose = () => {
    closeNotification(vNode, () => destroy$1(el));
    if (props == null ? void 0 : props.onClose) {
      props.onClose();
    }
  };
  vNode = createVNode(component, { ...props, onClose }, children);
  if (appContext) {
    vNode.appContext = appContext;
  }
  if (el) {
    render(vNode, el);
  } else if (typeof document !== "undefined") {
    render(vNode, el = document.createElement("div"));
  }
  return { vNode, el };
};
const closeAllNotifications = (appContext) => {
  if (!getGlobal().vaToastInstances.length) {
    seed = 1;
    return;
  }
  getGlobal().vaToastInstances.forEach((instance) => {
    if (appContext && instance.appContext !== appContext) {
      return;
    }
    getNodeProps$1(instance).onClose();
  });
};
const closeById = (id) => {
  const targetInstance = getGlobal().vaToastInstances.find((instance) => {
    var _a2;
    return ((_a2 = instance.el) == null ? void 0 : _a2.id) === id;
  });
  if (targetInstance) {
    const nodeProps = getNodeProps$1(targetInstance);
    nodeProps.onClose();
  }
};
const getToastOptions = (options) => {
  if (typeof options === "string") {
    return {
      message: options
    };
  }
  return options;
};
const createToastInstance = (customProps, appContext) => {
  const { vNode, el } = mount$1(VaToast, { appContext, props: getToastOptions(customProps) });
  const nodeProps = getNodeProps$1(vNode);
  if (el && vNode.el && nodeProps) {
    document.body.appendChild(el.childNodes[0]);
    vNode.el.id = "notification_" + seed;
    seed += 1;
    getGlobal().vaToastInstances.push(vNode);
    return vNode.el.id;
  }
  return null;
};
const createVaToastPlugin = (app) => ({
  /** Returns toast instance id */
  init(options) {
    return createToastInstance(options, app == null ? void 0 : app._context);
  },
  close(id) {
    closeById(id);
  },
  closeAll(allApps = false) {
    closeAllNotifications(allApps ? void 0 : app == null ? void 0 : app._context);
  }
});
const VaToastPlugin = defineVuesticPlugin(() => ({
  install(app) {
    defineGlobalProperty(app, "$vaToast", createVaToastPlugin(app));
  }
}));
const vaDropdownPlugin = {
  closeDropdown() {
    let vm = this;
    while (vm = vm.$parent) {
      const name = vm.$options.name;
      if (name === "VaDropdown") {
        vm.hide();
        break;
      }
    }
  }
};
const VaDropdownPlugin = defineVuesticPlugin(() => ({
  install(app) {
    defineGlobalProperty(app, "$closeDropdown", vaDropdownPlugin.closeDropdown);
    defineGlobalProperty(app, "$vaDropdown", vaDropdownPlugin);
  }
}));
const useButtonBackground = (colorComputed, isPressed, isHovered) => {
  const instance = getCurrentInstance();
  if (!instance) {
    throw new Error("`useButtonBackground` hook must be used only inside of setup function!");
  }
  const props = instance.props;
  const { getColor, getGradientBackground: getGradientBackground2 } = useColors();
  const backgroundColor = computed(() => {
    if (props.plain) {
      return "transparent";
    }
    return props.gradient ? getGradientBackground2(colorComputed.value) : colorComputed.value;
  });
  const hoveredBgState = computed(() => !props.plain && isHovered.value);
  const pressedBgState = computed(() => !props.plain && isPressed.value);
  const backgroundColorOpacity = computed(() => {
    if (pressedBgState.value && props.pressedBehavior === "opacity") {
      return props.pressedOpacity;
    }
    if (hoveredBgState.value && props.hoverBehavior === "opacity") {
      return Number(props.hoverOpacity);
    }
    return Number(props.backgroundOpacity);
  });
  const hoveredMaskState = computed(() => hoveredBgState.value && props.hoverBehavior === "mask");
  const pressedMaskState = computed(() => pressedBgState.value && props.pressedBehavior === "mask");
  const backgroundMaskOpacity = computed(() => {
    if (pressedMaskState.value) {
      return props.pressedOpacity;
    }
    if (hoveredMaskState.value) {
      return Number(props.hoverOpacity);
    }
    return 0;
  });
  const backgroundMaskColor = computed(() => {
    if (pressedMaskState.value) {
      return getColor(props.pressedMaskColor);
    }
    if (hoveredMaskState.value) {
      return getColor(props.hoverMaskColor);
    }
    return "transparent";
  });
  return {
    backgroundColor,
    backgroundColorOpacity,
    backgroundMaskOpacity,
    backgroundMaskColor
  };
};
const useRouterLinkProps = {
  tag: { type: String, default: "span" },
  to: { type: [String, Object], default: void 0 },
  replace: { type: Boolean, default: void 0 },
  append: { type: Boolean, default: void 0 },
  exact: { type: Boolean, default: void 0 },
  activeClass: { type: String, default: void 0 },
  exactActiveClass: { type: String, default: void 0 },
  href: { type: String, default: void 0 },
  target: { type: String, default: void 0 },
  disabled: { type: Boolean, default: false }
};
const useRouterLink = (props) => {
  const currentInstance2 = getCurrentInstance();
  const globalProperties = computed(() => currentInstance2 == null ? void 0 : currentInstance2.appContext.config.globalProperties);
  const vueRouter = computed(() => {
    var _a2;
    return (_a2 = globalProperties.value) == null ? void 0 : _a2.$router;
  });
  const vueRoute = computed(() => {
    var _a2;
    return (_a2 = globalProperties.value) == null ? void 0 : _a2.$route;
  });
  const { getGlobalConfig } = useGlobalConfig();
  const tagComputed = computed(() => {
    if (props.disabled) {
      return props.tag;
    }
    if (props.href && !props.to) {
      return "a";
    }
    const globalConfig = getGlobalConfig();
    if (globalConfig.routerComponent && props.to) {
      return globalConfig.routerComponent;
    }
    if (props.to && vueRouter.value !== void 0) {
      return "router-link";
    }
    if (props.to && vueRouter.value === void 0) {
      return "a";
    }
    return props.tag || "div";
  });
  const isLinkTag = computed(() => {
    if (props.disabled) {
      return false;
    }
    return Boolean(props.href || props.to);
  });
  const linkAttributesComputed = computed(() => {
    if (!isLinkTag.value) {
      return {};
    }
    return tagComputed.value === "a" ? {
      target: props.target,
      href: hrefComputed.value
    } : {
      target: props.target,
      to: props.to,
      replace: props.replace,
      append: props.append,
      activeClass: props.activeClass,
      exact: props.exact,
      exactActiveClass: props.exactActiveClass
    };
  });
  const isActiveRouterLink = computed(() => {
    if (!vueRouter.value || !props.to) {
      return false;
    }
    const to = vueRouter.value.resolve(props.to).href;
    const currentHref = vueRouter.value.currentRoute.value.path;
    return to.replace("#", "") === currentHref.replace("#", "");
  });
  const hrefComputed = computed(() => {
    var _a2;
    if (props.href) {
      return props.href;
    }
    if (vueRoute.value === void 0 && props.to) {
      return props.to;
    }
    return props.to ? (_a2 = vueRouter.value) == null ? void 0 : _a2.resolve(props.to, vueRoute.value).href : void 0;
  });
  return {
    isLinkTag,
    tagComputed,
    hrefComputed,
    isActiveRouterLink,
    linkAttributesComputed
  };
};
const useButtonAttributes = (props) => {
  const { linkAttributesComputed, isLinkTag } = useRouterLink(props);
  const typeComputed = computed(() => isLinkTag.value ? void 0 : props.type);
  const buttonAttributesComputed = computed(() => {
    const disabledAttributes = {
      "aria-disabled": !!props.disabled,
      disabled: !!props.disabled
    };
    if (isLinkTag.value) {
      return disabledAttributes;
    }
    return {
      type: typeComputed.value,
      tabindex: props.loading || props.disabled ? -1 : 0,
      ...disabledAttributes
    };
  });
  return computed(() => ({ ...linkAttributesComputed.value, ...buttonAttributesComputed.value }));
};
const getOpacity = (opacity) => {
  var _a2, _b, _c;
  if (isServer()) {
    return opacity;
  }
  if (opacity > 0) {
    const userAgent = (_a2 = window == null ? void 0 : window.navigator) == null ? void 0 : _a2.userAgent;
    const isSafari = userAgent && /^((?!chrome|android).)*safari/i.test((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.userAgent);
    const isLatestSafari = userAgent && /(version.)15|16/i.test((_c = window == null ? void 0 : window.navigator) == null ? void 0 : _c.userAgent);
    if (isSafari && !isLatestSafari) {
      return opacity < 1 ? 1 - opacity : opacity;
    }
  }
  return opacity;
};
const useButtonTextColor = (textColorComputed, colorComputed, isPressed, isHovered) => {
  const instance = getCurrentInstance();
  if (!instance) {
    throw new Error("`useButtonTextColor` hook must be used only inside of setup function!");
  }
  const props = instance.props;
  const { getColor, colorToRgba: colorToRgba2, getStateMaskGradientBackground: getStateMaskGradientBackground2 } = useColors();
  const plainColorStyles = computed(() => ({
    background: "transparent",
    color: textColorComputed.value,
    "-webkit-background-clip": "text",
    "background-clip": "text",
    opacity: getPlainTextOpacity.value
  }));
  const getStateColor = (maskColor, stateOpacity, stateBehavior) => {
    const maskStateColor = getColor(maskColor);
    let stateStyles;
    if (stateBehavior === "opacity") {
      stateStyles = { color: colorToRgba2(textColorComputed.value, stateOpacity) };
    } else {
      stateStyles = {
        background: getStateMaskGradientBackground2(colorComputed.value, maskStateColor, stateOpacity),
        color: stateOpacity < 1 ? colorToRgba2(textColorComputed.value, getOpacity(stateOpacity)) : maskStateColor
      };
    }
    return { ...plainColorStyles.value, ...stateStyles };
  };
  const hoverTextColorComputed = computed(() => {
    return getStateColor(props.hoverMaskColor, Number(props.hoverOpacity), props.hoverBehavior);
  });
  const pressedTextColorComputed = computed(() => {
    return getStateColor(props.pressedMaskColor, props.pressedOpacity, props.pressedBehavior);
  });
  const getPlainTextOpacity = computed(() => {
    if (props.disabled) {
      return void 0;
    }
    if (props.textOpacity === 1 || isHovered.value && !isPressed.value) {
      return 1;
    }
    return isPressed.value ? 0.9 : props.textOpacity;
  });
  return computed(() => {
    const defaultColorStyles = {
      color: textColorComputed.value,
      background: "transparent"
    };
    props.plain && Object.assign(defaultColorStyles, plainColorStyles.value, { background: textColorComputed.value });
    if (!props.plain) {
      return defaultColorStyles;
    }
    if (isPressed.value) {
      return pressedTextColorComputed.value;
    }
    if (isHovered.value) {
      return hoverTextColorComputed.value;
    }
    return defaultColorStyles;
  });
};
const clamp$1 = (value, min2, max2) => {
  return Math.min(Math.max(value, min2), max2);
};
const _hoisted_1$15 = {
  class: "va-progress-circle__wrapper",
  viewBox: "0 0 40 40"
};
const _hoisted_2$x = ["r", "stroke", "stroke-width", "stroke-dasharray", "stroke-dashoffset"];
const _sfc_main$1R = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaProgressCircle"
  },
  __name: "VaProgressCircle",
  props: {
    ...useSizeProps,
    ...useComponentPresetProp,
    modelValue: { type: [Number, String], default: 0 },
    indeterminate: { type: Boolean, default: false },
    thickness: { type: [Number, String], default: 0.06 },
    color: { type: String, default: "primary" },
    ariaLabel: useTranslationProp("$t:progressState")
  },
  setup(__props) {
    const props = __props;
    const { getColor } = useColors();
    const { sizeComputed } = useSize(props);
    const cappedThickness = computed(() => clamp$1(Number(props.thickness), 0, 1) / 2 * 100);
    const radius = computed(() => 20 - 20 * cappedThickness.value / 100);
    const dasharray = computed(() => 2 * Math.PI * radius.value);
    const dashoffset = computed(() => dasharray.value * (1 - clamp$1(Number(props.modelValue), 0, 100) / 100));
    const colorComputed = computed(() => getColor(props.color, void 0, true));
    const { tp } = useTranslation();
    const infoStyle = computed(() => ({ color: colorComputed.value }));
    const rootStyle = computed(() => ({
      width: sizeComputed.value,
      height: sizeComputed.value
    }));
    const rootClass = computed(() => ({
      "va-progress-circle--indeterminate": props.indeterminate
    }));
    const ariaAttributesComputed = computed(() => ({
      role: "progressbar",
      "aria-label": tp(props.ariaLabel),
      "aria-valuenow": !props.indeterminate ? props.modelValue : void 0
    }));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", mergeProps$1({
        class: ["va-progress-circle", rootClass.value],
        style: rootStyle.value
      }, ariaAttributesComputed.value), [
        (openBlock(), createElementBlock("svg", _hoisted_1$15, [
          createBaseVNode("circle", {
            class: "va-progress-circle__overlay",
            cx: "50%",
            cy: "50%",
            r: radius.value,
            fill: "none",
            stroke: colorComputed.value,
            "stroke-width": cappedThickness.value + "%",
            "stroke-dasharray": dasharray.value,
            "stroke-dashoffset": dashoffset.value
          }, null, 8, _hoisted_2$x)
        ])),
        _ctx.$slots.default ? (openBlock(), createElementBlock("div", {
          key: 0,
          style: normalizeStyle(infoStyle.value),
          class: "va-progress-circle__info"
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 4)) : createCommentVNode("", true)
      ], 16);
    };
  }
});
const VaProgressCircle = withConfigTransport$1(_sfc_main$1R);
const pick = (o, keys) => {
  return Object.keys(o).filter((key) => keys.includes(key)).reduce((acc, key) => {
    acc[key] = o[key];
    return acc;
  }, {});
};
const useHoverStyleProps = {
  hoverBehavior: {
    type: String,
    default: "mask",
    validator: (value) => ["opacity", "mask"].includes(value)
  },
  hoverOpacity: { type: [Number, String], default: 0.15 },
  hoverMaskColor: { type: String, default: "textInverted" }
};
const usePressedStyleProps = {
  pressedBehavior: {
    type: String,
    default: "mask",
    validator: (value) => ["opacity", "mask"].includes(value)
  },
  pressedOpacity: { type: Number, default: 0.13 },
  pressedMaskColor: { type: String, default: "textPrimary" }
};
const useLoadingProps = {
  loading: { type: Boolean, default: false }
};
const isHTMLElement$1 = (el) => {
  return el instanceof HTMLElement;
};
const focusElement = (el) => {
  if (!el || !isHTMLElement$1(el)) {
    return;
  }
  el.focus();
  el.dispatchEvent(new FocusEvent("focus", { bubbles: true }));
};
const blurElement = (el) => {
  if (!el || !isHTMLElement$1(el)) {
    return;
  }
  el.blur();
  el.dispatchEvent(new Event("blur", { bubbles: true }));
};
const focusFirstFocusableChild = (el) => {
  if (el.tabIndex !== -1) {
    focusElement(el);
    return;
  }
  const focusable = el.querySelector('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
  if (focusable) {
    focusElement(focusable);
  }
};
const useCaptureEvent = (event, cb, options = {}) => {
  onMounted(() => window.addEventListener(event, cb, { capture: true, ...options }));
  onBeforeUnmount(() => window.removeEventListener(event, cb, { capture: true, ...options }));
};
const useActiveElement = () => {
  const activeEl = shallowRef();
  const updateActiveElement = () => {
    activeEl.value = document.activeElement;
  };
  onMounted(updateActiveElement);
  useCaptureEvent("focus", updateActiveElement);
  useCaptureEvent("blur", updateActiveElement);
  return activeEl;
};
const useFocusEmits = ["focus", "blur"];
function useFocus(el, emit2) {
  const activeElement = useActiveElement();
  const isFocused = computed({
    get: () => {
      if (isNilValue(activeElement.value)) {
        return false;
      }
      if (isNilValue(el == null ? void 0 : el.value)) {
        return false;
      }
      return activeElement.value === (el == null ? void 0 : el.value);
    },
    set: (value) => {
      if (value) {
        focus();
      } else {
        blur();
      }
    }
  });
  const onFocus = (e) => {
    emit2 == null ? void 0 : emit2("focus", e);
  };
  const onBlur = (e) => {
    emit2 == null ? void 0 : emit2("blur", e);
  };
  const focus = () => {
    if (!(el == null ? void 0 : el.value)) {
      return;
    }
    focusElement(unwrapEl(el == null ? void 0 : el.value));
  };
  const blur = () => {
    if (!(el == null ? void 0 : el.value)) {
      return;
    }
    blurElement(unwrapEl(el == null ? void 0 : el.value));
  };
  useEvent("focus", onFocus, el);
  useEvent("blur", onBlur, el);
  return {
    isFocused,
    onFocus,
    onBlur,
    focus,
    blur
  };
}
const useHTMLElement = (key) => {
  if (isRef(key)) {
    return computed({
      get() {
        return unwrapEl(key.value);
      },
      set(value) {
        key.value = value;
      }
    });
  }
  if (key) {
    const el2 = useTemplateRef(key);
    return computed({
      get() {
        return unwrapEl(el2.value);
      },
      set(value) {
        el2.value = value;
      }
    });
  }
  const el = shallowRef();
  return computed({
    set(value) {
      el.value = unwrapEl(value);
    },
    get() {
      return el.value;
    }
  });
};
function useHover(el, disabled) {
  const isHovered = ref(false);
  const onMouseEnter = () => {
    if (disabled == null ? void 0 : disabled.value) {
      return;
    }
    isHovered.value = true;
  };
  const onMouseLeave = () => {
    isHovered.value = false;
  };
  disabled && watch(disabled, (v) => {
    if (v) {
      isHovered.value = false;
    }
  });
  const target = useHTMLElement(el);
  useEvent("mouseenter", onMouseEnter, target);
  useEvent("mouseleave", onMouseLeave, target);
  return { isHovered, onMouseEnter, onMouseLeave };
}
function usePressed(el) {
  const isPressed = ref(false);
  const onMouseDown = () => {
    isPressed.value = true;
  };
  const onMouseUp = () => {
    isPressed.value = false;
  };
  const target = useHTMLElement(el);
  useEvent(["mousedown", "touchstart", "dragstart"], onMouseDown, target);
  useEvent([
    "mouseup",
    "mouseleave",
    "touchend",
    "touchcancel",
    "drop",
    "dragend"
  ], onMouseUp, true);
  return { isPressed, onMouseDown, onMouseUp };
}
const checkSlotChildrenDeep = (v, initial = true) => {
  var _a2;
  if (isVNode(v)) {
    return true;
  }
  if (!v || initial && (!isFunction$2(v) || !((_a2 = v()) == null ? void 0 : _a2.length))) {
    return false;
  }
  const slotData = initial ? v() : v;
  if (Array.isArray(slotData)) {
    return slotData.some((el) => {
      return Array.isArray(el.children) ? checkSlotChildrenDeep(el.children, false) : el.children || el.props;
    });
  }
  return !!slotData.children;
};
const useSlotPassed = (name = "default") => {
  const { slots } = getCurrentInstance();
  return computed(() => checkSlotChildrenDeep(slots[name]));
};
const useBem = (prefix2, modifiers) => {
  if (isDev && !prefix2) {
    console.warn('You must pass the @param "prefix" to the useBem hook!');
  }
  const modifiersList = computed(() => typeof modifiers === "function" ? modifiers() : unref(modifiers));
  const computedBemClassesObject = computed(() => {
    return Object.entries(unref(modifiersList)).reduce((classesObj, [modifierName, value]) => {
      if (value) {
        classesObj[`${prefix2}--${camelCaseToKebabCase(modifierName)}`] = true;
      }
      return classesObj;
    }, {});
  });
  const computedBemClassesArray = computed(() => Object.keys(computedBemClassesObject.value));
  const computedBemClassesString = computed(() => computedBemClassesArray.value.join(" "));
  return new Proxy({}, {
    ownKeys() {
      return Reflect.ownKeys(computedBemClassesObject.value);
    },
    getOwnPropertyDescriptor(_, key) {
      return Reflect.getOwnPropertyDescriptor(computedBemClassesObject.value, key);
    },
    get(_, key, receiver) {
      switch (key) {
        case "asArray":
          return computedBemClassesArray;
        case "asString":
          return computedBemClassesString;
        case "asObject":
          return computedBemClassesObject;
        default:
          return Reflect.get(computedBemClassesObject.value, key, receiver);
      }
    }
  });
};
const _sfc_main$1Q = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaButton"
  },
  __name: "VaButton",
  props: {
    ...useComponentPresetProp,
    ...useSizeProps,
    ...useHoverStyleProps,
    ...usePressedStyleProps,
    ...useLoadingProps,
    ...useRouterLinkProps,
    tag: { type: String, default: "button" },
    type: { type: String, default: "button" },
    block: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    textColor: { type: String, default: "" },
    textOpacity: { type: [Number, String], default: 1 },
    backgroundOpacity: { type: [Number, String], default: 1 },
    borderColor: { type: String, default: "" },
    // only for filled bg state
    gradient: { type: Boolean, default: false },
    plain: { type: Boolean, default: false },
    round: { type: Boolean, default: false },
    size: {
      type: String,
      default: "medium",
      validator: (v) => ["small", "medium", "large"].includes(v)
    },
    icon: { type: String, default: "" },
    iconRight: { type: String, default: "" },
    iconColor: { type: String, default: "" }
  },
  setup(__props, { expose: __expose }) {
    const props = __props;
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const { sizeComputed } = useSize(props);
    const iconSizeComputed = computed(() => {
      const size2 = /([0-9]*)(px)/.exec(sizeComputed.value);
      return size2 ? `${+size2[1] / 2}${size2[2]}` : sizeComputed.value;
    });
    const { tagComputed } = useRouterLink(props);
    const attributesComputed = useButtonAttributes(props);
    const { disabled } = toRefs(props);
    const button = shallowRef();
    const { focus, blur } = useFocus(button);
    const { isHovered } = useHover(button, disabled);
    const { isPressed } = usePressed(button);
    const iconColorComputed = computed(() => props.iconColor ? getColor(props.iconColor) : textColorComputed.value);
    const iconAttributesComputed = computed(() => ({
      color: iconColorComputed.value,
      size: props.size
    }));
    const wrapperClassComputed = computed(() => ({ "va-button__content--loading": props.loading }));
    const isSlotContentPassed = useSlotPassed();
    const isOneIcon = computed(() => !!(props.iconRight && !props.icon || !props.iconRight && props.icon));
    const isOnlyIcon = computed(() => !isSlotContentPassed.value && isOneIcon.value);
    const textOpacityComputed = useNumericProp("textOpacity");
    const backgroundOpacityComputed = useNumericProp("backgroundOpacity");
    const computedClass = useBem("va-button", () => ({
      ...pick(props, ["disabled", "block", "loading", "round", "plain"]),
      small: props.size === "small",
      normal: !props.size || props.size === "medium",
      large: props.size === "large",
      opacity: textOpacityComputed.value < 1,
      bordered: !!props.borderColor,
      iconOnly: isOnlyIcon.value,
      leftIcon: !isOnlyIcon.value && !!props.icon && !props.iconRight,
      rightIcon: !isOnlyIcon.value && !props.icon && !!props.iconRight
    }));
    const isTransparentBg = computed(() => props.plain || backgroundOpacityComputed.value < 0.5);
    const { textColorComputed } = useTextColor(colorComputed, isTransparentBg);
    const {
      backgroundColor,
      backgroundColorOpacity,
      backgroundMaskOpacity,
      backgroundMaskColor
    } = useButtonBackground(colorComputed, isPressed, isHovered);
    const contentColorComputed = useButtonTextColor(textColorComputed, colorComputed, isPressed, isHovered);
    const computedStyle = computed(() => ({
      borderColor: props.borderColor ? getColor(props.borderColor) : "transparent",
      ...contentColorComputed.value
    }));
    __expose({
      focus,
      blur
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(unref(tagComputed)), mergeProps$1({
        ref_key: "button",
        ref: button,
        class: ["va-button", unref(computedClass)],
        style: [computedStyle.value, `--va-background-color: ${String(unref(backgroundColor))};--va-background-color-opacity: ${String(unref(backgroundColorOpacity))};--va-background-mask-color: ${String(unref(backgroundMaskColor))};--va-background-mask-opacity: ${String(unref(backgroundMaskOpacity))}`]
      }, unref(attributesComputed)), {
        default: withCtx(() => [
          createBaseVNode("span", {
            class: normalizeClass(["va-button__content", wrapperClassComputed.value])
          }, [
            renderSlot(_ctx.$slots, "prepend", normalizeProps$1(guardReactiveProps({ icon: __props.icon, iconAttributes: iconAttributesComputed.value })), () => [
              __props.icon ? (openBlock(), createBlock(unref(VaIcon), mergeProps$1({
                key: 0,
                class: "va-button__left-icon",
                name: __props.icon
              }, iconAttributesComputed.value), null, 16, ["name"])) : createCommentVNode("", true)
            ]),
            renderSlot(_ctx.$slots, "default"),
            renderSlot(_ctx.$slots, "append", normalizeProps$1(guardReactiveProps({ icon: __props.iconRight, iconAttributes: iconAttributesComputed.value })), () => [
              __props.iconRight ? (openBlock(), createBlock(unref(VaIcon), mergeProps$1({
                key: 0,
                class: "va-button__right-icon",
                name: __props.iconRight
              }, iconAttributesComputed.value), null, 16, ["name"])) : createCommentVNode("", true)
            ])
          ], 2),
          _ctx.loading ? renderSlot(_ctx.$slots, "loading", normalizeProps$1(mergeProps$1({ key: 0 }, {
            size: iconSizeComputed.value,
            color: unref(textColorComputed)
          })), () => [
            createVNode(unref(VaProgressCircle), {
              class: "va-button__loader",
              size: iconSizeComputed.value,
              color: unref(textColorComputed),
              thickness: 0.15,
              indeterminate: ""
            }, null, 8, ["size", "color"])
          ]) : createCommentVNode("", true)
        ]),
        _: 3
      }, 16, ["class", "style"]);
    };
  }
});
const VaButton = withConfigTransport$1(_sfc_main$1Q);
const useCurrentComponentId = () => {
  const instance = getCurrentInstance();
  if (!instance.appContext.app) {
    return String(instance.uid);
  }
  return `${instance.appContext.app._uid}_${instance.uid}`;
};
const openedModals = [];
const useBlur = (shouldBlur, isModalShown) => {
  const id = useCurrentComponentId();
  const document2 = useDocument();
  const blur = () => {
    var _a2;
    if (openedModals.includes(id)) {
      return;
    }
    openedModals.push(id);
    (_a2 = document2.value) == null ? void 0 : _a2.body.classList.add("va-modal-overlay-background--blurred");
  };
  const removeBlur = () => {
    var _a2;
    const modalIndex = openedModals.indexOf(id);
    if (modalIndex === -1) {
      return;
    }
    openedModals.splice(modalIndex, 1);
    if (openedModals.length === 0) {
      (_a2 = document2.value) == null ? void 0 : _a2.body.classList.remove("va-modal-overlay-background--blurred");
    }
  };
  watchEffect(() => {
    if (!shouldBlur.value) {
      return;
    }
    if (isModalShown.value) {
      blur();
    } else {
      removeBlur();
    }
  });
  onBeforeUnmount(removeBlur);
};
const createInstance = () => {
  return generateUniqueId();
};
const zIndexStack = shallowReactive([]);
const useZIndex = (isVisible) => {
  const instance = createInstance();
  const register = () => {
    if (zIndexStack.includes(instance)) {
      return;
    }
    zIndexStack.push(instance);
  };
  const unregister = () => {
    const index = zIndexStack.findIndex((item) => item === instance);
    if (index !== -1) {
      zIndexStack.splice(index, 1);
    }
  };
  const zIndex = computed(() => {
    const index = zIndexStack.findIndex((item) => item === instance);
    if (index === -1) {
      return -1;
    }
    return index + 1;
  });
  const isTop = computed(() => zIndex.value === zIndexStack.length - 1);
  const isLowest = computed(() => zIndex.value === 0);
  onMounted(() => {
    if (isVisible.value) {
      register();
    }
  });
  onBeforeUnmount(() => {
    unregister();
  });
  watch(isVisible, (value) => {
    if (value) {
      register();
    } else {
      unregister();
    }
  });
  return {
    zIndex,
    isTop,
    isLowest,
    register,
    unregister
  };
};
const NOT_PROVIDED = Symbol("NOT_PROVIDED");
const useUserProvidedProp = (propName, props) => {
  const vm = getCurrentInstance();
  return computed(() => {
    if (!(vm == null ? void 0 : vm.vnode.props)) {
      return NOT_PROVIDED;
    }
    const originalProp = props[propName];
    return propName in vm.vnode.props ? originalProp : NOT_PROVIDED;
  });
};
const useStatefulProps = {
  stateful: { type: Boolean, default: false },
  modelValue: { type: void 0 }
};
const createStatefulProps = (statefulDefault = false) => {
  return {
    stateful: { type: Boolean, default: statefulDefault }
  };
};
const useStatefulEmits = ["update:modelValue"];
const useStateful = (props, emit2, key = "modelValue", options = {}) => {
  const { eventName, defaultValue } = options;
  const event = eventName || `update:${key.toString()}`;
  const passedProp = useUserProvidedProp(key, props);
  const defaultValuePassed = "defaultValue" in options;
  const valueState = ref(
    passedProp.value === NOT_PROVIDED ? defaultValuePassed ? defaultValue : props[key] : passedProp.value
  );
  let unwatchModelValue;
  const watchModelValue = () => {
    unwatchModelValue = watch(() => props[key], (modelValue) => {
      valueState.value = modelValue;
    });
  };
  watch(() => props.stateful, (stateful) => {
    stateful ? watchModelValue() : unwatchModelValue == null ? void 0 : unwatchModelValue();
  }, { immediate: true });
  const valueComputed = computed({
    get: () => {
      if (props.stateful) {
        return valueState.value;
      }
      return props[key];
    },
    set: (value) => {
      if (props.stateful) {
        valueState.value = value;
      }
      emit2(event, value);
    }
  });
  Object.defineProperty(valueComputed, "stateful", {
    get: () => props.stateful
  });
  Object.defineProperty(valueComputed, "userProvided", {
    get: () => passedProp.value !== NOT_PROVIDED
  });
  return { valueComputed };
};
const FOCUSABLE_ELEMENTS_SELECTOR = ":where(a, button, input, textarea, select):not([disabled]), *[tabindex]";
const useTrapFocus = () => {
  const document2 = useDocument();
  const window2 = useWindow();
  const trapInEl = useAppGlobal("trapInEl", null);
  let focusableElements = [];
  let firstFocusableElement = null;
  let lastFocusableElement = null;
  const isFocusIn = (evt) => {
    var _a2;
    return ((_a2 = trapInEl.value) == null ? void 0 : _a2.contains(evt.target)) || false;
  };
  const focusFirstElement = () => {
    firstFocusableElement == null ? void 0 : firstFocusableElement.focus();
  };
  const focusLastElement = () => {
    lastFocusableElement == null ? void 0 : lastFocusableElement.focus();
  };
  const onKeydown = (evt) => {
    var _a2, _b;
    const isTabPressed = evt.code === "Tab";
    const isShiftPressed = evt.shiftKey;
    if (!isTabPressed) {
      return;
    }
    if (!isFocusIn(evt)) {
      evt.preventDefault();
      isShiftPressed ? focusLastElement() : focusFirstElement();
      return;
    }
    if (((_a2 = document2.value) == null ? void 0 : _a2.activeElement) === lastFocusableElement && !isShiftPressed) {
      evt.preventDefault();
      focusFirstElement();
      return;
    }
    if (((_b = document2.value) == null ? void 0 : _b.activeElement) === firstFocusableElement && isShiftPressed) {
      evt.preventDefault();
      focusLastElement();
    }
  };
  const trapFocusIn = (el) => {
    trapInEl.value = el;
    freeFocus();
    trapFocus();
  };
  const trapFocus = () => {
    var _a2;
    if (!trapInEl.value) {
      return;
    }
    focusableElements = Array.from(trapInEl.value.querySelectorAll(FOCUSABLE_ELEMENTS_SELECTOR));
    firstFocusableElement = focusableElements[0];
    lastFocusableElement = focusableElements[focusableElements.length - 1];
    (_a2 = window2.value) == null ? void 0 : _a2.addEventListener("keydown", onKeydown);
  };
  const freeFocus = () => {
    var _a2;
    focusableElements = [];
    firstFocusableElement = null;
    lastFocusableElement = null;
    (_a2 = window2.value) == null ? void 0 : _a2.removeEventListener("keydown", onKeydown);
  };
  return {
    trapFocus,
    freeFocus,
    trapFocusIn
  };
};
const modalsStack = shallowReactive([]);
const useModalLevel = () => {
  const modalId = useComponentUuid();
  const modalLevel = computed(
    () => modalsStack.findIndex(({ id }) => id === String(modalId))
  );
  const registerModal = () => {
    if (modalLevel.value !== -1) {
      return;
    }
    modalsStack.push({
      id: String(modalId)
    });
  };
  const unregisterModal = () => {
    if (modalLevel.value === -1) {
      return;
    }
    modalsStack.splice(modalLevel.value, 1);
  };
  const isTopLevelModal = computed(
    () => modalLevel.value !== -1 && modalLevel.value === modalsStack.length - 1
  );
  const isLowestLevelModal = computed(
    () => modalLevel.value === 0
  );
  const isMoreThenOneModalOpen = computed(() => modalsStack.length > 1);
  return {
    modalId,
    modalLevel,
    registerModal,
    unregisterModal,
    isTopLevelModal,
    isLowestLevelModal,
    isMoreThenOneModalOpen
  };
};
const TELEPORT_FROM_ATTR = "data-va-teleported-from";
const TELEPORT_ATTR = "data-va-teleported";
const findTeleportedFrom = (el) => {
  if (!el) {
    return null;
  }
  const teleportId = el.getAttribute(TELEPORT_ATTR);
  if (teleportId === null) {
    return findTeleportedFrom(el.parentElement);
  }
  return document.querySelector(`[${TELEPORT_FROM_ATTR}="${teleportId}"]`);
};
const useTeleported = () => {
  var _a2, _b;
  const componentId = useCurrentComponentId();
  const currentInstance2 = getCurrentInstance();
  const scopedDataV = currentInstance2 == null ? void 0 : currentInstance2.vnode.scopeId;
  return {
    teleportFromAttrs: {
      [TELEPORT_FROM_ATTR]: componentId
    },
    teleportedAttrs: {
      [TELEPORT_ATTR]: componentId,
      ...scopedDataV ? { [scopedDataV]: "" } : void 0,
      ...(_b = (_a2 = currentInstance2 == null ? void 0 : currentInstance2.appContext.config) == null ? void 0 : _a2.globalProperties) == null ? void 0 : _b.$vaColorConfig.getAppStylesRootAttribute()
    },
    findTeleportedFrom
  };
};
const checkIfElementChild$1 = (parent, child) => {
  if (!child) {
    return false;
  }
  if (child.parentElement === parent) {
    return true;
  }
  return parent.contains(child);
};
const safeArray$1 = (a) => Array.isArray(a) ? a : [a];
const useClickOutside = (elements, cb) => {
  useCaptureEvent("mousedown", (event) => {
    const clickTarget = event.target;
    if (event.target.shadowRoot) {
      return;
    }
    const teleportParent = findTeleportedFrom(clickTarget);
    const isClickInside = safeArray$1(elements).some((element) => {
      const el = unwrapEl(unref(element));
      if (!el) {
        return false;
      }
      if (!teleportParent) {
        return checkIfElementChild$1(el, clickTarget);
      }
      return checkIfElementChild$1(el, clickTarget) || checkIfElementChild$1(el, teleportParent);
    });
    if (!isClickInside) {
      cb(clickTarget);
    }
  });
};
const _hoisted_1$14 = ["aria-labelledby"];
const _hoisted_2$w = {
  key: 2,
  class: "va-modal__inner"
};
const _hoisted_3$m = { class: "va-modal__header" };
const _hoisted_4$d = {
  key: 0,
  class: "va-modal__message"
};
const _hoisted_5$9 = {
  key: 1,
  class: "va-modal__message"
};
const _hoisted_6$4 = {
  key: 2,
  class: "va-modal__footer"
};
const _hoisted_7$2 = {
  key: 3,
  class: "va-modal__footer"
};
const WithTransition = /* @__PURE__ */ defineComponent({
  name: "ModalElement",
  inheritAttrs: false,
  props: {
    ...useComponentPresetProp,
    isTransition: { type: Boolean, default: true }
  },
  setup: (props, { slots, attrs }) => () => {
    var _a2;
    return props.isTransition ? h(Transition, { ...attrs }, slots) : (_a2 = slots.default) == null ? void 0 : _a2.call(slots, attrs);
  }
});
const _sfc_main$1P = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaModal",
    inheritAttrs: false
  },
  __name: "VaModal",
  props: {
    ...defineChildProps({
      cancelButton: VaButton,
      okButton: VaButton,
      closeButton: VaIcon
    }),
    ...useStatefulProps,
    modelValue: { type: Boolean, default: false },
    attachElement: { type: String, default: "body" },
    allowBodyScroll: { type: Boolean, default: false },
    disableAttachment: { type: Boolean, default: false },
    title: { type: String, default: "" },
    message: { type: String, default: "" },
    okText: useTranslationProp("$t:ok"),
    cancelText: useTranslationProp("$t:cancel"),
    hideDefaultActions: { type: Boolean, default: false },
    fullscreen: { type: Boolean, default: false },
    closeButton: { type: Boolean, default: false },
    mobileFullscreen: { type: Boolean, default: true },
    noDismiss: { type: Boolean, default: false },
    noOutsideDismiss: { type: Boolean, default: false },
    noEscDismiss: { type: Boolean, default: false },
    maxWidth: { type: String, default: "" },
    maxHeight: { type: String, default: "" },
    anchorClass: { type: String },
    size: {
      type: String,
      default: "medium"
    },
    sizesConfig: {
      type: Object,
      default: () => ({
        defaultSize: "medium",
        sizes: {
          small: 576,
          medium: 768,
          large: 992,
          auto: "max-content"
        }
      })
    },
    fixedLayout: { type: Boolean, default: false },
    withoutTransitions: { type: Boolean, default: false },
    overlay: { type: Boolean, default: true },
    overlayOpacity: { type: [Number, String], default: 0.6 },
    showNestedOverlay: { type: Boolean, default: false },
    blur: { type: Boolean, default: false },
    zIndex: { type: [Number, String], default: void 0 },
    backgroundColor: { type: String, default: "background-secondary" },
    noPadding: { type: Boolean, default: false },
    beforeClose: { type: Function },
    beforeOk: { type: Function },
    beforeCancel: { type: Function },
    ariaCloseLabel: useTranslationProp("$t:close")
  },
  emits: [
    ...useStatefulEmits,
    "cancel",
    "ok",
    "before-open",
    "open",
    "before-close",
    "close",
    "click-outside"
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    useChildComponents(props);
    const emit2 = __emit;
    const rootElement = shallowRef();
    const modalDialog = shallowRef();
    const { trapFocusIn, freeFocus } = useTrapFocus();
    const {
      registerModal,
      unregisterModal,
      isTopLevelModal,
      isLowestLevelModal
    } = useModalLevel();
    const { getColor } = useColors();
    const { textColorComputed } = useTextColor(toRef(props, "backgroundColor"));
    const { valueComputed } = useStateful(props, emit2);
    const computedClass = computed(() => ({
      "va-modal--fullscreen": props.fullscreen,
      "va-modal--mobile-fullscreen": props.mobileFullscreen,
      "va-modal--fixed-layout": props.fixedLayout,
      "va-modal--no-padding": props.noPadding
    }));
    const {
      zIndex: zIndexInherited
    } = useZIndex(valueComputed);
    const zIndexComputed = computed(() => {
      if (props.zIndex) {
        return Number(props.zIndex);
      }
      return zIndexInherited.value;
    });
    const sizeComputed = useSizeRef(props);
    const computedDialogStyle = computed(() => ({
      maxWidth: props.maxWidth || sizeComputed.value,
      maxHeight: props.maxHeight,
      color: textColorComputed.value,
      background: getColor(props.backgroundColor)
    }));
    const computedOverlayClass = computed(() => ({
      "va-modal__overlay--lowest": isLowestLevelModal.value,
      "va-modal__overlay--top": isTopLevelModal.value
    }));
    const getOverlayOpacity = () => {
      if (props.showNestedOverlay && !isLowestLevelModal.value) {
        return "var(--va-modal-overlay-nested-opacity)";
      }
      return "var(--va-modal-overlay-opacity)";
    };
    const computedOverlayStyles = computed(() => {
      if (!props.overlay) {
        return;
      }
      if (isTopLevelModal.value || props.showNestedOverlay) {
        return {
          "background-color": "var(--va-modal-overlay-color)",
          opacity: getOverlayOpacity()
        };
      }
      return "";
    });
    const show = () => {
      valueComputed.value = true;
    };
    const hide = (cb) => {
      const _hide = () => {
        valueComputed.value = false;
        cb == null ? void 0 : cb();
      };
      props.beforeClose ? props.beforeClose(_hide) : _hide();
    };
    const toggle = () => {
      valueComputed.value = !valueComputed.value;
    };
    const cancel = () => {
      const _hide = () => {
        hide(() => emit2("cancel"));
      };
      props.beforeCancel ? props.beforeCancel(_hide) : _hide();
    };
    const ok = () => {
      const _hide = () => {
        hide(() => emit2("ok"));
      };
      props.beforeOk ? props.beforeOk(_hide) : _hide();
    };
    const trapFocusInModal = () => {
      nextTick(() => {
        if (modalDialog.value) {
          trapFocusIn(modalDialog.value);
        }
      });
    };
    const onBeforeEnterTransition = (el) => emit2("before-open", el);
    const onAfterEnterTransition = (el) => emit2("open", el);
    const onBeforeLeaveTransition = (el) => emit2("before-close", el);
    const onAfterLeaveTransition = (el) => emit2("close", el);
    const listenKeyUp = (e) => {
      const hideModal = () => {
        if (e.code === "Escape" && !props.noEscDismiss && !props.noDismiss && isTopLevelModal.value) {
          cancel();
        }
      };
      setTimeout(hideModal);
    };
    useClickOutside([modalDialog], () => {
      if (!valueComputed.value || props.noOutsideDismiss || props.noDismiss || !isTopLevelModal.value) {
        return;
      }
      emit2("click-outside");
      cancel();
    });
    const window2 = useWindow();
    watchEffect(() => {
      var _a2, _b;
      if (valueComputed.value) {
        (_a2 = window2.value) == null ? void 0 : _a2.addEventListener("keyup", listenKeyUp);
      } else {
        (_b = window2.value) == null ? void 0 : _b.removeEventListener("keyup", listenKeyUp);
      }
    });
    useBlur(toRef(props, "blur"), valueComputed);
    const documentRef = useDocument();
    const setBodyOverflow = (overflow) => {
      if (!documentRef.value || props.allowBodyScroll) {
        return;
      }
      if (overflow === "hidden") {
        documentRef.value.body.classList.add("va-modal-open");
      } else {
        documentRef.value.body.classList.remove("va-modal-open");
      }
    };
    const onShow = () => {
      registerModal();
      setBodyOverflow("hidden");
    };
    const onHide = () => {
      if (isLowestLevelModal.value) {
        freeFocus();
        setBodyOverflow("");
      }
      unregisterModal();
    };
    watch(valueComputed, (newValue) => {
      if (newValue) {
        onShow();
      } else {
        onHide();
      }
    });
    onMounted(() => {
      if (valueComputed.value) {
        onShow();
      }
      if (isTopLevelModal.value) {
        trapFocusInModal();
      }
    });
    onBeforeUnmount(() => {
      onHide();
    });
    watch(isTopLevelModal, (newIsTopLevelModal) => {
      if (newIsTopLevelModal) {
        trapFocusInModal();
      }
    }, { immediate: true });
    __expose({
      show,
      hide,
      toggle,
      cancel,
      ok,
      onBeforeEnterTransition,
      onAfterEnterTransition,
      onBeforeLeaveTransition,
      onAfterLeaveTransition,
      listenKeyUp
    });
    const { tp } = useTranslation();
    const {
      teleportFromAttrs,
      teleportedAttrs
    } = useTeleported();
    const slotBind = { show, hide, toggle, cancel, ok };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "rootElement",
        ref: rootElement,
        class: normalizeClass(["va-modal-entry", _ctx.$props.anchorClass])
      }, [
        _ctx.$slots.anchor ? (openBlock(), createElementBlock("div", mergeProps$1({
          key: 0,
          class: "va-modal__anchor"
        }, unref(teleportFromAttrs)), [
          renderSlot(_ctx.$slots, "anchor", normalizeProps$1(guardReactiveProps(slotBind)))
        ], 16)) : createCommentVNode("", true),
        (openBlock(), createBlock(Teleport, {
          to: __props.attachElement,
          disabled: _ctx.$props.disableAttachment
        }, [
          createVNode(unref(WithTransition), mergeProps$1({
            name: "va-modal",
            isTransition: !_ctx.$props.withoutTransitions,
            duration: 300,
            style: { zIndex: zIndexComputed.value },
            appear: ""
          }, { ..._ctx.$attrs, ...unref(teleportedAttrs) }, {
            onBeforeEnter: onBeforeEnterTransition,
            onAfterEnter: onAfterEnterTransition,
            onBeforeLeave: onBeforeLeaveTransition,
            onAfterLeave: onAfterLeaveTransition
          }), {
            default: withCtx(() => [
              unref(valueComputed) ? (openBlock(), createElementBlock("div", {
                key: 0,
                "aria-labelledby": __props.title,
                class: normalizeClass([computedClass.value, "va-modal"]),
                role: "dialog",
                "aria-modal": "true"
              }, [
                _ctx.$props.overlay ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(["va-modal__overlay", computedOverlayClass.value]),
                  style: normalizeStyle(computedOverlayStyles.value)
                }, null, 6)) : createCommentVNode("", true),
                createBaseVNode("div", {
                  ref_key: "modalDialog",
                  ref: modalDialog,
                  class: "va-modal__dialog",
                  style: normalizeStyle([computedDialogStyle.value])
                }, [
                  _ctx.$props.fullscreen || _ctx.$props.closeButton ? (openBlock(), createBlock(unref(VaIcon), {
                    key: 0,
                    "va-child": "closeButton",
                    class: normalizeClass([{ "va-modal__close--fullscreen": _ctx.$props.fullscreen }, "va-modal__close"]),
                    "aria-label": unref(tp)(_ctx.$props.ariaCloseLabel),
                    role: "button",
                    tabindex: "0",
                    name: "va-close",
                    onClick: cancel,
                    onKeydown: [
                      withKeys(cancel, ["space"]),
                      withKeys(cancel, ["enter"])
                    ]
                  }, null, 8, ["class", "aria-label"])) : createCommentVNode("", true),
                  _ctx.$slots.content ? renderSlot(_ctx.$slots, "content", normalizeProps$1(mergeProps$1({ key: 1 }, slotBind))) : (openBlock(), createElementBlock("div", _hoisted_2$w, [
                    createBaseVNode("div", _hoisted_3$m, [
                      renderSlot(_ctx.$slots, "header", normalizeProps$1(guardReactiveProps(slotBind)), () => [
                        __props.title ? (openBlock(), createElementBlock("div", {
                          key: 0,
                          class: "va-modal__title",
                          style: normalizeStyle({ color: unref(getColor)("primary") })
                        }, toDisplayString(_ctx.$props.title), 5)) : createCommentVNode("", true)
                      ])
                    ]),
                    _ctx.$props.message ? (openBlock(), createElementBlock("div", _hoisted_4$d, toDisplayString(_ctx.$props.message), 1)) : createCommentVNode("", true),
                    _ctx.$slots.default ? (openBlock(), createElementBlock("div", _hoisted_5$9, [
                      renderSlot(_ctx.$slots, "default", normalizeProps$1(guardReactiveProps(slotBind)))
                    ])) : createCommentVNode("", true),
                    (_ctx.$props.cancelText || _ctx.$props.okText) && !_ctx.$props.hideDefaultActions ? (openBlock(), createElementBlock("div", _hoisted_6$4, [
                      _ctx.$props.cancelText ? (openBlock(), createBlock(unref(VaButton), {
                        key: 0,
                        "va-child": "cancelButton",
                        preset: "secondary",
                        color: "secondary",
                        class: "va-modal__default-cancel-button",
                        onClick: cancel
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(unref(tp)(_ctx.$props.cancelText)), 1)
                        ]),
                        _: 1
                      })) : createCommentVNode("", true),
                      createVNode(unref(VaButton), {
                        "va-child": "okButton",
                        onClick: ok
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(unref(tp)(_ctx.$props.okText)), 1)
                        ]),
                        _: 1
                      })
                    ])) : createCommentVNode("", true),
                    _ctx.$slots.footer ? (openBlock(), createElementBlock("div", _hoisted_7$2, [
                      renderSlot(_ctx.$slots, "footer", normalizeProps$1(guardReactiveProps(slotBind)))
                    ])) : createCommentVNode("", true)
                  ]))
                ], 4)
              ], 10, _hoisted_1$14)) : createCommentVNode("", true)
            ]),
            _: 3
          }, 16, ["isTransition", "style"])
        ], 8, ["to", "disabled"]))
      ], 2);
    };
  }
});
const VaModal = withConfigTransport$1(_sfc_main$1P);
const getNodeProps = (vNode) => {
  var _a2;
  return ((_a2 = vNode.component) == null ? void 0 : _a2.props) || {};
};
const destroy = (el, vNode) => {
  if (el) {
    render(null, el);
    el.remove();
  }
  el = null;
};
const mount = (component, { props, appContext } = {}) => {
  const el = document == null ? void 0 : document.createElement("div");
  let vNode;
  const onClose = (event) => {
    var _a2;
    (_a2 = props == null ? void 0 : props.onClose) == null ? void 0 : _a2.call(props, event);
    destroy(el);
  };
  const onUpdateModelValue = (value) => {
    var _a2;
    (_a2 = props == null ? void 0 : props["onUpdate:modelValue"]) == null ? void 0 : _a2.call(props, value);
    if ((props == null ? void 0 : props.withoutTransitions) && !value) {
      nextTick(() => {
        destroy(el);
      });
    }
  };
  vNode = h(component, {
    ...props,
    stateful: (props == null ? void 0 : props.stateful) ?? true,
    modelValue: true,
    onClose,
    "onUpdate:modelValue": onUpdateModelValue
  });
  if (appContext) {
    vNode.appContext = appContext;
  }
  if (el) {
    render(vNode, el);
  }
  return { vNode, el };
};
const getModalOptions = (options) => typeof options === "string" ? { message: options } : options;
const createModalInstance = (customProps, appContext) => {
  const { vNode, el } = mount(VaModal, { appContext, props: getModalOptions(customProps) });
  if (el && vNode.el && getNodeProps(vNode)) {
    document.body.appendChild(el.childNodes[0]);
  }
  return vNode;
};
const createVaModalPlugin = (app) => ({
  init(options) {
    return createModalInstance(options, app == null ? void 0 : app._context);
  },
  confirm(options) {
    if (typeof options === "string") {
      return new Promise((resolve2) => {
        createModalInstance({
          message: options,
          onOk() {
            resolve2(true);
          },
          onCancel() {
            resolve2(false);
          }
        }, app == null ? void 0 : app._context);
      });
    }
    return new Promise((resolve2) => {
      createModalInstance({
        ...options,
        onOk() {
          var _a2;
          (_a2 = options == null ? void 0 : options.onOk) == null ? void 0 : _a2.call(options);
          resolve2(true);
        },
        onCancel() {
          var _a2;
          (_a2 = options == null ? void 0 : options.onCancel) == null ? void 0 : _a2.call(options);
          resolve2(false);
        }
      }, app == null ? void 0 : app._context);
    });
  }
});
const VaModalPlugin = defineVuesticPlugin(() => ({
  install(app) {
    defineGlobalProperty(app, "$vaModal", createVaModalPlugin(app));
  }
}));
const getColorsClassesHelpers = (helpers, colors) => {
  const colorsEntries = Object.entries(colors);
  return helpers.reduce((acc, helper) => acc.concat(
    colorsEntries.map(([colorName, colorValue]) => ({
      ...helper,
      postfix: helper.postfix ?? colorName,
      value: helper.value ?? colorValue
    }))
  ), []);
};
const getColorsClassesStyles = (helpers) => {
  return helpers.reduce((styles, helper) => {
    const style = [helper.property].flat().map((prop) => `${prop}: ${helper.value};`).join("");
    styles += `.va-${helper.prefix}--${helper.postfix} { ${style} }`;
    return styles;
  }, "");
};
const handleConfigUpdate = (helpers, colors) => {
  const coloredHelpers = getColorsClassesHelpers(helpers, colors);
  addOrUpdateStyleElement(
    "va-color-helpers",
    () => getColorsClassesStyles(coloredHelpers)
  );
};
const createColorHelpersPlugin = () => {
  if (isServer()) {
    return;
  }
  const { globalConfig } = useGlobalConfig();
  watch(() => globalConfig.value.colorsClasses, (newHelpers) => {
    if (newHelpers.length) {
      handleConfigUpdate(newHelpers, globalConfig.value.colors.variables);
    }
  }, { immediate: true, deep: true });
  watch(() => globalConfig.value.colors.variables, (newColors) => {
    if (!newColors) {
      return;
    }
    handleConfigUpdate(globalConfig.value.colorsClasses, newColors);
  }, { immediate: true, deep: true });
  return {
    renderColorHelpers: () => {
      const coloredHelpers = getColorsClassesHelpers(globalConfig.value.colorsClasses, globalConfig.value.colors.variables);
      return getColorsClassesStyles(coloredHelpers);
    }
  };
};
const ColorsClassesPlugin = defineVuesticPlugin(() => ({
  install(app) {
    defineGlobalProperty(app, "$vaColorsClasses", createColorHelpersPlugin());
  }
}));
const AccordionServiceKey = Symbol("AccordionService");
const useAccordion = (props, state) => {
  const items2 = ref([]);
  const makeState = () => {
    const correctItemsCount = Math.max(items2.value.length, state.value.length);
    return Array.from({ length: correctItemsCount }, (_, index) => {
      return state.value[index] ?? false;
    });
  };
  const getItemValue = (item) => {
    return state.value[items2.value.indexOf(item)] ?? false;
  };
  const onItemsChanged = () => {
    state.value = makeState();
  };
  const registerItem = (item) => {
    items2.value.push(item);
    onItemsChanged();
  };
  const unregisterItem = (item) => {
    items2.value = items2.value.filter((i) => i !== item);
    nextTick(onItemsChanged);
  };
  const setItemValue = (item, value) => {
    const index = items2.value.indexOf(item);
    if (index === -1) {
      warn("Accordion item is not registered yet");
      return;
    }
    if (!props.multiple) {
      state.value = makeState().map((el, i) => {
        if (i === index) {
          return value;
        }
        return false;
      });
    } else {
      state.value[index] = value;
    }
  };
  provide(AccordionServiceKey, {
    registerItem,
    unregisterItem,
    getItemValue,
    setItemValue,
    props: computed(() => props)
  });
  return { items: items2 };
};
const useAccordionItem = () => {
  const accordion = inject$1(AccordionServiceKey, void 0);
  if (!accordion) {
    return { accordionProps: ref({}) };
  }
  const item = {};
  accordion.registerItem(item);
  onBeforeUnmount(() => accordion.unregisterItem(item));
  const accordionItemValue = computed({
    get: () => accordion.getItemValue(item),
    set: (value) => accordion.setItemValue(item, value)
  });
  return {
    accordionItemValue,
    accordionProps: accordion.props
  };
};
const _hoisted_1$13 = { class: "va-accordion" };
const _sfc_main$1O = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaAccordion"
  },
  __name: "VaAccordion",
  props: {
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: Array, default: () => [] },
    multiple: { type: Boolean, default: false },
    inset: { type: Boolean, default: false },
    stateful: { type: Boolean, default: true },
    popout: { type: Boolean, default: false }
  },
  emits: [...useStatefulEmits],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const { valueComputed } = useStateful(props, emit2, "modelValue");
    const { items: items2 } = useAccordion(props, valueComputed);
    const collapses = items2;
    const value = valueComputed;
    __expose({
      collapses,
      value
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$13, [
        renderSlot(_ctx.$slots, "default")
      ]);
    };
  }
});
const VaAccordion = withConfigTransport$1(_sfc_main$1O);
const noop = () => {
};
const throttle = (func, wait) => {
  let lastTime = 0;
  return function(...args) {
    const now = Date.now();
    if (now - lastTime < wait) {
      return;
    }
    func.apply(this, args);
    lastTime = now;
  };
};
function getWindowHeight() {
  return document.documentElement.clientHeight || window.innerHeight || document.body.clientHeight;
}
function computeAffixedState({
  coordinates,
  offsetTop,
  offsetBottom,
  target
}) {
  let isTopAffixed = false;
  let isBottomAffixed = false;
  const windowHeight = getWindowHeight();
  if (offsetTop != null && windowHeight) {
    if (target === window) {
      isTopAffixed = coordinates.top <= offsetTop;
    } else {
      const { top } = target.getBoundingClientRect();
      isTopAffixed = coordinates.top - top <= offsetTop;
    }
  }
  if (offsetBottom != null && windowHeight) {
    if (target === window) {
      isBottomAffixed = coordinates.bottom >= windowHeight - offsetBottom;
    } else {
      const { bottom } = target.getBoundingClientRect();
      isBottomAffixed = bottom - coordinates.bottom <= offsetBottom;
    }
  }
  return {
    isTopAffixed,
    isBottomAffixed
  };
}
function checkAffixedStateChange(currentState, nextState) {
  return currentState.isTopAffixed !== nextState.isTopAffixed || currentState.isBottomAffixed !== nextState.isBottomAffixed;
}
function handleThrottledEvent(eventName, context) {
  const { target, element, offsetTop, offsetBottom, setState, getState, initialPosition } = context;
  if (!element) {
    return;
  }
  const isInitialCall = !eventName;
  const coordinates = element.getBoundingClientRect();
  const options = {
    offsetBottom,
    offsetTop,
    target
  };
  const nextState = isInitialCall && initialPosition ? computeAffixedState({ coordinates: initialPosition, ...options }) : computeAffixedState({ coordinates, ...options });
  const prevState = getState();
  if (checkAffixedStateChange(prevState, nextState)) {
    setState({ ...nextState, width: coordinates.width });
  } else if (prevState.width !== coordinates.width) {
    setState({ ...prevState, width: coordinates.width });
  }
}
function useCaptureDefault(eventName) {
  return eventName === "scroll";
}
function useEventsHandlerWithThrottle(events, {
  handler,
  useCapture = useCaptureDefault,
  wait = 50
}) {
  const clearHandlersArray = events.map((eventName) => {
    const _handler = throttle((event) => handler(eventName, event), wait);
    window.addEventListener(eventName, _handler, useCapture(eventName));
    return () => window.removeEventListener(eventName, _handler, useCapture(eventName));
  });
  return () => clearHandlersArray.forEach((clear) => clear());
}
const _sfc_main$1N = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaAffix"
  },
  __name: "VaAffix",
  props: {
    ...useComponentPresetProp,
    offsetTop: { type: [Number, String], default: void 0 },
    offsetBottom: { type: [Number, String], default: void 0 },
    target: { type: [Object, Function], default: getWindow$1 }
  },
  emits: ["change"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const element = shallowRef();
    const getTargetElement2 = () => typeof props.target === "function" ? props.target() : props.target;
    const isAffixed = computed(() => state.value.isTopAffixed || state.value.isBottomAffixed);
    const state = ref({
      isTopAffixed: false,
      isBottomAffixed: false
    });
    const getState = () => state.value;
    const setState = (newState) => {
      state.value = newState;
      emit2("change", isAffixed);
    };
    const offsetTopComputed = useNumericProp("offsetTop");
    const offsetBottomComputed = useNumericProp("offsetBottom");
    const calculateTop = () => {
      const target = getTargetElement2();
      if (!target) {
        return 0;
      }
      if (offsetTopComputed.value === void 0) {
        return;
      }
      if (!(target instanceof Window)) {
        const { top } = target.getBoundingClientRect();
        return top + offsetTopComputed.value;
      }
      return offsetTopComputed.value;
    };
    const calculateBottom = () => {
      const target = getTargetElement2();
      if (!target) {
        return 0;
      }
      if (offsetBottomComputed.value === void 0) {
        return;
      }
      if (!(target instanceof Window)) {
        const { bottom } = target.getBoundingClientRect();
        const { borderTopWidth, borderBottomWidth } = getComputedStyle(target);
        const { offsetHeight, clientHeight } = target;
        const scrollBarHeight = offsetHeight - clientHeight - parseInt(borderTopWidth) - parseInt(borderBottomWidth);
        return getWindowHeight() - (bottom - offsetBottomComputed.value) + scrollBarHeight;
      }
      return offsetBottomComputed.value;
    };
    const convertToPixels = (calculate) => {
      const result = calculate();
      return result === void 0 ? void 0 : `${result}px`;
    };
    const computedClass = computed(() => [{ "va-affix--affixed": isAffixed }]);
    const computedStyle = computed(() => ({
      top: state.value.isTopAffixed ? convertToPixels(calculateTop) : void 0,
      bottom: state.value.isBottomAffixed ? convertToPixels(calculateBottom) : void 0,
      width: `${state.value.width}px`
    }));
    const initialPosition = ref();
    const throttledEventHandler = (eventName, event) => {
      const context = {
        ...props,
        offsetTop: offsetTopComputed.value,
        offsetBottom: offsetBottomComputed.value,
        initialPosition: initialPosition.value,
        element: element.value,
        target: getTargetElement2(),
        setState,
        getState
      };
      if (!eventName || eventName === "resize") {
        handleThrottledEvent(eventName, context);
      } else if (event && event.target) {
        const target = getTargetElement2();
        if (target === event.target || target instanceof Window) {
          handleThrottledEvent(eventName, context);
        } else {
          setState({
            isBottomAffixed: false,
            isTopAffixed: false
          });
        }
      }
    };
    let clearEventListeners = noop;
    onMounted(() => {
      var _a2;
      initialPosition.value = (_a2 = element.value) == null ? void 0 : _a2.getBoundingClientRect();
      const events = ["scroll", "resize"];
      clearEventListeners = useEventsHandlerWithThrottle(events, {
        handler: throttledEventHandler
      });
      nextTick(() => {
        throttledEventHandler(null);
      });
    });
    onBeforeUnmount(clearEventListeners);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "element",
        ref: element,
        class: "va-affix"
      }, [
        createBaseVNode("div", {
          style: normalizeStyle({ visibility: isAffixed.value ? "hidden" : "inherit" })
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 4),
        isAffixed.value ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(computedClass.value),
          style: normalizeStyle(computedStyle.value)
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 6)) : createCommentVNode("", true)
      ], 512);
    };
  }
});
const VaAffix = withConfigTransport$1(_sfc_main$1N);
const useElementTextColor = (background) => {
  const { textColorComputed } = useTextColor(background);
  return textColorComputed;
};
const useCurrentElement = (el) => {
  if (el) {
    return el;
  }
  const vm = getCurrentInstance();
  const currentEl = shallowRef();
  onMounted(() => {
    currentEl.value = vm.proxy.$el ?? void 0;
  });
  onUpdated(() => {
    currentEl.value = vm.proxy.$el ?? void 0;
  });
  onBeforeUnmount(() => {
    currentEl.value = vm.proxy.$el ?? void 0;
  });
  return currentEl;
};
const useAlertStyles = (props) => {
  const { getColor } = useColors();
  const isTransparentBackground = computed(() => Boolean(props.outline || props.border));
  const { textColorComputed } = useTextColor(toRef(props, "color"), isTransparentBackground);
  const colorComputed = computed(() => getColor(props.color));
  const alertStyle = computed(() => {
    let background = colorComputed.value;
    let boxShadow = "none";
    if (props.outline) {
      background = "transparent";
    }
    if (props.border) {
      background = "var(--va-background-primary)";
      boxShadow = "var(--va-alert-box-shadow)";
    }
    return {
      border: props.outline ? `1px solid ${colorComputed.value}` : "",
      padding: props.dense ? "var(--va-alert-padding-y-dense) var(--va-alert-padding-x)" : "",
      backgroundColor: background,
      boxShadow
    };
  });
  const currentColor = useElementTextColor(useElementBackground(useCurrentElement()));
  const contentStyle = computed(() => {
    return {
      alignItems: props.center ? "center" : "",
      color: props.border || props.outline ? currentColor.value : textColorComputed.value
    };
  });
  const titleStyle = computed(() => {
    return { color: textColorComputed.value };
  });
  const borderStyle = computed(() => ({
    backgroundColor: props.borderColor ? getColor(props.borderColor) : colorComputed.value
  }));
  return {
    alertStyle,
    contentStyle,
    titleStyle,
    borderStyle
  };
};
const _hoisted_1$12 = {
  key: 1,
  class: "va-alert__close"
};
const _hoisted_2$v = ["aria-label"];
const _sfc_main$1M = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaAlert"
  },
  __name: "VaAlert",
  props: {
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: Boolean, default: true },
    stateful: { type: Boolean, default: true },
    color: { type: String, default: "primary" },
    textColor: { type: String, default: "" },
    title: { type: String, default: "" },
    description: { type: String, default: "" },
    icon: { type: String, default: "" },
    closeText: { type: String, default: "" },
    closeIcon: { type: String, default: "close" },
    closeable: { type: Boolean, default: false },
    dense: { type: Boolean, default: false },
    outline: { type: Boolean, default: false },
    center: { type: Boolean, default: false },
    borderColor: { type: String, default: "" },
    border: {
      type: String,
      default: "",
      validator: (value) => ["top", "right", "bottom", "left", ""].includes(value)
    }
  },
  emits: [...useStatefulEmits],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const {
      contentStyle,
      titleStyle,
      alertStyle,
      borderStyle
    } = useAlertStyles(props);
    const { valueComputed } = useStateful(props, emit2);
    const hide = () => {
      valueComputed.value = false;
    };
    const show = () => {
      valueComputed.value = true;
    };
    const slots = useSlots();
    const hasIcon = computed(() => props.icon || slots.icon);
    const hasTitle = computed(() => props.title || slots.title);
    const borderClass = computed(() => `va-alert__border--${props.border}`);
    const { t } = useTranslation();
    __expose({
      hide,
      show
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Transition, { name: "fade" }, {
        default: withCtx(() => [
          unref(valueComputed) ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "va-alert",
            style: normalizeStyle(unref(alertStyle)),
            role: "alert"
          }, [
            createBaseVNode("div", {
              style: normalizeStyle(unref(borderStyle)),
              class: normalizeClass([borderClass.value, "va-alert__border"])
            }, null, 6),
            hasIcon.value ? (openBlock(), createElementBlock("div", {
              key: 0,
              style: normalizeStyle(unref(contentStyle)),
              class: "va-alert__icon",
              "aria-hidden": "true"
            }, [
              renderSlot(_ctx.$slots, "icon", {}, () => [
                createVNode(unref(VaIcon), { name: __props.icon }, null, 8, ["name"])
              ])
            ], 4)) : createCommentVNode("", true),
            createBaseVNode("div", {
              style: normalizeStyle(unref(contentStyle)),
              class: "va-alert__content"
            }, [
              hasTitle.value ? (openBlock(), createElementBlock("div", {
                key: 0,
                style: normalizeStyle(unref(titleStyle)),
                class: "va-alert__title"
              }, [
                renderSlot(_ctx.$slots, "title", {}, () => [
                  createTextVNode(toDisplayString(__props.title), 1)
                ])
              ], 4)) : createCommentVNode("", true),
              createBaseVNode("span", null, [
                renderSlot(_ctx.$slots, "default", {}, () => [
                  createTextVNode(toDisplayString(_ctx.$props.description), 1)
                ])
              ])
            ], 4),
            __props.closeable ? (openBlock(), createElementBlock("div", _hoisted_1$12, [
              createBaseVNode("div", {
                role: "button",
                class: "va-alert__close--closeable",
                tabindex: "0",
                "aria-label": __props.closeText || unref(t)("closeAlert"),
                style: normalizeStyle(unref(contentStyle)),
                onClick: hide,
                onKeydown: [
                  withKeys(hide, ["space"]),
                  withKeys(hide, ["enter"])
                ]
              }, [
                renderSlot(_ctx.$slots, "close", {}, () => [
                  !__props.closeText ? (openBlock(), createBlock(unref(VaIcon), {
                    key: 0,
                    name: __props.closeIcon
                  }, null, 8, ["name"])) : createCommentVNode("", true),
                  createTextVNode(" " + toDisplayString(__props.closeText), 1)
                ])
              ], 44, _hoisted_2$v)
            ])) : createCommentVNode("", true)
          ], 4)) : createCommentVNode("", true)
        ]),
        _: 3
      });
    };
  }
});
const VaAlert = withConfigTransport$1(_sfc_main$1M);
const useFixedBarProps = {
  hideOnScroll: { type: Boolean, default: false },
  fixed: { type: Boolean, default: false },
  bottom: { type: Boolean, default: false }
};
function useFixedBar(props, isScrolledDown) {
  const isHiddenComputed = computed(() => isScrolledDown.value ? !!props.hideOnScroll : false);
  const transformComputed = computed(() => {
    if (!props.bottom && !isHiddenComputed.value) {
      return;
    }
    if (props.bottom && isHiddenComputed.value) {
      return "translateY(100%)";
    }
    if (props.bottom) {
      return props.fixed ? "translateY(-100%)" : "translateY(0)";
    }
    return "translateY(-100%)";
  });
  const positionComputed = computed(() => {
    if (props.fixed) {
      return "fixed";
    }
    return isHiddenComputed.value ? "absolute" : void 0;
  });
  const fixedBarStyleComputed = computed(() => {
    const result = {
      top: props.bottom && (isHiddenComputed.value || props.fixed) ? "100%" : void 0,
      transform: props.hideOnScroll || props.fixed ? transformComputed.value : void 0
    };
    positionComputed.value && Object.assign(result, { position: positionComputed.value });
    return result;
  });
  return { fixedBarStyleComputed };
}
function getTargetElement(target) {
  if (!target) {
    throw new Error("No target was provided for `useScroll` hook!");
  }
  return typeof target === "string" ? document.querySelector(target) : target;
}
function setupScroll(fixed, target) {
  const scrollRoot = shallowRef();
  let targetElement;
  const isScrolledDown = ref(false);
  const prevScrollPosition = ref(0);
  const onScroll = (e) => {
    const target2 = e.target;
    const scrollValue = e.target instanceof Window ? target2.scrollY : target2.scrollTop;
    isScrolledDown.value = prevScrollPosition.value < scrollValue;
    prevScrollPosition.value = scrollValue;
  };
  onMounted(() => {
    targetElement = fixed ? window : getTargetElement(target || scrollRoot.value);
    targetElement == null ? void 0 : targetElement.addEventListener("scroll", onScroll, fixed);
  });
  onBeforeUnmount(() => {
    targetElement == null ? void 0 : targetElement.removeEventListener("scroll", onScroll);
  });
  return { scrollRoot, isScrolledDown };
}
const _sfc_main$1L = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaAppBar"
  },
  __name: "VaAppBar",
  props: {
    ...useFixedBarProps,
    ...useComponentPresetProp,
    gradient: { type: Boolean, default: false },
    target: { type: [Object, String], default: "" },
    shadowOnScroll: { type: Boolean, default: false },
    shadowColor: { type: String, default: "" },
    color: { type: String, default: "primary" }
  },
  setup(__props) {
    const props = __props;
    const { scrollRoot, isScrolledDown } = setupScroll(props.fixed, props.target);
    const { fixedBarStyleComputed } = useFixedBar(props, isScrolledDown);
    const { getColor, getGradientBackground: getGradientBackground2, getBoxShadowColor: getBoxShadowColor2 } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const { textColorComputed } = useTextColor(toRef(props, "color"));
    const showShadowComputed = computed(() => isScrolledDown.value ? !!props.shadowOnScroll : false);
    const shadowColorComputed = computed(() => getColor(props.shadowColor, colorComputed.value));
    const computedShadow = computed(() => {
      const shadow = getBoxShadowColor2(props.shadowColor ? shadowColorComputed.value : colorComputed.value);
      return showShadowComputed.value ? `var(--va-app-bar-shadow) ${shadow}` : "";
    });
    const computedStyle = computed(() => ({
      ...fixedBarStyleComputed.value,
      background: props.gradient ? getGradientBackground2(colorComputed.value) : colorComputed.value,
      boxShadow: computedShadow.value,
      color: textColorComputed.value
    }));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("header", {
        ref_key: "scrollRoot",
        ref: scrollRoot,
        role: "toolbar",
        class: "va-app-bar",
        style: normalizeStyle(computedStyle.value)
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 4);
    };
  }
});
const VaAppBar = withConfigTransport$1(_sfc_main$1L);
const _sfc_main$1K = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaAspectRatio"
  },
  __name: "VaAspectRatio",
  props: {
    ...useComponentPresetProp,
    ratio: {
      type: [Number, String],
      default: "auto"
    },
    contentHeight: { type: [Number, String], default: 1 },
    contentWidth: { type: [Number, String], default: 1 },
    maxWidth: {
      type: [Number, String],
      default: 0,
      validator: (v) => Number(v) >= 0
    }
  },
  setup(__props) {
    const props = __props;
    const contentHeightComputed = useNumericProp("contentHeight");
    const contentWidthComputed = useNumericProp("contentWidth");
    const aspectRatio = computed(() => {
      if (props.ratio === "auto" && props.contentHeight === 1 && props.contentWidth === 1) {
        return 0;
      }
      if (!isNaN(+props.ratio)) {
        return props.ratio;
      }
      return contentWidthComputed.value / contentHeightComputed.value;
    });
    const stylesComputed = computed(() => {
      if (!aspectRatio.value) {
        return;
      }
      return { paddingBottom: `${1 / aspectRatio.value * 100}%` };
    });
    const maxWidthComputed = computed(() => props.maxWidth ? `${props.maxWidth}px` : void 0);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "va-aspect-ratio",
        style: normalizeStyle(`--va-max-width-computed: ${String(maxWidthComputed.value)}`)
      }, [
        stylesComputed.value ? (openBlock(), createElementBlock("div", {
          key: 0,
          style: normalizeStyle(stylesComputed.value)
        }, null, 4)) : createCommentVNode("", true),
        renderSlot(_ctx.$slots, "default")
      ], 4);
    };
  }
});
const VaAspectRatio = withConfigTransport$1(_sfc_main$1K);
const _sfc_main$1J = /* @__PURE__ */ defineComponent({
  name: "VaFallback",
  props: {
    fallbackSrc: {
      type: String
    },
    fallbackText: {
      type: String
    },
    fallbackIcon: {
      type: String
    },
    fallbackRender: {
      type: Function
    }
  },
  components: { VaIcon },
  emits: ["fallback"],
  setup(props, { emit: emit2 }) {
    onMounted(() => {
      emit2("fallback");
    });
    if (props.fallbackIcon) {
      return () => h(VaIcon, {
        name: props.fallbackIcon
      });
    }
    if (props.fallbackSrc) {
      return () => h("img", {
        src: props.fallbackSrc
      });
    }
    if (props.fallbackRender) {
      return () => {
        var _a2;
        return h((_a2 = props.fallbackRender) == null ? void 0 : _a2.call(props));
      };
    }
    return () => h("span", props.fallbackText);
  }
});
const VaFallback = withConfigTransport$1(_sfc_main$1J);
function normalizeProps(props) {
  switch (true) {
    case Array.isArray(props):
      return props.reduce((acc, prop) => ({ ...acc, [prop]: null }), {});
    case (typeof props === "object" && props !== null):
      return props;
    default:
      return {};
  }
}
function mergeProps(to, from, optionsType = "props") {
  const { mixins, extends: extendsOptions } = from;
  extendsOptions && mergeProps(to, extendsOptions, optionsType);
  mixins && mixins.forEach((m) => mergeProps(to, m, optionsType));
  const props = normalizeProps(from[optionsType]);
  for (const key in props) {
    to[key] = props[key];
  }
}
function getComponentOptions(component) {
  if (component.options) {
    return component.options;
  }
  if (component.__vccOpts || component.__b) {
    return { ...component.__vccOpts, ...component.__b };
  }
  return component;
}
function resolveProps(options, optionsType = "props") {
  const mixins = options.mixins ?? [];
  const extendsOptions = options.extends ?? [];
  const result = {};
  mergeProps(result, extendsOptions, optionsType);
  for (let i = 0; i < mixins.length; i++) {
    mergeProps(result, mixins[i], optionsType);
  }
  Object.assign(result, normalizeProps(options[optionsType]));
  return result;
}
const getComponentProps = (component) => {
  return resolveProps(getComponentOptions(component));
};
function extractComponentProps(component, ignoreProps) {
  const props = getComponentProps(component);
  if (ignoreProps) {
    return Object.keys(props).reduce((acc, propName) => {
      if (ignoreProps.includes(propName)) {
        return acc;
      }
      if (props[propName] === void 0) {
        return acc;
      }
      acc[propName] = typeof props[propName] === "string" ? {} : props[propName];
      return acc;
    }, {});
  }
  return props;
}
function extractComponentEmits(component) {
  return [...new Set(component.emits)];
}
const filterComponentProps = (childProps) => {
  const { props } = getCurrentInstance();
  return computed(() => {
    return Object.keys(childProps).reduce((acc, propName) => {
      acc[propName] = props[propName];
      return acc;
    }, {});
  });
};
const _hoisted_1$11 = ["src", "alt"];
const VaFallbackPropsDeclaration = extractComponentProps(VaFallback);
const _sfc_main$1I = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaAvatar"
  },
  __name: "VaAvatar",
  props: {
    ...useLoadingProps,
    ...useSizeProps,
    ...useComponentPresetProp,
    ...VaFallbackPropsDeclaration,
    color: { type: String, default: "primary" },
    textColor: { type: String },
    square: { type: Boolean, default: false },
    fontSize: { type: String, default: "" },
    src: { type: String, default: null },
    icon: { type: String, default: "" },
    alt: { type: String, default: "" }
  },
  emits: ["error", "fallback"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const backgroundColorComputed = computed(() => {
      if (props.loading || props.src && !hasLoadError.value) {
        return void 0;
      }
      return colorComputed.value;
    });
    const { sizeComputed, fontSizeComputed } = useSize(props, "VaAvatar");
    const { textColorComputed } = useTextColor(backgroundColorComputed);
    const computedStyle = computed(() => ({
      fontSize: props.fontSize || fontSizeComputed.value
    }));
    const classesComputed = useBem("va-avatar", () => ({
      ...pick(props, ["square"])
    }));
    const hasLoadError = ref(false);
    const onLoadError = (event) => {
      hasLoadError.value = true;
      emit2("error", event);
    };
    watch(() => props.src, () => {
      hasLoadError.value = false;
    });
    const avatarOptions = computed(() => ({
      hasError: hasLoadError.value,
      onError: onLoadError
    }));
    const VaFallbackProps2 = filterComponentProps(VaFallbackPropsDeclaration);
    __expose({
      hasLoadError
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["va-avatar", unref(classesComputed)]),
        style: normalizeStyle([computedStyle.value, `--va-background-color-computed: ${String(backgroundColorComputed.value)};--va-text-color-computed: ${String(unref(textColorComputed))};--va-size-computed: ${String(unref(sizeComputed))}`])
      }, [
        _ctx.$props.loading ? (openBlock(), createBlock(unref(VaProgressCircle), {
          key: 0,
          size: unref(sizeComputed),
          color: colorComputed.value,
          indeterminate: ""
        }, null, 8, ["size", "color"])) : renderSlot(_ctx.$slots, "default", normalizeProps$1(mergeProps$1({ key: 1 }, avatarOptions.value)), () => [
          _ctx.$props.src && !hasLoadError.value ? (openBlock(), createElementBlock("img", {
            key: 0,
            src: _ctx.$props.src,
            alt: _ctx.$props.alt,
            onError: onLoadError
          }, null, 40, _hoisted_1$11)) : hasLoadError.value && _ctx.$props.src ? renderSlot(_ctx.$slots, "fallback", { key: 1 }, () => [
            createVNode(unref(VaFallback), mergeProps$1(unref(VaFallbackProps2), {
              onFallback: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("fallback"))
            }), null, 16)
          ]) : _ctx.$props.icon ? (openBlock(), createBlock(unref(VaIcon), {
            key: 2,
            name: _ctx.$props.icon
          }, null, 8, ["name"])) : renderSlot(_ctx.$slots, "fallback", { key: 3 }, () => [
            createVNode(unref(VaFallback), mergeProps$1(unref(VaFallbackProps2), {
              onFallback: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("fallback"))
            }), null, 16)
          ])
        ])
      ], 6);
    };
  }
});
const VaAvatar = withConfigTransport$1(_sfc_main$1I);
const VaAvatarProps = extractComponentProps(VaAvatar);
const _sfc_main$1H = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaAvatarGroup"
  },
  __name: "VaAvatarGroup",
  props: {
    ...useSizeProps,
    ...useComponentPresetProp,
    ...VaAvatarProps,
    max: {
      type: [Number, String],
      default: 0
    },
    vertical: {
      type: Boolean,
      default: false
    },
    options: {
      type: Array,
      default: () => []
    },
    /** If there are more avatars that can be displayed we show rest number. This prop changes color of rest indicator. */
    restColor: {
      type: String,
      default: "secondary"
    }
  },
  setup(__props) {
    const props = __props;
    const maxComputed = useNumericProp("max");
    const classComputed = useBem("va-avatar-group", () => ({
      ...pick(props, ["vertical"])
    }));
    const maxOptions = computed(() => maxComputed.value && maxComputed.value <= props.options.length ? props.options.slice(0, maxComputed.value) : props.options);
    const restOptionsCount = computed(() => {
      const hasOptions = props.options.length > 0;
      const canAddMoreOptions = maxOptions.value.length < props.options.length;
      const remainingOptions = props.options.length - (maxComputed.value || 0);
      return hasOptions && canAddMoreOptions ? remainingOptions : 0;
    });
    const { sizeComputed, fontSizeComputed } = useSize(props, "VaAvatarGroup");
    const filteredAvatarProps = filterComponentProps(VaAvatarProps);
    const avatarProps = computed(() => ({
      ...filteredAvatarProps.value,
      fontSize: fontSizeComputed.value,
      size: sizeComputed.value
    }));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["va-avatar-group", unref(classComputed)]),
        role: "list"
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(maxOptions.value, (option, idx) => {
          return openBlock(), createBlock(unref(VaAvatar), mergeProps$1({ key: idx }, { ...avatarProps.value, ...option }, { role: "listitem" }), null, 16);
        }), 128)),
        restOptionsCount.value > 0 ? renderSlot(_ctx.$slots, "rest", normalizeProps$1(mergeProps$1({ key: 0 }, avatarProps.value)), () => [
          createVNode(unref(VaAvatar), mergeProps$1(avatarProps.value, {
            color: __props.restColor,
            class: "va-avatar-group__rest",
            role: "listitem"
          }), {
            default: withCtx(() => [
              createTextVNode(" +" + toDisplayString(restOptionsCount.value), 1)
            ]),
            _: 1
          }, 16, ["color"])
        ]) : createCommentVNode("", true)
      ], 2);
    };
  }
});
const VaAvatarGroup = withConfigTransport$1(_sfc_main$1H);
const _hoisted_1$10 = ["aria-label", "onKeydown"];
const _sfc_main$1G = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaBacktop"
  },
  __name: "VaBacktop",
  props: {
    ...useComponentPresetProp,
    target: {
      type: [Object, String],
      default: void 0
    },
    visibilityHeight: { type: [Number, String], default: 300 },
    speed: { type: [Number, String], default: 50 },
    verticalOffset: { type: String, default: "1rem" },
    horizontalOffset: { type: String, default: "1rem" },
    color: { type: String, default: "" },
    horizontalPosition: {
      type: String,
      default: "right",
      validator: (value) => ["right", "left"].includes(value)
    },
    verticalPosition: {
      type: String,
      default: "bottom",
      validator: (value) => ["bottom", "top"].includes(value)
    },
    ariaLabel: useTranslationProp("$t:backToTop")
  },
  setup(__props) {
    const props = __props;
    const targetScrollValue = ref(0);
    const computedStyle = computed(() => ({
      [props.verticalPosition]: props.verticalOffset,
      [props.horizontalPosition]: props.horizontalOffset
    }));
    let targetElement;
    const visibilityHeightComputed = useNumericProp("visibilityHeight");
    const speedComputed = useNumericProp("speed");
    const getTargetElement2 = () => {
      if (!props.target) {
        return window;
      }
      if (typeof props.target === "string") {
        const target = document.querySelector(props.target);
        if (!target) {
          warn(`Target element [${props.target}] is not found, falling back to window.`);
          return window;
        }
        return target;
      }
      return props.target;
    };
    const scrolled = ref(false);
    const interval = ref(0);
    const scrollToTop = () => {
      if (scrolled.value) {
        return;
      }
      scrolled.value = true;
      if (targetElement instanceof Window) {
        window.scrollTo({
          top: 0,
          behavior: "smooth"
        });
        return;
      }
      interval.value = window.setInterval(() => {
        if (targetElement instanceof Element) {
          if (targetElement.scrollTop === 0) {
            clearInterval(interval.value);
            scrolled.value = false;
          } else {
            const next = Math.floor(targetElement.scrollTop - speedComputed.value);
            targetElement.scrollTo(0, next);
          }
        }
      }, 15);
    };
    const handleScroll = () => {
      targetScrollValue.value = targetElement instanceof Window ? targetElement.scrollY : targetElement.scrollTop;
    };
    const server = isServer();
    const visible = computed(() => {
      if (server) {
        return false;
      }
      return targetScrollValue.value > visibilityHeightComputed.value;
    });
    if (!server) {
      onMounted(() => {
        targetElement = getTargetElement2();
        targetElement.addEventListener("scroll", handleScroll, true);
      });
      onBeforeUnmount(() => targetElement == null ? void 0 : targetElement.removeEventListener("scroll", handleScroll));
    }
    const { tp } = useTranslation();
    return (_ctx, _cache) => {
      return visible.value ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: "va-backtop",
        role: "button",
        "aria-label": unref(tp)(_ctx.$props.ariaLabel),
        tabindex: "1",
        style: normalizeStyle(computedStyle.value),
        onClick: scrollToTop,
        onKeydown: withKeys(withModifiers(scrollToTop, ["stop"]), ["enter"])
      }, [
        renderSlot(_ctx.$slots, "default", {}, () => [
          createVNode(unref(VaButton), {
            "aria-hidden": "true",
            icon: "va-arrow-up",
            color: __props.color
          }, null, 8, ["color"])
        ])
      ], 44, _hoisted_1$10)) : createCommentVNode("", true);
    };
  }
});
const VaBacktop = withConfigTransport$1(_sfc_main$1G);
const verticalPlacement = ["top", "bottom"];
const horizontalPlacement = ["left", "right"];
const placementPosition = [...verticalPlacement, ...horizontalPlacement];
const placementAlignment = ["start", "end", "center"];
const placementsPositions = placementPosition.reduce((acc, position) => {
  acc.push(position);
  placementAlignment.forEach((alignment) => acc.push(`${position}-${alignment}`));
  return acc;
}, ["auto"]);
const placementAliasesPositions = verticalPlacement.reduce((acc, yPosition) => {
  horizontalPlacement.forEach((xPosition) => {
    acc.push(`${yPosition}-${xPosition}`);
    acc.push(`${xPosition}-${yPosition}`);
  });
  return acc;
}, []);
const placementsPositionsWithAliases = [...placementsPositions, ...placementAliasesPositions];
const aliasToPlacement = {
  "top-left": "top-start",
  "left-top": "top-start",
  "top-right": "top-end",
  "right-top": "top-end",
  "bottom-left": "bottom-start",
  "left-bottom": "bottom-start",
  "bottom-right": "bottom-end",
  "right-bottom": "bottom-end"
};
const usePlacementAliasesProps = {
  placement: {
    type: String,
    default: "auto",
    validator: (position) => placementsPositionsWithAliases.includes(position)
  }
};
const usePlacementAliases = (props) => {
  const placementArray = computed(() => {
    const placement = aliasToPlacement[props.placement] || props.placement;
    return placement.split("-");
  });
  const position = computed(() => {
    const position2 = placementArray.value[0];
    return position2 === "auto" ? "bottom" : position2;
  });
  const align = computed(() => {
    return placementArray.value[1] || "center";
  });
  return { position, align };
};
const useParsableMeasure = () => {
  const isParsableMeasure2 = (value) => {
    if (typeof value === "string") {
      return !isNaN(+value) || value.endsWith("px") || value.endsWith("rem");
    }
    return false;
  };
  const isParsablePositiveMeasure2 = (value) => {
    if (typeof value === "number") {
      return value >= 0;
    }
    return isParsableMeasure2(value) && parseInt(value) >= 0;
  };
  const parseSizeValue2 = (value, pageFontSize = 16) => {
    const valueUnref = unref(value);
    if (typeof valueUnref === "string") {
      const parsedValue = parseInt(valueUnref);
      if (isNaN(parsedValue)) {
        return 0;
      }
      return valueUnref.endsWith("rem") ? parsedValue * unref(pageFontSize) : parsedValue;
    }
    return valueUnref;
  };
  return { isParsableMeasure: isParsableMeasure2, isParsablePositiveMeasure: isParsablePositiveMeasure2, parseSizeValue: parseSizeValue2 };
};
const { isParsableMeasure, parseSizeValue: parseSizeValue$1 } = useParsableMeasure();
const useFloatingPositionProps = {
  overlap: { type: Boolean, default: false },
  placement: {
    type: String,
    default: "top-end",
    validator: (position) => placementsPositionsWithAliases.includes(position)
  },
  offset: {
    type: [Number, String, Array],
    default: 0,
    validator: (value) => {
      if (Array.isArray(value)) {
        return value.every(isParsableMeasure);
      }
      if (typeof value === "string") {
        return isParsableMeasure(value);
      }
      return !isNaN(value);
    }
  }
};
const useFloatingPosition = (props, floating) => {
  if (!floating.value) {
    return {};
  }
  const { position, align } = usePlacementAliases(props);
  const alignmentShiftComputed = computed(() => {
    const alignOptions = {
      start: props.overlap ? "-50%" : "-100%",
      center: "-50%",
      end: props.overlap ? "-50%" : "0%"
    };
    return alignOptions[align.value];
  });
  const offsetMarginComputed = computed(() => {
    if (!props.offset) {
      return {};
    }
    const mainAxis = ["left", "right"].includes(position.value) ? "top" : "left";
    const crossAxis = mainAxis === "top" ? "left" : "top";
    if (Array.isArray(props.offset)) {
      const [x, y] = props.offset.map(parseSizeValue$1);
      return {
        [`margin-${mainAxis}`]: `${x}px`,
        [`margin-${crossAxis}`]: `${y}px`
      };
    }
    const offset2 = parseSizeValue$1(props.offset);
    return {
      [`margin-${crossAxis}`]: `${offset2}px`
    };
  });
  const alignmentComputed = computed(() => {
    const mainAxis = ["left", "right"].includes(position.value) ? "top" : "left";
    const crossAxis = mainAxis === "top" ? "left" : "top";
    let shiftValue = "0%";
    if (crossAxis === "top" && position.value === "bottom") {
      shiftValue = "100%";
    }
    if (crossAxis === "left" && position.value === "right") {
      shiftValue = "100%";
    }
    const alignmentOptions = {
      start: { [mainAxis]: "0%", [crossAxis]: shiftValue },
      center: { [mainAxis]: "50%", [crossAxis]: shiftValue },
      end: { [mainAxis]: "100%", [crossAxis]: shiftValue }
    };
    return alignmentOptions[align.value];
  });
  const transformComputed = computed(() => {
    const coords = {
      top: {
        x: alignmentShiftComputed.value,
        y: props.overlap ? "-50%" : "-100%"
      },
      bottom: {
        x: alignmentShiftComputed.value,
        y: props.overlap ? "-50%" : "0%"
      },
      left: {
        x: props.overlap ? "-50%" : "-100%",
        y: alignmentShiftComputed.value
      },
      right: {
        x: props.overlap ? "-50%" : "0%",
        y: alignmentShiftComputed.value
      }
    };
    const { x, y } = coords[position.value];
    return { transform: `translate(${x}, ${y})` };
  });
  return computed(() => ({
    ...alignmentComputed.value,
    ...transformComputed.value,
    ...offsetMarginComputed.value
  }));
};
const OPTIONS_LIST = {
  props: "prop",
  attrs: "prop",
  slots: "slot"
};
const useDeprecated = (deprecatedList, deprecationSource = ["props", "attrs"]) => {
  if (!isDev) {
    return void 0;
  }
  const instance = getCurrentInstance();
  if (!instance) {
    throw new Error("`useDeprecated` hook must be used only inside of setup function!");
  }
  const instanceName = instance.type.name;
  const deprecatedItems = unref(deprecatedList);
  deprecationSource.every((source) => {
    var _a2;
    const option = OPTIONS_LIST[source];
    const throwWarning = (key) => console.warn(`The '${key}' ${option} (${instanceName} component) is deprecated! Please, check the documentation.`);
    if (source === "props") {
      const propsOptions = ((_a2 = instance.propsOptions) == null ? void 0 : _a2[0]) || {};
      const propsValues = instance.props || {};
      deprecatedItems.forEach((propName) => {
        propsOptions[propName] && propsValues[propName] !== propsOptions[propName].default && throwWarning(propName);
      });
      return true;
    }
    Object.keys({ ...instance[source] }).forEach((key) => {
      if (deprecatedItems.includes(key)) {
        throwWarning(key);
      }
    });
    return true;
  });
};
const _hoisted_1$$ = ["aria-labelledby"];
const _hoisted_2$u = { class: "va-badge__text" };
const _sfc_main$1F = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaBadge"
  },
  __name: "VaBadge",
  props: {
    ...useComponentPresetProp,
    ...useFloatingPositionProps,
    color: { type: String, default: "danger" },
    textColor: { type: String },
    text: { type: [String, Number], default: "" },
    multiLine: { type: Boolean, default: false },
    visibleEmpty: { type: Boolean, default: false },
    dot: { type: Boolean, default: false },
    // TODO: Remove after 1.8.0
    transparent: { type: Boolean, default: false }
  },
  setup(__props) {
    const props = __props;
    useDeprecated(["transparent"]);
    const slots = useSlots();
    const isEmpty = computed(() => !(props.text || props.visibleEmpty || props.dot || slots.text));
    const isFloating = computed(() => !!(slots.default || props.dot));
    const badgeClass = useBem("va-badge", () => ({
      ...pick(props, ["visibleEmpty", "dot", "multiLine"]),
      empty: isEmpty.value,
      floating: isFloating.value
    }));
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const { textColorComputed } = useTextColor(colorComputed);
    const positionStylesComputed = useFloatingPosition(props, isFloating);
    const stylesComputed = computed(() => ({
      color: textColorComputed.value,
      borderColor: colorComputed.value,
      backgroundColor: colorComputed.value,
      opacity: props.transparent ? 0.5 : 1,
      ...unref(positionStylesComputed)
    }));
    const ariaLabelledByComputed = computed(() => props.text ? String(props.text) : void 0);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["va-badge", unref(badgeClass)]),
        role: "status",
        "aria-labelledby": ariaLabelledByComputed.value
      }, [
        createBaseVNode("span", {
          class: "va-badge__text-wrapper",
          style: normalizeStyle(stylesComputed.value)
        }, [
          createBaseVNode("span", _hoisted_2$u, [
            renderSlot(_ctx.$slots, "text", {}, () => [
              createTextVNode(toDisplayString(__props.text), 1)
            ])
          ])
        ], 4),
        renderSlot(_ctx.$slots, "default")
      ], 10, _hoisted_1$$);
    };
  }
});
const VaBadge = withConfigTransport$1(_sfc_main$1F);
const hasOwnProperty = (object, key) => {
  return Object.prototype.hasOwnProperty.call(object, key);
};
const resolveSlot = (slot) => {
  return slot && typeof slot === "function" ? slot() : slot;
};
const useAlignProps = {
  align: {
    type: String,
    default: "left"
  },
  vertical: {
    type: Boolean,
    default: false
  }
};
const horizontalMap = {
  left: "flex-start",
  center: "center",
  right: "flex-end",
  between: "space-between",
  around: "space-around"
};
const verticalMap = {
  left: "flex-start",
  center: "center",
  right: "flex-end",
  stretch: "stretch"
};
const justify = (align, vertical) => {
  return vertical ? "center" : align ? horizontalMap[align] : "flex-start";
};
const items = (align, vertical) => {
  return vertical ? verticalMap[align] : "center";
};
function useAlign(props) {
  const alignComputed = computed(() => {
    return {
      display: "flex",
      flexDirection: props.vertical ? "column" : "row",
      justifyContent: justify(props.align, props.vertical),
      alignItems: items(props.align, props.vertical)
    };
  });
  return {
    alignComputed
  };
}
const _sfc_main$1E = /* @__PURE__ */ defineComponent({
  name: "VaBreadcrumbs",
  props: {
    ...useAlignProps,
    ...useComponentPresetProp,
    separator: { type: String, default: "/" },
    color: { type: String, default: null },
    disabledColor: { type: String, default: "secondary" },
    activeColor: { type: String, default: null },
    separatorColor: { type: String, default: null },
    ariaLabel: useTranslationProp("$t:breadcrumbs")
  },
  setup(props, { slots }) {
    const { alignComputed } = useAlign(props);
    const { getColor } = useColors();
    const computedThemesSeparatorColor = computed(() => {
      return props.separatorColor ? getColor(props.separatorColor) : null;
    });
    const computedThemesColor = computed(() => props.color ? getColor(props.color) : null);
    const computedThemesActiveColor = computed(() => {
      return props.activeColor ? getColor(props.activeColor) : null;
    });
    const childNodeFilter = (result, node) => {
      const nodes = node && node.type === Fragment && node.children ? node.children : [node];
      return [
        ...result,
        ...nodes.filter((node2) => {
          var _a2, _b;
          return !!((_b = (_a2 = node2 == null ? void 0 : node2.type) == null ? void 0 : _a2.name) == null ? void 0 : _b.match(/VaBreadcrumbsItem$/));
        })
      ];
    };
    const createSeparatorComponent = () => {
      const separatorNode = resolveSlot(slots.separator) || [props.separator];
      return h("span", {
        "aria-hidden": true,
        class: ["va-breadcrumbs__separator"],
        style: [{ color: computedThemesSeparatorColor.value }]
      }, separatorNode);
    };
    const isDisabledChild = (child) => {
      const childPropData = child == null ? void 0 : child.props;
      if (!childPropData || !hasOwnProperty(childPropData, "disabled")) {
        return false;
      }
      if (childPropData.disabled === "") {
        return true;
      }
      return Boolean(childPropData.disabled);
    };
    const isAllChildLinks = ref(true);
    const getChildren = () => {
      const defaultSlotContent = resolveSlot(slots.default);
      if (!defaultSlotContent) {
        return;
      }
      const childNodes = defaultSlotContent.reduce(childNodeFilter, []) || [];
      const childNodesLength = childNodes.length;
      const isLastIndexChildNodes = (index) => index === childNodesLength - 1;
      const isChildLink = (child) => {
        const childPropData = child == null ? void 0 : child.props;
        if (!childPropData || !hasOwnProperty(childPropData, "to")) {
          return false;
        }
        return !!(childPropData.to && !childPropData.disabled);
      };
      const createChildComponent = (child, index) => h(
        "span",
        {
          class: ["va-breadcrumbs__item", { "va-breadcrumbs__item--disabled": isDisabledChild(child) }],
          "aria-current": isLastIndexChildNodes(index) && isChildLink(child) ? "location" : false,
          style: {
            color: isDisabledChild(child) ? getColor(props.disabledColor) : isLastIndexChildNodes(index) ? computedThemesActiveColor.value : computedThemesColor.value
          }
        },
        [child]
      );
      const children = [];
      if (childNodesLength) {
        childNodes.forEach((child, index) => {
          if (isAllChildLinks.value && !isChildLink(child)) {
            isAllChildLinks.value = false;
          }
          children.push(createChildComponent(child, index));
          if (!isLastIndexChildNodes(index)) {
            children.push(createSeparatorComponent());
          }
        });
      }
      return children;
    };
    const { tp } = useTranslation();
    return () => h("div", {
      class: "va-breadcrumbs",
      style: alignComputed.value,
      role: isAllChildLinks.value ? "navigation" : void 0,
      "aria-label": isAllChildLinks.value ? tp(props.ariaLabel) : void 0
    }, getChildren());
  }
});
const _sfc_main$1D = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaBreadcrumbsItem"
  },
  __name: "VaBreadcrumbsItem",
  props: {
    ...useRouterLinkProps,
    disabled: { type: Boolean, default: false },
    label: { type: String, default: "" }
  },
  setup(__props) {
    const props = __props;
    const { tagComputed, hrefComputed, isLinkTag } = useRouterLink(props);
    const classComputed = computed(() => ({
      "va-breadcrumb-item--link": isLinkTag.value
    }));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(unref(tagComputed)), {
        class: normalizeClass(["va-breadcrumb-item", classComputed.value]),
        "active-class": _ctx.$props.activeClass,
        href: unref(hrefComputed),
        to: _ctx.$props.to,
        target: _ctx.$props.target,
        replace: _ctx.$props.replace,
        append: _ctx.$props.append,
        exact: _ctx.$props.exact,
        "exact-active-class": _ctx.$props.exactActiveClass
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createTextVNode(toDisplayString(__props.label), 1)
          ])
        ]),
        _: 3
      }, 8, ["class", "active-class", "href", "to", "target", "replace", "append", "exact", "exact-active-class"]);
    };
  }
});
const VaBreadcrumbsItem = withConfigTransport$1(_sfc_main$1D);
const VaBreadcrumbs = withConfigTransport$1(_sfc_main$1E);
const VaButtonProps$1 = omit(extractComponentProps(VaButton), ["block", "gradient"]);
const _sfc_main$1C = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaButtonGroup"
  },
  __name: "VaButtonGroup",
  props: {
    ...VaButtonProps$1,
    ...useComponentPresetProp,
    grow: { type: Boolean, default: false },
    gradient: { type: Boolean, default: false }
  },
  setup(__props) {
    const props = __props;
    const { getColor, getGradientBackground: getGradientBackground2 } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const { textColorComputed } = useTextColor(colorComputed);
    const filteredProps = filterComponentProps(VaButtonProps$1);
    const buttonConfig = computed(() => ({
      VaButton: {
        ...filteredProps.value,
        ...props.gradient && {
          color: "#00000000",
          textColor: textColorComputed.value
        }
      }
    }));
    const computedClass = useBem("va-button-group", () => ({
      square: !props.round,
      grow: props.grow,
      small: props.size === "small",
      large: props.size === "large"
    }));
    const backgroundColor = computed(
      () => props.gradient ? getGradientBackground2(colorComputed.value) : "transparent"
    );
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["va-button-group", unref(computedClass)]),
        style: normalizeStyle(`--va-background-color: ${String(backgroundColor.value)}`)
      }, [
        createVNode(unref(_sfc_main$1W), { components: buttonConfig.value }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 8, ["components"])
      ], 6);
    };
  }
});
const VaButtonGroup = withConfigTransport$1(_sfc_main$1C);
const debounce = (func, wait) => {
  let timeout = null;
  const fn = function(...args) {
    timeout && clearTimeout(timeout);
    timeout = setTimeout(() => {
      timeout = null;
      func.apply(this, args);
    }, wait);
  };
  fn.cancel = () => {
    timeout && clearTimeout(timeout);
    timeout = null;
  };
  return fn;
};
const useDebounceFn = (timeout) => {
  let callback = null;
  const createDebounced = () => {
    return debounce(() => {
      callback == null ? void 0 : callback();
      callback = null;
    }, unref(timeout));
  };
  let debounced = createDebounced();
  if (isRef(timeout)) {
    watch(timeout, () => {
      debounced = createDebounced();
    });
  }
  return {
    // todo check if we need to create proxy here
    debounced: (cb) => {
      callback = cb;
      debounced();
    },
    cancel: () => debounced.cancel()
  };
};
const isTyping = (e) => {
  const target = e.target;
  if (!(target.tagName === "INPUT" || target.tagName === "TEXTAREA")) {
    return false;
  }
  if (target.attributes.getNamedItem("readonly")) {
    return false;
  }
  return true;
};
const isReadonlyArray = (arr) => {
  return Array.isArray(arr);
};
const useNavigation = (isOpen, anchorRef, contentRef, props) => {
  const normalizeTriggerName = (t) => {
    t = t.replace(/-/g, "").toLowerCase();
    if (t === "space") {
      return " ";
    }
    if (t === "rightclick") {
      return "contextmenu";
    }
    return t;
  };
  const normalizedTriggers = computed(() => {
    if (isReadonlyArray(props.trigger)) {
      return props.trigger.map((t) => normalizeTriggerName(t));
    }
    return [normalizeTriggerName(props.trigger)];
  });
  useEvent("keydown", (e) => {
    if (props.disabled) {
      return;
    }
    if (e.key === "Escape" && isOpen.value) {
      isOpen.value = false;
      e.preventDefault();
    }
    if (isTyping(e)) {
      return;
    }
    if (normalizedTriggers.value.includes(normalizeTriggerName(e.key))) {
      isOpen.value = !isOpen.value;
      e.preventDefault();
    }
  }, anchorRef);
  useEvent("keydown", (e) => {
    if (props.disabled) {
      return;
    }
    if (e.key === "Escape" && isOpen.value) {
      isOpen.value = false;
      e.preventDefault();
    }
  }, contentRef);
  useEvent(["click", "contextmenu", "dblclick"], (e) => {
    if (props.disabled) {
      return;
    }
    if (isTyping(e)) {
      return;
    }
    if (normalizedTriggers.value.includes(normalizeTriggerName(e.type))) {
      e.preventDefault();
      if (isOpen.value && props.closeOnAnchorClick) {
        isOpen.value = false;
        if (props.cursor) {
          setTimeout(() => {
            isOpen.value = true;
          }, 16);
        }
      } else {
        isOpen.value = true;
      }
    }
  }, anchorRef);
  useEvent(["click", "contextmenu", "dblclick"], (e) => {
    if (props.closeOnContentClick) {
      isOpen.value = false;
    }
  }, contentRef);
  const { debounced: debounceHover, cancel: cancelHoverDebounce } = useDebounceFn(useNumericProp("hoverOverTimeout"));
  const { debounced: debounceUnHover, cancel: cancelUnHoverDebounce } = useDebounceFn(useNumericProp("hoverOutTimeout"));
  const onMouseHover = (e) => {
    if (props.disabled) {
      return;
    }
    if (!normalizedTriggers.value.includes("hover")) {
      return;
    }
    if (e.type === "mouseleave") {
      cancelHoverDebounce();
      if (!props.isContentHoverable) {
        isOpen.value = false;
        return;
      }
      debounceUnHover(() => {
        isOpen.value = false;
      });
    } else {
      cancelUnHoverDebounce();
      debounceHover(() => {
        isOpen.value = true;
      });
    }
  };
  useEvent(["mouseleave", "mouseenter"], onMouseHover, anchorRef);
  useEvent(["mouseleave", "mouseenter"], onMouseHover, contentRef);
};
const useAnchorSelector = (props) => {
  const anchorRef = ref();
  const document2 = useDocument();
  const isMounted = useIsMounted();
  const computedAnchorRef = computed({
    set(v) {
      anchorRef.value = unwrapEl(v);
    },
    get() {
      var _a2, _b, _c;
      isMounted.value;
      if (typeof props.anchor === "string") {
        return ((_a2 = document2.value) == null ? void 0 : _a2.querySelector(props.anchor)) ?? anchorRef.value;
      }
      if (typeof props.anchor === "object") {
        return props.anchor;
      }
      if (props.anchorSelector) {
        return ((_b = document2.value) == null ? void 0 : _b.querySelector(props.anchorSelector)) ?? anchorRef.value;
      } else if (props.innerAnchorSelector && anchorRef.value) {
        return ((_c = anchorRef.value) == null ? void 0 : _c.querySelector(props.innerAnchorSelector)) ?? anchorRef.value;
      }
      return anchorRef.value;
    }
  });
  return {
    anchorRef: computedAnchorRef
  };
};
const useCursorAnchor = (anchorRef, enabled) => {
  const position = reactive({ x: 0, y: 0 });
  useEvent(["mousemove", "mousedown", "mouseup"], (e) => {
    var _a2;
    if (!enabled.value) {
      return;
    }
    const { x, y } = ((_a2 = anchorRef.value) == null ? void 0 : _a2.getBoundingClientRect()) ?? { x: 0, y: 0 };
    position.x = e.clientX - x;
    position.y = e.clientY - y;
  }, anchorRef);
  return computed(() => {
    return {
      getBoundingClientRect() {
        var _a2;
        const { x, y } = ((_a2 = anchorRef.value) == null ? void 0 : _a2.getBoundingClientRect()) ?? { x: 0, y: 0 };
        const resX = position.x + x;
        const resY = position.y + y;
        return {
          width: 0,
          height: 0,
          x: resX,
          y: resY,
          top: resY,
          right: resX,
          bottom: resY,
          left: resX
        };
      },
      contextElement: anchorRef.value
    };
  });
};
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = (v) => ({
  x: v,
  y: v
});
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const flip$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides[0]], overflow[sides[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          var _overflowsData$;
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          const hasInitialMainAxisOverflow = ((_overflowsData$ = overflowsData[0]) == null ? void 0 : _overflowsData$.overflows[0]) > 0;
          if (!ignoreCrossAxisOverflow || hasInitialMainAxisOverflow) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$1 = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
const shift$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
const size$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply: apply2 = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply2({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement$1(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement$1(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement$1(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
const getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a, b) {
  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (_e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement$1(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const offset = offset$1;
const shift = shift$1;
const flip = flip$1;
const size = size$1;
const computePosition = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
function isComponentPublicInstance(target) {
  return target != null && typeof target === "object" && "$el" in target;
}
function unwrapElement(target) {
  if (isComponentPublicInstance(target)) {
    const element = target.$el;
    return isNode(element) && getNodeName(element) === "#comment" ? null : element;
  }
  return target;
}
function toValue(source) {
  return typeof source === "function" ? source() : unref(source);
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useFloating(reference, floating, options) {
  if (options === void 0) {
    options = {};
  }
  const whileElementsMountedOption = options.whileElementsMounted;
  const openOption = computed(() => {
    var _toValue;
    return (_toValue = toValue(options.open)) != null ? _toValue : true;
  });
  const middlewareOption = computed(() => toValue(options.middleware));
  const placementOption = computed(() => {
    var _toValue2;
    return (_toValue2 = toValue(options.placement)) != null ? _toValue2 : "bottom";
  });
  const strategyOption = computed(() => {
    var _toValue3;
    return (_toValue3 = toValue(options.strategy)) != null ? _toValue3 : "absolute";
  });
  const transformOption = computed(() => {
    var _toValue4;
    return (_toValue4 = toValue(options.transform)) != null ? _toValue4 : true;
  });
  const referenceElement = computed(() => unwrapElement(reference.value));
  const floatingElement = computed(() => unwrapElement(floating.value));
  const x = ref(0);
  const y = ref(0);
  const strategy = ref(strategyOption.value);
  const placement = ref(placementOption.value);
  const middlewareData = shallowRef({});
  const isPositioned = ref(false);
  const floatingStyles = computed(() => {
    const initialStyles = {
      position: strategy.value,
      left: "0",
      top: "0"
    };
    if (!floatingElement.value) {
      return initialStyles;
    }
    const xVal = roundByDPR(floatingElement.value, x.value);
    const yVal = roundByDPR(floatingElement.value, y.value);
    if (transformOption.value) {
      return {
        ...initialStyles,
        transform: "translate(" + xVal + "px, " + yVal + "px)",
        ...getDPR(floatingElement.value) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy.value,
      left: xVal + "px",
      top: yVal + "px"
    };
  });
  let whileElementsMountedCleanup;
  function update() {
    if (referenceElement.value == null || floatingElement.value == null) {
      return;
    }
    const open = openOption.value;
    computePosition(referenceElement.value, floatingElement.value, {
      middleware: middlewareOption.value,
      placement: placementOption.value,
      strategy: strategyOption.value
    }).then((position) => {
      x.value = position.x;
      y.value = position.y;
      strategy.value = position.strategy;
      placement.value = position.placement;
      middlewareData.value = position.middlewareData;
      isPositioned.value = open !== false;
    });
  }
  function cleanup() {
    if (typeof whileElementsMountedCleanup === "function") {
      whileElementsMountedCleanup();
      whileElementsMountedCleanup = void 0;
    }
  }
  function attach() {
    cleanup();
    if (whileElementsMountedOption === void 0) {
      update();
      return;
    }
    if (referenceElement.value != null && floatingElement.value != null) {
      whileElementsMountedCleanup = whileElementsMountedOption(referenceElement.value, floatingElement.value, update);
      return;
    }
  }
  function reset() {
    if (!openOption.value) {
      isPositioned.value = false;
    }
  }
  watch([middlewareOption, placementOption, strategyOption, openOption], update, {
    flush: "sync"
  });
  watch([referenceElement, floatingElement], attach, {
    flush: "sync"
  });
  watch(openOption, reset, {
    flush: "sync"
  });
  if (getCurrentScope()) {
    onScopeDispose(cleanup);
  }
  return {
    x: shallowReadonly(x),
    y: shallowReadonly(y),
    strategy: shallowReadonly(strategy),
    placement: shallowReadonly(placement),
    middlewareData: shallowReadonly(middlewareData),
    isPositioned: shallowReadonly(isPositioned),
    floatingStyles,
    update
  };
}
const useDropdown = (anchorComputed, floating, target, options) => {
  const placementComputed = computed(() => {
    const { position, align } = usePlacementAliases({ placement: options.value.placement });
    return `${position.value}-${align.value}`;
  });
  const offsetComputed = computed(() => {
    const dropdownOffset = options.value.offset;
    const result = { mainAxis: 0, crossAxis: 0 };
    if (Array.isArray(dropdownOffset)) {
      result.mainAxis = dropdownOffset[0];
      result.crossAxis = dropdownOffset[1];
    }
    if (typeof dropdownOffset === "number") {
      result.mainAxis = dropdownOffset;
    }
    return result;
  });
  const middlewareComputed = computed(() => {
    const { autoPlacement, stickToEdges, keepAnchorWidth, verticalScrollOnOverflow } = options.value;
    const result = [
      offset(offsetComputed.value)
    ];
    if (autoPlacement) {
      result.push(
        // boundary doesn't work with ssr (trying to access document)
        flip({
          boundary: target.value
        })
      );
    }
    if (stickToEdges) {
      result.push(
        shift()
      );
    }
    if (keepAnchorWidth || verticalScrollOnOverflow) {
      result.push(size({
        apply({ elements, availableHeight }) {
          if (keepAnchorWidth) {
            const reference = elements.reference;
            const availableWidth = reference.getBoundingClientRect().width;
            Object.assign(elements.floating.style, {
              // Don't set width here, because some plugin applies width 100% and it breaks layout
              maxWidth: `${availableWidth}px`,
              minWidth: `${availableWidth}px`
            });
          }
          if (verticalScrollOnOverflow) {
            Object.assign(elements.floating.style, {
              maxHeight: `${availableHeight}px`
            });
          }
        }
      }));
    }
    return result;
  });
  const { floatingStyles, isPositioned } = typeof document === "undefined" ? { floatingStyles: {}, isPositioned: ref(false) } : useFloating(anchorComputed, floating, {
    placement: placementComputed,
    whileElementsMounted: autoUpdate,
    middleware: middlewareComputed,
    transform: true
  });
  return {
    // Because floating ui by default set top and left to 0 before position calculated, dropdown jumps to the left top corner
    // If user wants to make focus on el as soon as Dropdown is opened, page will be scrolled on the left top corner
    floatingStyles: computed(() => {
      if (!isPositioned.value) {
        return {
          position: "fixed"
        };
      }
      return floatingStyles.value;
    }),
    isPositioned
  };
};
const checkIfElementChild = (parent, child) => {
  if (!child) {
    return false;
  }
  if (child instanceof Window) {
    return false;
  }
  if (child.parentElement === parent) {
    return true;
  }
  return parent.contains(child);
};
const safeArray = (a) => Array.isArray(a) ? a : [a];
const useFocusOutside = (elements, cb, options = {}) => {
  let previouslyClicked2 = false;
  if (options.onlyKeyboard) {
    useEvent("mousedown", (e) => {
      previouslyClicked2 = true;
      setTimeout(() => {
        previouslyClicked2 = false;
      }, 200);
    }, true);
  }
  useEvent("focus", (event) => {
    if (options.onlyKeyboard && previouslyClicked2) {
      return;
    }
    const focusTarget = event.target;
    if (event.target.shadowRoot) {
      return;
    }
    const isFocusInside = safeArray(elements).some((element) => {
      const el = unwrapEl(unref(element));
      return el && checkIfElementChild(el, focusTarget);
    });
    if (!isFocusInside) {
      cb(focusTarget);
    }
  }, true);
};
const useHTMLElementSelector = (key) => {
  return computed(() => {
    if (typeof (key == null ? void 0 : key.value) === "string") {
      return document == null ? void 0 : document.querySelector(key.value);
    }
    return unwrapEl(key == null ? void 0 : key.value);
  });
};
const _sfc_main$1B = /* @__PURE__ */ defineComponent({
  name: "VaDropdown",
  props: {
    ...usePlacementAliasesProps,
    ...createStatefulProps(true),
    modelValue: { type: Boolean, default: false },
    anchor: { type: [String, Object], default: void 0 },
    anchorSelector: { type: String, default: "" },
    innerAnchorSelector: { type: String, default: "" },
    trigger: {
      type: [String, Array],
      default: () => ["click", "space", "enter", "arrow-down", "arrow-up"]
    },
    disabled: { type: Boolean },
    readonly: { type: Boolean },
    closeOnClickOutside: { type: Boolean, default: true },
    closeOnFocusOutside: { type: Boolean, default: true },
    closeOnAnchorClick: { type: Boolean, default: true },
    closeOnContentClick: { type: Boolean, default: true },
    hoverOverTimeout: { type: [Number, String], default: 30 },
    hoverOutTimeout: { type: [Number, String], default: 200 },
    isContentHoverable: { type: Boolean, default: true },
    offset: { type: [Array, Number], default: 0 },
    keepAnchorWidth: { type: Boolean, default: false },
    verticalScrollOnOverflow: { type: Boolean, default: true },
    cursor: { type: [Boolean, Object], default: false },
    autoPlacement: { type: Boolean, default: true },
    stickToEdges: { type: Boolean, default: false },
    /** Viewport where dropdown will be rendered. Autoplacement will be calculated relative to `target` */
    target: { type: [String, Object], default: void 0 },
    /** Element where dropdown content will be rendered. */
    teleport: { type: [String, Object], default: void 0 },
    /** Not reactive */
    keyboardNavigation: { type: Boolean, default: true },
    ariaLabel: useTranslationProp("$t:toggleDropdown"),
    role: { type: String, default: "button" },
    contentClass: { type: String, default: "" }
  },
  emits: [...useStatefulEmits, "anchor-click", "anchor-right-click", "content-click", "click-outside", "focus-outside", "close", "open", "anchor-dblclick"],
  setup(props, { emit: emit2 }) {
    const { valueComputed } = useStateful(props, emit2, "modelValue");
    watch(valueComputed, (isOpened) => {
      if (isOpened) {
        emit2("open");
      } else {
        emit2("close");
      }
    });
    const isMounted = useIsMounted();
    const { anchorRef } = useAnchorSelector(props);
    const cursorAnchor = useCursorAnchor(anchorRef, computed(() => Boolean(props.cursor)));
    const floating = useHTMLElement("floating");
    const body = useHTMLElementSelector(ref("body"));
    const target = useHTMLElementSelector(computed(() => props.target));
    const teleport = useHTMLElementSelector(computed(() => props.teleport));
    const anchorClass = useBem("va-dropdown", () => pick(props, ["disabled"]));
    const teleportTarget = computed(() => {
      if (teleport.value) {
        return teleport.value;
      }
      if (target.value) {
        return target.value;
      }
      if (anchorRef.value) {
        const root = anchorRef.value.getRootNode();
        if (root instanceof ShadowRoot) {
          const el = [...root.children].find((c) => c.tagName !== "STYLE");
          if (el) {
            return el;
          }
        }
      }
      return body.value;
    });
    const showFloating = computed(() => isMounted.value && valueComputed.value);
    useNavigation(
      valueComputed,
      anchorRef,
      floating,
      props
    );
    const emitAndClose = (eventName, close, e) => {
      emit2(eventName, e);
      if (close) {
        valueComputed.value = false;
      }
    };
    useClickOutside([anchorRef, floating], () => {
      if (props.closeOnClickOutside && valueComputed.value) {
        emitAndClose("click-outside", props.closeOnClickOutside);
      }
    });
    useFocusOutside([floating], () => {
      if (props.closeOnFocusOutside && valueComputed.value) {
        emitAndClose("focus-outside", props.closeOnFocusOutside);
      }
    }, { onlyKeyboard: true });
    const anchorComputed = computed(() => {
      if (typeof props.cursor === "object") {
        return props.cursor;
      }
      return props.cursor ? cursorAnchor.value : anchorRef.value;
    });
    const { floatingStyles } = useDropdown(
      anchorComputed,
      floating,
      target,
      computed(() => ({
        placement: props.placement,
        offset: props.offset,
        autoPlacement: props.autoPlacement,
        stickToEdges: props.stickToEdges,
        keepAnchorWidth: props.keepAnchorWidth,
        verticalScrollOnOverflow: props.verticalScrollOnOverflow
      }))
    );
    const hide = () => {
      valueComputed.value = false;
    };
    const show = () => {
      valueComputed.value = true;
    };
    const {
      zIndex
    } = useZIndex(valueComputed);
    watch(valueComputed, (isOpened) => {
      if (!props.keyboardNavigation) {
        return;
      }
      if (isOpened) {
        nextTick(() => {
          const el = unwrapEl(floating.value);
          if (!el) {
            return;
          }
          focusFirstFocusableChild(el);
        });
      } else {
        if (!anchorRef.value) {
          return;
        }
        focusFirstFocusableChild(anchorRef.value);
      }
    });
    return {
      ...useTranslation(),
      ...useTeleported(),
      anchorRef,
      anchorClass,
      floating,
      floatingStyles,
      showFloating,
      teleportTarget,
      isMounted,
      valueComputed,
      hide,
      show,
      zIndex
    };
  },
  render() {
    const slotBind = {
      isOpened: this.valueComputed,
      hide: this.hide,
      show: this.show,
      toggle: () => this.valueComputed ? this.hide() : this.show(),
      getAnchorWidth: () => {
        var _a2;
        return ((_a2 = this.anchorRef) == null ? void 0 : _a2.offsetWidth) + "px";
      },
      getAnchorHeight: () => {
        var _a2;
        return ((_a2 = this.anchorRef) == null ? void 0 : _a2.offsetHeight) + "px";
      }
    };
    const floatingSlotNode = this.showFloating && renderSlotNode(this.$slots.default, slotBind, {
      ref: "floating",
      class: ["va-dropdown__content-wrapper", this.$props.contentClass],
      style: [this.floatingStyles, { zIndex: this.zIndex }],
      ...this.teleportedAttrs
    });
    const anchorSlotVNode = renderSlotNode(this.$slots.anchor, slotBind, {
      ref: "anchorRef",
      role: this.$props.role,
      class: ["va-dropdown", ...this.anchorClass.asArray.value],
      style: { position: "relative" },
      "aria-label": this.tp(this.$props.ariaLabel),
      "aria-disabled": this.$props.disabled,
      "aria-expanded": this.$props.role && this.$props.role !== "none" ? !!this.showFloating : void 0,
      ...this.teleportFromAttrs,
      ...this.$attrs
    });
    if (typeof this.$props.cursor === "object" && floatingSlotNode) {
      return h(
        Teleport,
        {
          to: this.teleportTarget,
          disabled: this.$props.disabled
        },
        [floatingSlotNode]
      );
    }
    if (!this.$props.anchorSelector && !anchorSlotVNode) {
      warn("VaDropdown: #anchor slot is missing");
      return;
    }
    if (this.showFloating && !floatingSlotNode) {
      warn("VaDropdown: default slot is missing");
      return;
    }
    return h(Fragment, {}, [
      anchorSlotVNode,
      floatingSlotNode && h(
        Teleport,
        {
          to: this.teleportTarget,
          disabled: this.$props.disabled
        },
        [floatingSlotNode]
      )
    ]);
  }
});
const VaDropdown = withConfigTransport$1(_sfc_main$1B);
const _sfc_main$1A = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaDropdownContent"
  },
  __name: "VaDropdownContent",
  props: {
    noPadding: { type: Boolean, default: false },
    background: { type: String, default: "background-secondary" },
    textColor: { type: String }
  },
  setup(__props) {
    const props = __props;
    const { getColor } = useColors();
    const { textColorComputed } = useTextColor(toRef(props, "background"));
    const computedStyle = computed(() => ({
      background: getColor(props.background, void 0, true),
      color: textColorComputed.value,
      padding: props.noPadding ? 0 : void 0
    }));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "va-dropdown__content",
        style: normalizeStyle(computedStyle.value),
        role: "listbox"
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 4);
    };
  }
});
const VaDropdownContent = withConfigTransport$1(_sfc_main$1A);
const getEvent = (event) => typeof event === "object" ? event.listen : event;
const getEmit = (event) => typeof event === "object" ? event.emit : event;
const useEmitProxy = (events) => {
  const createEmits2 = () => events.map(getEmit);
  const eventToListenerName = (event) => {
    const eventName = event.charAt(0).toUpperCase() + event.slice(1);
    return `on${eventName}`;
  };
  const createListeners2 = (emit2) => {
    return events.reduce((acc, key) => ({
      ...acc,
      [eventToListenerName(getEvent(key))]: (...args) => emit2(getEmit(key), ...args)
    }), {});
  };
  const createVOnListeners = (emit2) => {
    return events.reduce((acc, key) => ({
      ...acc,
      [getEvent(key)]: (...args) => emit2(getEmit(key), ...args)
    }), {});
  };
  return {
    createListeners: createListeners2,
    createVOnListeners,
    createEmits: createEmits2
  };
};
const { createEmits: createEmits$1, createVOnListeners: createListeners$1 } = useEmitProxy(["click"]);
const { createEmits: createMainButtonEmits, createVOnListeners: createMainButtonListeners } = useEmitProxy(
  [{ listen: "click", emit: "main-button-click" }]
);
const VaButtonProps = omit(extractComponentProps(VaButton), ["iconRight", "block"]);
const VaDropdownProps$3 = extractComponentProps(VaDropdown);
const _sfc_main$1z = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaButtonDropdown"
  },
  __name: "VaButtonDropdown",
  props: {
    ...useComponentPresetProp,
    ...VaButtonProps,
    ...VaDropdownProps$3,
    ...useStatefulProps,
    ...usePlacementAliasesProps,
    modelValue: { type: Boolean, default: false },
    stateful: { type: Boolean, default: true },
    icon: { type: String, default: "va-arrow-down" },
    openedIcon: { type: String, default: "va-arrow-up" },
    hideIcon: { type: Boolean, default: false },
    leftIcon: { type: Boolean, default: false },
    iconColor: { type: String, default: "" },
    disabled: { type: Boolean, default: false },
    disableButton: { type: Boolean, default: false },
    disableDropdown: { type: Boolean, default: false },
    offset: { type: [Number, Array], default: 2 },
    keepAnchorWidth: { type: Boolean, default: false },
    closeOnContentClick: { type: Boolean, default: true },
    split: { type: Boolean },
    splitTo: { type: String, default: "" },
    splitHref: { type: String, default: "" },
    loading: { type: Boolean, default: false },
    label: { type: String },
    ariaLabel: useTranslationProp("$t:toggleDropdown")
  },
  emits: ["update:modelValue", ...createEmits$1(), ...createMainButtonEmits()],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const { valueComputed } = useStateful(props, emit2);
    const computedIcon = computed(() => valueComputed.value ? props.openedIcon : props.icon);
    const slots = useSlots();
    const computedButtonIcons = computed(() => {
      if (props.hideIcon) {
        return {};
      }
      const propName = (props.label || slots.label) && !props.leftIcon ? "icon-right" : "icon";
      return { [propName]: computedIcon.value };
    });
    const buttonPropsFiltered = computed(() => {
      const ignoredProps = ["to", "href", "loading", "icon"];
      const presetProps = [
        "plain",
        "textOpacity",
        "backgroundOpacity",
        "hoverOpacity",
        "hoverBehavior",
        "hoverOpacity",
        "pressedOpacity",
        "pressedBehavior",
        "pressedOpacity"
      ];
      if (props.preset) {
        return Object.keys(omit(VaButtonProps, [...ignoredProps, ...presetProps]));
      }
      return Object.keys(omit(VaButtonProps, ignoredProps));
    });
    const buttonPropsComputed = computed(
      () => Object.entries(props).filter(([key, _]) => buttonPropsFiltered.value.includes(key)).reduce((acc, [key, value]) => {
        Object.assign(acc, { [key]: value });
        return acc;
      }, {})
    );
    const computedMainButtonProps = computed(() => ({
      to: props.splitTo,
      href: props.splitHref,
      loading: props.loading
    }));
    const hideDropdown = () => {
      valueComputed.value = false;
    };
    const vaDropdownProps = filterComponentProps(VaDropdownProps$3);
    const listeners = createListeners$1(emit2);
    const mainButtonListeners = createMainButtonListeners(emit2);
    const { t, tp } = useTranslation();
    __expose({
      hideDropdown
    });
    return (_ctx, _cache) => {
      return !_ctx.$props.split ? (openBlock(), createBlock(unref(VaDropdown), mergeProps$1({ key: 0 }, unref(vaDropdownProps), {
        modelValue: unref(valueComputed),
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(valueComputed) ? valueComputed.value = $event : null),
        disabled: _ctx.$props.disabled || _ctx.$props.disableDropdown,
        class: ["va-button-dropdown"]
      }), {
        anchor: withCtx(() => [
          createVNode(unref(VaButton), mergeProps$1({
            "aria-label": unref(tp)(_ctx.$props.ariaLabel)
          }, { ...computedButtonIcons.value, ...buttonPropsComputed.value }, toHandlers(unref(listeners))), {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "label", {}, () => [
                createTextVNode(toDisplayString(__props.label), 1)
              ])
            ]),
            _: 3
          }, 16, ["aria-label"])
        ]),
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "content", {}, () => [
            createVNode(unref(VaDropdownContent), null, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            })
          ])
        ]),
        _: 3
      }, 16, ["modelValue", "disabled"])) : (openBlock(), createBlock(unref(VaButtonGroup), mergeProps$1({ key: 1 }, buttonPropsComputed.value, { class: ["va-button-dropdown", "va-button-dropdown--split"] }), {
        default: withCtx(() => [
          !_ctx.$props.leftIcon ? (openBlock(), createBlock(unref(VaButton), mergeProps$1({
            key: 0,
            disabled: _ctx.$props.disabled || _ctx.$props.disableButton
          }, computedMainButtonProps.value, toHandlers(unref(mainButtonListeners))), {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "label", {}, () => [
                createTextVNode(toDisplayString(__props.label), 1)
              ])
            ]),
            _: 3
          }, 16, ["disabled"])) : createCommentVNode("", true),
          createVNode(unref(VaDropdown), mergeProps$1(unref(vaDropdownProps), {
            modelValue: unref(valueComputed),
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => isRef(valueComputed) ? valueComputed.value = $event : null),
            disabled: _ctx.$props.disabled || _ctx.$props.disableDropdown
          }), {
            anchor: withCtx(() => [
              createVNode(unref(VaButton), mergeProps$1({
                "aria-label": _ctx.$props.ariaLabel || unref(t)("toggleDropdown"),
                disabled: _ctx.$props.disabled || _ctx.$props.disableDropdown,
                icon: computedIcon.value,
                "icon-color": _ctx.$props.iconColor
              }, toHandlers(unref(listeners)), {
                onKeydown: withKeys(withModifiers(hideDropdown, ["prevent"]), ["esc"])
              }), null, 16, ["aria-label", "disabled", "icon", "icon-color", "onKeydown"])
            ]),
            default: withCtx(() => [
              createVNode(unref(VaDropdownContent), null, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default")
                ]),
                _: 3
              })
            ]),
            _: 3
          }, 16, ["modelValue", "disabled"]),
          _ctx.$props.leftIcon ? (openBlock(), createBlock(unref(VaButton), mergeProps$1({
            key: 1,
            disabled: _ctx.$props.disabled || _ctx.$props.disableButton
          }, computedMainButtonProps.value, toHandlers(unref(mainButtonListeners))), {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "label", {}, () => [
                createTextVNode(toDisplayString(__props.label), 1)
              ])
            ]),
            _: 3
          }, 16, ["disabled"])) : createCommentVNode("", true)
        ]),
        _: 3
      }, 16));
    };
  }
});
const VaButtonDropdown = withConfigTransport$1(_sfc_main$1z);
const getNestedValue = (option, propsArray) => {
  if (propsArray.length === 0) {
    return option;
  }
  const nestedItem = option[propsArray[0]];
  if (!isObject$2(nestedItem)) {
    if (propsArray.length === 1) {
      return nestedItem;
    }
    return void 0;
  }
  return getNestedValue(nestedItem, propsArray.slice(1));
};
const getValueByPath = (option, prop) => {
  if (prop in option) {
    return option[prop];
  }
  prop = prop.replace(/^\./, "");
  return getNestedValue(option, prop.split("."));
};
const getValueByKey = (option, prop) => {
  if (isNilValue(option) || typeof option !== "object" || Array.isArray(option)) {
    return void 0;
  }
  if (!prop) {
    return option;
  }
  if (typeof prop === "string") {
    return getValueByPath(option, prop);
  }
  if (typeof prop === "function") {
    return prop(option);
  }
  return option;
};
const useSelectableListProps = {
  options: { type: Array, default: () => [] },
  textBy: { type: [String, Function], default: "text" },
  valueBy: { type: [String, Function], default: "" },
  trackBy: { type: [String, Function], default: "" },
  disabledBy: { type: [String, Function], default: "disabled" },
  groupBy: { type: [String, Function], default: "group" }
};
function useSelectableList(props) {
  const tryResolveByValue = (value) => {
    const options = props.options;
    for (let i = 0; i < options.length; i++) {
      if (getValue2(options[i]) === value) {
        return options[i];
      }
    }
    return value;
  };
  const getOptionProperty = (option, prop) => {
    if (!isObject$2(option)) {
      return option;
    }
    return getValueByKey(option, prop);
  };
  const getTrackBy = (option) => {
    return props.trackBy ? getOptionProperty(option, props.trackBy) : getValue2(option);
  };
  const getDisabled = (option) => {
    if (!isObject$2(option)) {
      return false;
    }
    return getOptionProperty(option, props.disabledBy);
  };
  const getText = (option) => {
    const optionText = getOptionProperty(option, props.textBy);
    if (["number", "boolean"].includes(typeof optionText)) {
      return String(optionText);
    }
    return optionText;
  };
  const getGroupBy = (option) => {
    if (!isObject$2(option)) {
      return void 0;
    }
    return getOptionProperty(option, props.groupBy);
  };
  const getValue2 = (option) => getOptionProperty(option, props.valueBy);
  return {
    tryResolveByValue,
    getValue: getValue2,
    getText,
    getDisabled,
    getTrackBy,
    getGroupBy
  };
}
const VaButtonGroupProps = extractComponentProps(VaButtonGroup);
const _sfc_main$1y = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaButtonToggle"
  },
  __name: "VaButtonToggle",
  props: {
    ...VaButtonGroupProps,
    ...useComponentPresetProp,
    ...useSelectableListProps,
    modelValue: { type: [String, Number, Boolean, Object], default: "" },
    options: {
      type: Array,
      required: true
    },
    activeButtonTextColor: { type: String },
    toggleColor: { type: String, default: "" },
    textBy: { type: [String, Function], default: "label" },
    valueBy: { type: [String, Function], default: "value" }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const { getText, getTrackBy } = useSelectableList(props);
    const { getColor, shiftHSLAColor: shiftHSLAColor2 } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const isToggled = (value) => getTrackBy(value) === props.modelValue;
    const activeButtonColor = computed(() => {
      if (props.toggleColor) {
        return getColor(props.toggleColor);
      }
      return shiftHSLAColor2(colorComputed.value, { l: props.plain ? -16 : -6 });
    });
    const activeButtonBackgroundOpacityComputed = computed(() => {
      if (!props.preset || props.preset === "default") {
        return {};
      }
      return { backgroundOpacity: props.pressedOpacity };
    });
    const activeButtonPropsComputed = computed(() => ({
      color: activeButtonColor.value,
      textColor: props.activeButtonTextColor,
      ...activeButtonBackgroundOpacityComputed.value
    }));
    const getButtonProps = (option = {}) => {
      const iconsProps = { icon: option.icon, iconRight: option.iconRight };
      if (!isToggled(option)) {
        return iconsProps;
      }
      return {
        ...isToggled(option) && activeButtonPropsComputed.value,
        ...iconsProps
      };
    };
    const buttonGroupPropsComputed = filterComponentProps(VaButtonGroupProps);
    const changeValue = (value) => emit2("update:modelValue", getTrackBy(value));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaButtonGroup), mergeProps$1({ class: "va-button-toggle" }, unref(buttonGroupPropsComputed)), {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(__props.options, (option) => {
            return openBlock(), createBlock(unref(VaButton), mergeProps$1({
              key: unref(getTrackBy)(option),
              "aria-pressed": isToggled(option)
            }, getButtonProps(option), {
              onClick: ($event) => changeValue(option)
            }), {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(getText)(option)), 1)
              ]),
              _: 2
            }, 1040, ["aria-pressed", "onClick"]);
          }), 128))
        ]),
        _: 1
      }, 16);
    };
  }
});
const VaButtonToggle = withConfigTransport$1(_sfc_main$1y);
const _sfc_main$1x = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaCard"
  },
  __name: "VaCard",
  props: {
    ...useRouterLinkProps,
    ...useComponentPresetProp,
    tag: { type: String, default: "div" },
    square: { type: Boolean, default: false },
    outlined: { type: Boolean, default: false },
    bordered: { type: Boolean, default: true },
    disabled: { type: Boolean, default: false },
    href: { type: String, default: "" },
    target: { type: String, default: "" },
    stripe: { type: Boolean, default: false },
    stripeColor: { type: String, default: "" },
    gradient: { type: Boolean, default: false },
    textColor: { type: String },
    color: { type: String, default: "background-secondary" }
  },
  setup(__props) {
    const props = __props;
    const { getColor } = useColors();
    const { isLinkTag, tagComputed, hrefComputed } = useRouterLink(props);
    const { textColorComputed } = useTextColor(computed(() => getColor(props.color)));
    const stripeColorComputed = computed(() => getColor(props.stripeColor));
    const classComputed = useBem("va-card", () => ({
      ...pick(props, ["square", "outlined", "disabled", "stripe"]),
      noBorder: !props.bordered,
      link: isLinkTag.value
    }));
    const cardStyles = computed(() => {
      const background = props.gradient && props.color ? getGradientBackground(getColor(props.color)) : getColor(props.color);
      return {
        background,
        color: textColorComputed.value
      };
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(unref(tagComputed)), {
        class: normalizeClass(["va-card", unref(classComputed)]),
        style: normalizeStyle([cardStyles.value, `--va-stripe-color-computed: ${String(stripeColorComputed.value)}`]),
        href: unref(hrefComputed),
        target: __props.target,
        to: _ctx.to,
        replace: _ctx.replace,
        exact: _ctx.exact,
        "active-class": _ctx.activeClass,
        "exact-active-class": _ctx.exactActiveClass
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["class", "style", "href", "target", "to", "replace", "exact", "active-class", "exact-active-class"]);
    };
  }
});
const _hoisted_1$_ = { class: "va-card__content" };
const _sfc_main$1w = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaCardContent"
  },
  __name: "VaCardContent",
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$_, [
        renderSlot(_ctx.$slots, "default")
      ]);
    };
  }
});
const _sfc_main$1v = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaCardTitle"
  },
  __name: "VaCardTitle",
  props: {
    ...useComponentPresetProp,
    textColor: { type: String }
  },
  setup(__props) {
    const props = __props;
    const { getColor } = useColors();
    const titleStyles = computed(() => ({
      color: props.textColor ? getColor(props.textColor) : ""
    }));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "va-card-title va-card__title",
        style: normalizeStyle(titleStyles.value)
      }, [
        renderSlot(_ctx.$slots, "default", {}, void 0, true)
      ], 4);
    };
  }
});
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const VaCardTitleBase = /* @__PURE__ */ _export_sfc(_sfc_main$1v, [["__scopeId", "data-v-5cd66b25"]]);
const _sfc_main$1u = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaCardActions"
  },
  __name: "VaCardActions",
  props: {
    ...useAlignProps,
    ...useComponentPresetProp
  },
  setup(__props) {
    const props = __props;
    const { alignComputed } = useAlign(props);
    const classComputed = useBem("va-card__actions", () => ({
      ...pick(props, ["vertical"])
    }));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["va-card__actions", unref(classComputed)]),
        style: normalizeStyle(unref(alignComputed))
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 6);
    };
  }
});
const _sfc_main$1t = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaCardBlock"
  },
  __name: "VaCardBlock",
  props: {
    horizontal: {
      type: Boolean,
      default: false
    }
  },
  setup(__props) {
    const props = __props;
    const classComputed = computed(() => ({
      "va-card-block--horizontal": props.horizontal
    }));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["va-card-block", classComputed.value])
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 2);
    };
  }
});
const VaCardContent = withConfigTransport$1(_sfc_main$1w);
const VaCardTitle = withConfigTransport$1(VaCardTitleBase);
const VaCardActions = withConfigTransport$1(_sfc_main$1u);
const VaCardBlock = withConfigTransport$1(_sfc_main$1t);
const VaCard = withConfigTransport$1(_sfc_main$1x);
const useCarousel = (props, currentSlide) => {
  const goTo = (index) => {
    currentSlide.value = index;
  };
  const prev = () => {
    if (props.infinite) {
      if (currentSlide.value <= 0) {
        currentSlide.value = props.items.length - 1;
        return;
      }
    }
    currentSlide.value -= 1;
  };
  const next = () => {
    if (props.infinite) {
      if (currentSlide.value >= props.items.length - 1) {
        currentSlide.value = 0;
        return;
      }
    }
    currentSlide.value += 1;
  };
  const doShowDirectionButtons = computed(() => props.items.length > 1);
  const doShowPrevButton = computed(() => currentSlide.value > 0 || props.infinite);
  const doShowNextButton = computed(() => currentSlide.value < props.items.length - 1 || props.infinite);
  return {
    doShowPrevButton,
    doShowNextButton,
    doShowDirectionButtons,
    goTo,
    prev,
    next
  };
};
const useCarouselAnimation = (props, currentSlide) => {
  let animationInterval = -1;
  const start = () => {
    if (!props.autoscroll) {
      return;
    }
    clearInterval(animationInterval);
    animationInterval = setInterval(() => {
      currentSlide.value += 1;
      if (currentSlide.value >= props.items.length) {
        currentSlide.value = 0;
      }
    }, props.autoscrollInterval);
  };
  let pauseTimeout;
  const pause = () => {
    if (!props.autoscroll) {
      return;
    }
    clearInterval(animationInterval);
    pauseTimeout = setTimeout(() => {
      start();
      clearTimeout(pauseTimeout);
    }, props.autoscrollPauseDuration);
  };
  const stop = () => {
    clearInterval(animationInterval);
    clearTimeout(pauseTimeout);
  };
  onMounted(() => start());
  onBeforeUnmount(() => stop());
  const withPause = (fn) => {
    return (...args) => {
      pause();
      fn(...args);
    };
  };
  const slidesContainerStyle = ref({
    transition: void 0
  });
  const sliderToBeShown = ref(0);
  const computedSlidesStyle = computed(() => {
    if (props.effect === "fade") {
      return {
        ...slidesContainerStyle.value,
        transition: "none"
      };
    }
    if (props.vertical) {
      return {
        ...slidesContainerStyle.value,
        transform: `translateY(${sliderToBeShown.value * -100}%)`
      };
    }
    return {
      ...slidesContainerStyle.value,
      transform: `translateX(${sliderToBeShown.value * -100}%)`
    };
  });
  const animator = {
    isAnimating: false,
    speed: 0.3,
    order: [],
    move(from, to) {
      const last = props.items.length - 1;
      const firstAfterLast = props.items.length;
      if (to === 0 && from === last) {
        this.order.push({ to: firstAfterLast });
        this.order.push({ to: 0, animate: false });
      } else if (to === last && from === 0) {
        this.order.push({ to: firstAfterLast, animate: false });
        this.order.push({ to });
      } else {
        this.order.push({ to });
      }
      if (!this.isAnimating) {
        this.runAnimation();
      }
    },
    runAnimation() {
      this.isAnimating = true;
      const animation = this.order.shift();
      if (!animation) {
        this.isAnimating = false;
        return;
      }
      sliderToBeShown.value = animation == null ? void 0 : animation.to;
      if (animation.animate || animation.animate === void 0) {
        slidesContainerStyle.value.transition = `all ${this.speed}s linear`;
        setTimeout(() => {
          this.runAnimation();
        }, this.speed * 1e3);
      } else {
        slidesContainerStyle.value.transition = "none";
        setTimeout(() => {
          this.runAnimation();
        }, 16);
      }
    }
  };
  watch(currentSlide, (newValue, oldValue) => {
    animator.move(oldValue, newValue);
  });
  const slides = computed(() => {
    if (props.effect === "fade") {
      return [props.items[currentSlide.value]];
    }
    if (props.infinite || props.autoscroll) {
      return [...props.items, props.items[0]];
    }
    return props.items;
  });
  return {
    start,
    pause,
    stop,
    withPause,
    computedSlidesStyle,
    slides
  };
};
const useCarouselColor = () => {
  const { setHSLAColor: setHSLAColor2, getColor } = useColors();
  return {
    computedColor: computed(() => setHSLAColor2(getColor("background-element"), { a: 0.7 })),
    computedHoverColor: computed(() => setHSLAColor2(getColor("primary"), { a: 0.7 })),
    computedActiveColor: computed(() => getColor("primary"))
  };
};
const useNativeImgAttributesProps = {
  src: { type: String, required: true },
  alt: { type: String, default: "" },
  title: { type: String, default: "" },
  sizes: { type: String, default: "" },
  srcset: { type: String, default: "" },
  draggable: { type: Boolean, default: true },
  loading: {
    type: String
  },
  crossorigin: {
    type: String
  },
  decoding: {
    type: String
  },
  fetchpriority: {
    type: String,
    default: "auto"
  },
  referrerpolicy: {
    type: String
  }
};
const useNativeImgAttributes = (props) => {
  return computed(
    () => pick(props, ["src", "alt", "title", "sizes", "srcset", "loading", "referrerpolicy", "fetchpriority", "decoding", "crossorigin", "draggable"])
  );
};
const useIntersectionObserver = (cb, options = ref({}), target = ref([]), enabled = true) => {
  const observer = ref();
  const disconnectObserver = () => {
    var _a2;
    (_a2 = observer.value) == null ? void 0 : _a2.disconnect();
  };
  const observeTarget = (target2) => {
    var _a2;
    const disclosedTarget = unwrapEl(unref(target2));
    disclosedTarget && ((_a2 = observer.value) == null ? void 0 : _a2.observe(disclosedTarget));
  };
  const observeAll = (targets) => {
    targets.forEach(observeTarget);
  };
  const initObserver = () => {
    observer.value = new IntersectionObserver(cb, options.value);
  };
  const isIntersectionDisabled = computed(() => !enabled || !(typeof window !== "undefined" && "IntersectionObserver" in window));
  watch([target, options], ([newTarget]) => {
    if (isIntersectionDisabled.value) {
      return;
    }
    disconnectObserver();
    if (!newTarget) {
      return;
    }
    initObserver();
    Array.isArray(newTarget) ? observeAll(newTarget) : observeTarget(newTarget);
  }, { immediate: true });
  onBeforeUnmount(disconnectObserver);
  return { isIntersectionDisabled };
};
const _hoisted_1$Z = ["aria-busy"];
const _hoisted_2$t = {
  key: 0,
  class: "va-image__overlay"
};
const _hoisted_3$l = {
  key: 1,
  class: "va-image__error"
};
const _hoisted_4$c = {
  key: 2,
  class: "va-image__loader"
};
const _hoisted_5$8 = {
  key: 3,
  class: "va-image__placeholder"
};
const _hoisted_6$3 = ["src"];
const VaFallbackProps = extractComponentProps(VaFallback);
const _sfc_main$1s = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaImage"
  },
  __name: "VaImage",
  props: {
    ...useComponentPresetProp,
    ...useNativeImgAttributesProps,
    ...VaFallbackProps,
    ratio: {
      type: [Number, String],
      default: "auto",
      validator: (v) => {
        if (typeof v === "number") {
          return v > 0;
        }
        return v === "auto";
      }
    },
    fit: {
      type: String,
      default: "cover"
    },
    maxWidth: {
      type: [Number, String],
      default: 0,
      validator: (v) => Number(v) >= 0
    },
    lazy: { type: Boolean, default: false },
    placeholderSrc: { type: String, default: "" }
  },
  emits: ["loaded", "error", "fallback"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const root = ref();
    const image = ref();
    const renderedImage = ref();
    const currentImage = computed(() => renderedImage.value || props.src);
    const imgWidth = ref(1);
    const imgHeight = ref(1);
    const isLoading = ref(false);
    const isError = ref(false);
    const handleLoad = () => {
      var _a2;
      isLoading.value = true;
      if (!isReadyForLoad.value) {
        return;
      }
      isLoading.value = false;
      renderedImage.value = (_a2 = image.value) == null ? void 0 : _a2.currentSrc;
      getImgSizes();
      emit2("loaded", currentImage.value);
    };
    const handleError2 = (err) => {
      isError.value = true;
      isLoading.value = false;
      emit2("error", err || currentImage.value);
    };
    const isIntersecting = ref(false);
    const handleIntersection = (entries, observer) => {
      entries.forEach((entry) => {
        if (!entry.isIntersecting) {
          return;
        }
        isIntersecting.value = true;
        init();
        observer.disconnect();
      });
    };
    const { isIntersectionDisabled } = useIntersectionObserver(handleIntersection, void 0, root, props.lazy);
    const isReadyForLoad = computed(() => isIntersectionDisabled.value || isIntersecting.value);
    const isMounted = useIsMounted();
    const isReadyForRender = computed(() => !props.lazy || props.lazy && isMounted.value && isReadyForLoad.value);
    const init = () => {
      if (!props.src || isLoading.value && isIntersectionDisabled.value || !isReadyForLoad.value) {
        return;
      }
      isLoading.value = true;
      isError.value = false;
      nextTick(() => {
        var _a2;
        if (!((_a2 = image.value) == null ? void 0 : _a2.complete)) {
          return;
        }
        if (!image.value.naturalWidth) {
          handleError2();
          return;
        }
        handleLoad();
      });
    };
    let timer;
    const getImgSizes = () => {
      clearTimeout(timer);
      if (isLoading.value) {
        timer = window.setTimeout(getImgSizes, 100);
      }
      const { naturalHeight, naturalWidth } = image.value || {};
      if (naturalHeight && naturalWidth) {
        imgWidth.value = naturalHeight;
        imgHeight.value = naturalWidth;
      }
    };
    onBeforeMount(init);
    onBeforeUnmount(() => clearTimeout(timer));
    watch(() => props.src, init);
    const slots = useSlots();
    const isPlaceholderPassed = computed(() => {
      var _a2;
      return ((_a2 = slots == null ? void 0 : slots.placeholder) == null ? void 0 : _a2.call(slots)) || props.placeholderSrc;
    });
    const isLoaderShown = computed(() => {
      var _a2;
      return isLoading.value && !((_a2 = slots == null ? void 0 : slots.loader) == null ? void 0 : _a2.call(slots));
    });
    const isErrorShown = computed(() => {
      var _a2;
      return isError.value && (!((_a2 = slots == null ? void 0 : slots.error) == null ? void 0 : _a2.call(slots)) && !isAnyFallbackPassed.value);
    });
    const isPlaceholderShown = computed(() => (isLoaderShown.value || isErrorShown.value) && isPlaceholderPassed.value);
    const isSuccessfullyLoaded = computed(() => !(isLoading.value || isError.value));
    const imgAttributesComputed = useNativeImgAttributes(props);
    const aspectRationAttributesComputed = computed(() => ({
      ...pick(props, ["ratio", "maxWidth"]),
      contentWidth: imgWidth.value,
      contentHeight: imgHeight.value
    }));
    const fallbackProps = filterComponentProps(VaFallbackProps);
    const checkObjectNonEmptyValues = (obj) => !!Object.values(obj || {}).filter((prop) => prop).length;
    const hasFallbackGlobalConfig = computed(() => {
      var _a2, _b, _c, _d;
      return checkObjectNonEmptyValues((_d = (_c = (_b = (_a2 = useGlobalConfig()) == null ? void 0 : _a2.globalConfig) == null ? void 0 : _b.value) == null ? void 0 : _c.components) == null ? void 0 : _d.VaFallback);
    });
    const isAnyFallbackPassed = computed(() => checkObjectNonEmptyValues(fallbackProps.value) || hasFallbackGlobalConfig.value);
    const fitComputed = computed(() => props.fit);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaAspectRatio), mergeProps$1({
        ref_key: "root",
        ref: root,
        class: "va-image"
      }, aspectRationAttributesComputed.value, {
        style: `--va-fit-computed: ${String(fitComputed.value)}`
      }), {
        default: withCtx(() => [
          withDirectives(createBaseVNode("picture", {
            class: "va-image__content",
            "aria-busy": isLoading.value
          }, [
            _ctx.$slots.sources ? renderSlot(_ctx.$slots, "sources", { key: 0 }) : createCommentVNode("", true),
            isReadyForRender.value ? (openBlock(), createElementBlock("img", mergeProps$1({
              key: 1,
              ref_key: "image",
              ref: image
            }, unref(imgAttributesComputed), {
              onError: handleError2,
              onLoad: handleLoad
            }), null, 16)) : createCommentVNode("", true)
          ], 8, _hoisted_1$Z), [
            [vShow, isSuccessfullyLoaded.value]
          ]),
          _ctx.$slots.default && isSuccessfullyLoaded.value ? (openBlock(), createElementBlock("div", _hoisted_2$t, [
            renderSlot(_ctx.$slots, "default")
          ])) : createCommentVNode("", true),
          isError.value && (_ctx.$slots.error || isAnyFallbackPassed.value) ? (openBlock(), createElementBlock("div", _hoisted_3$l, [
            renderSlot(_ctx.$slots, "error", {}, () => [
              createVNode(unref(VaFallback), mergeProps$1(unref(fallbackProps), {
                onFallback: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("fallback"))
              }), null, 16)
            ])
          ])) : createCommentVNode("", true),
          isLoading.value && _ctx.$slots.loader ? (openBlock(), createElementBlock("div", _hoisted_4$c, [
            renderSlot(_ctx.$slots, "loader")
          ])) : createCommentVNode("", true),
          isPlaceholderShown.value ? (openBlock(), createElementBlock("div", _hoisted_5$8, [
            renderSlot(_ctx.$slots, "placeholder", {}, () => [
              _ctx.$props.placeholderSrc ? (openBlock(), createElementBlock("img", {
                key: 0,
                src: _ctx.$props.placeholderSrc,
                alt: ""
              }, null, 8, _hoisted_6$3)) : createCommentVNode("", true)
            ])
          ])) : createCommentVNode("", true)
        ]),
        _: 3
      }, 16, ["style"]);
    };
  }
});
const VaImage = withConfigTransport$1(_sfc_main$1s);
const _sfc_main$1r = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaHover"
  },
  __name: "VaHover",
  props: {
    ...createStatefulProps(true),
    ...useComponentPresetProp,
    disabled: { type: Boolean, default: false },
    modelValue: { type: Boolean, default: false }
  },
  emits: [...useStatefulEmits],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const { valueComputed } = useStateful(props, emit2);
    const onMouseEnter = () => {
      if (!props.disabled) {
        valueComputed.value = true;
      }
    };
    const onMouseLeave = () => {
      if (!props.disabled) {
        valueComputed.value = false;
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "va-hover",
        onMouseenter: onMouseEnter,
        onMouseleave: onMouseLeave
      }, [
        renderSlot(_ctx.$slots, "default", normalizeProps$1(guardReactiveProps({ hover: unref(valueComputed) })))
      ], 32);
    };
  }
});
const VaHover = withConfigTransport$1(_sfc_main$1r);
const mouseEvents = ["mousedown", "mousemove"];
const touchEvents = ["touchstart", "touchmove"];
const commonAllowedDirections = {
  vertical: ["", "all", "vertical"],
  horizontal: ["", "all", "horizontal"]
};
const verticalSpecificAllowedDirections = [...commonAllowedDirections.vertical, "up", "down"];
const horizontalSpecificAllowedDirections = [...commonAllowedDirections.horizontal, "left", "right"];
const useSwipeProps = {
  swipable: { type: Boolean, default: false },
  swipeDistance: { type: Number, default: 75 },
  swipeDirection: { type: String, default: "all" }
};
const useSwipe = (props, container, cb) => {
  const swipeStarted = ref(false);
  const swipePath = reactive({
    start: { x: 0, y: 0 },
    end: { x: 0, y: 0 }
  });
  const swipeDuration = reactive({
    start: 0,
    end: 0
  });
  const setState = (e, type) => {
    let event;
    if (mouseEvents.includes(e.type)) {
      event = e;
    }
    if (touchEvents.includes(e.type)) {
      const touchEvent = e;
      event = touchEvent.changedTouches[touchEvent.changedTouches.length - 1];
    }
    if (!event) {
      return;
    }
    swipePath[type].x = event.pageX;
    swipePath[type].y = event.pageY;
    swipeDuration[type] = (/* @__PURE__ */ new Date()).getTime();
  };
  const onSwipeStart = (e) => {
    if (!props.swipable || swipeStarted.value) {
      return;
    }
    swipeStarted.value = true;
    setState(e, "start");
  };
  const onSwipeMove = (e) => {
    if (!swipeStarted.value) {
      return;
    }
    setState(e, "end");
  };
  const resetSwipe = () => {
    ["start", "end"].forEach((type) => {
      swipePath[type].x = 0;
      swipePath[type].y = 0;
      swipeDuration[type] = 0;
    });
    swipeStarted.value = false;
  };
  const isSwipeAllowed = reactive({
    vertical: false,
    horizontal: false
  });
  watchEffect(() => {
    isSwipeAllowed.horizontal = horizontalSpecificAllowedDirections.includes(props.swipeDirection);
    isSwipeAllowed.vertical = verticalSpecificAllowedDirections.includes(props.swipeDirection);
  });
  const calcDistance = (axis) => {
    return isSwipeAllowed[axis === "x" ? "horizontal" : "vertical"] && swipePath.start[axis] && swipePath.end[axis] ? Math.trunc(swipePath.start[axis] - swipePath.end[axis]) : 0;
  };
  const getAcceptableValue = (direction, result) => {
    return result === props.swipeDirection || commonAllowedDirections[direction].includes(props.swipeDirection) ? result : "";
  };
  const swipeState = reactive({ direction: "", duration: 0 });
  watch(swipePath, () => {
    const xDistance = calcDistance("x");
    const yDistance = calcDistance("y");
    if ((xDistance || yDistance) && [xDistance, yDistance].some((el) => Math.abs(el) >= props.swipeDistance)) {
      if (Math.abs(xDistance) >= Math.abs(yDistance) && isSwipeAllowed.horizontal) {
        const result = xDistance > 0 ? "left" : "right";
        swipeState.direction = getAcceptableValue("horizontal", result);
      } else if (Math.abs(xDistance) < Math.abs(yDistance) && isSwipeAllowed.vertical) {
        const result = yDistance > 0 ? "down" : "up";
        swipeState.direction = getAcceptableValue("vertical", result);
      }
      swipeState.duration = swipeDuration.end - swipeDuration.start;
      resetSwipe();
    }
  }, { deep: true });
  watch(swipeState, () => cb(swipeState), { deep: true });
  if (props.swipable) {
    useEvent(["touchstart", "mousedown"], onSwipeStart, container);
    useEvent(["touchmove", "mousemove"], onSwipeMove, container);
    useEvent(["touchcancel", "mouseup", "touchend", "mouseleave"], resetSwipe, container);
  }
  return { swipeState };
};
const _hoisted_1$Y = ["aria-label"];
const _hoisted_2$s = {
  key: 1,
  class: "va-carousel__indicators"
};
const _hoisted_3$k = { class: "va-carousel__content" };
const _hoisted_4$b = ["aria-hidden", "aria-current", "aria-label"];
const VaImageProps = extractComponentProps(VaImage, ["src", "alt"]);
const _sfc_main$1q = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaCarousel"
  },
  __name: "VaCarousel",
  props: {
    ...useSwipeProps,
    ...useStatefulProps,
    ...useComponentPresetProp,
    ...VaImageProps,
    stateful: { type: Boolean, default: true },
    modelValue: { type: Number, default: 0 },
    items: { type: Array, required: true },
    // Animations
    autoscroll: { type: Boolean, default: false },
    autoscrollInterval: { type: [Number, String], default: 5e3 },
    autoscrollPauseDuration: { type: [Number, String], default: 2e3 },
    infinite: { type: Boolean, default: true },
    fadeKeyframe: { type: String, default: "va-carousel-fade-appear 1s" },
    // Visual
    arrows: { type: Boolean, default: true },
    indicators: { type: Boolean, default: true },
    indicatorTrigger: {
      type: String,
      default: "click",
      validator: (value) => ["click", "hover", "none"].includes(value)
    },
    vertical: { type: Boolean, default: false },
    height: { type: String, default: "300px" },
    effect: {
      type: String,
      default: "transition",
      validator: (value) => ["fade", "transition"].includes(value)
    },
    color: { type: String, default: "primary" },
    ratio: { type: [Number, String] },
    ariaLabel: useTranslationProp("$t:carousel"),
    ariaPreviousLabel: useTranslationProp("$t:goPreviousSlide"),
    ariaNextLabel: useTranslationProp("$t:goNextSlide"),
    ariaGoToSlideLabel: useTranslationProp("$t:goSlide"),
    ariaSlideOfLabel: useTranslationProp("$t:slideOf")
  },
  emits: [...useStatefulEmits],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const { valueComputed: currentSlide } = useStateful(props, emit2, "modelValue");
    const autoscrollIntervalComputed = useNumericProp("autoscrollInterval");
    const autoscrollPauseDurationComputed = useNumericProp("autoscrollPauseDuration");
    const ratioComputed = useNumericProp("ratio");
    const {
      goTo,
      next,
      prev,
      doShowNextButton,
      doShowPrevButton,
      doShowDirectionButtons
    } = useCarousel(props, currentSlide);
    const { withPause, computedSlidesStyle, slides } = useCarouselAnimation({
      items: props.items,
      autoscrollInterval: autoscrollIntervalComputed.value,
      autoscrollPauseDuration: autoscrollPauseDurationComputed.value,
      autoscroll: props.autoscroll,
      infinite: props.infinite,
      effect: props.effect,
      vertical: props.vertical,
      fadeKeyframe: props.fadeKeyframe
    }, currentSlide);
    const isObjectSlides = computed(() => {
      return props.items.length && props.items.every((el) => !!el && typeof el === "object" && !!(el == null ? void 0 : el.src));
    });
    const isCurrentSlide = (index) => index === currentSlide.value;
    const slideStyleComputed = computed(() => ({
      animation: props.effect === "fade" ? "fadeKeyframe" : void 0
    }));
    const slidesContainer = shallowRef();
    const onSwipe = (state) => {
      switch (state.direction) {
        case "right":
        case "up":
          doShowPrevButton.value && prev();
          break;
        case "left":
        case "down":
          doShowNextButton.value && next();
      }
    };
    useSwipe(props, slidesContainer, onSwipe);
    const getIndicatorEvents = (index) => {
      if (props.indicatorTrigger === "hover") {
        return { onmouseover: () => goTo(index) };
      }
      if (props.indicatorTrigger === "click") {
        return { onclick: () => goTo(index) };
      }
      return {};
    };
    const { tp } = useTranslation();
    const {
      computedActiveColor,
      computedColor,
      computedHoverColor
    } = useCarouselColor();
    const vaImageProps = filterComponentProps(VaImageProps);
    const goToWithPause = withPause(goTo);
    const prevWithPause = withPause(prev);
    const nextWithPause = withPause(next);
    __expose({
      currentSlide,
      goTo,
      next,
      prev,
      goToWithPause,
      prevWithPause,
      nextWithPause
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["va-carousel", {
          "va-carousel--vertical": _ctx.$props.vertical,
          [`va-carousel--${_ctx.$props.effect}`]: true
        }]),
        style: normalizeStyle({ height: unref(ratioComputed) ? "auto" : __props.height }),
        role: "region",
        "aria-label": unref(tp)(_ctx.$props.ariaLabel)
      }, [
        _ctx.$props.arrows && unref(doShowDirectionButtons) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          unref(doShowPrevButton) ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "va-carousel__arrow va-carousel__arrow--left",
            onClick: _cache[0] || (_cache[0] = //@ts-ignore
            (...args) => unref(prevWithPause) && unref(prevWithPause)(...args)),
            onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers(
              //@ts-ignore
              (...args) => unref(prevWithPause) && unref(prevWithPause)(...args),
              ["stop"]
            ), ["enter"]))
          }, [
            renderSlot(_ctx.$slots, "prev-arrow", {}, () => [
              createVNode(unref(VaHover), { stateful: "" }, {
                default: withCtx(({ hover }) => [
                  createVNode(unref(VaButton), {
                    color: hover ? unref(computedHoverColor) : unref(computedColor),
                    icon: __props.vertical ? "va-arrow-up" : "va-arrow-left",
                    "aria-label": unref(tp)(_ctx.$props.ariaPreviousLabel)
                  }, null, 8, ["color", "icon", "aria-label"])
                ]),
                _: 1
              })
            ])
          ], 32)) : createCommentVNode("", true),
          unref(doShowNextButton) ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: "va-carousel__arrow va-carousel__arrow--right",
            onClick: _cache[2] || (_cache[2] = //@ts-ignore
            (...args) => unref(nextWithPause) && unref(nextWithPause)(...args)),
            onKeydown: _cache[3] || (_cache[3] = withKeys(withModifiers(
              //@ts-ignore
              (...args) => unref(nextWithPause) && unref(nextWithPause)(...args),
              ["stop"]
            ), ["enter"]))
          }, [
            renderSlot(_ctx.$slots, "next-arrow", {}, () => [
              createVNode(unref(VaHover), { stateful: "" }, {
                default: withCtx(({ hover }) => [
                  createVNode(unref(VaButton), {
                    color: hover ? unref(computedHoverColor) : unref(computedColor),
                    icon: __props.vertical ? "va-arrow-down" : "va-arrow-right",
                    "aria-label": unref(tp)(_ctx.$props.ariaNextLabel)
                  }, null, 8, ["color", "icon", "aria-label"])
                ]),
                _: 1
              })
            ])
          ], 32)) : createCommentVNode("", true)
        ], 64)) : createCommentVNode("", true),
        _ctx.$props.indicators ? (openBlock(), createElementBlock("div", _hoisted_2$s, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.items, (item, index) => {
            return openBlock(), createElementBlock("div", mergeProps$1({
              class: ["va-carousel__indicator", { "va-carousel__indicator--active": isCurrentSlide(index) }],
              key: index
            }, getIndicatorEvents(index)), [
              renderSlot(_ctx.$slots, "indicator", normalizeProps$1(guardReactiveProps({ item, index, goTo: unref(goToWithPause), isActive: isCurrentSlide(index) })), () => [
                createVNode(unref(VaHover), { stateful: "" }, {
                  default: withCtx(({ hover }) => [
                    createVNode(unref(VaButton), {
                      "aria-label": unref(tp)(_ctx.$props.ariaGoToSlideLabel, { index: index + 1 }),
                      round: "",
                      color: isCurrentSlide(index) ? unref(computedActiveColor) : hover ? unref(computedHoverColor) : unref(computedColor)
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(index + 1), 1)
                      ]),
                      _: 2
                    }, 1032, ["aria-label", "color"])
                  ]),
                  _: 2
                }, 1024)
              ])
            ], 16);
          }), 128))
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_3$k, [
          createBaseVNode("div", {
            ref_key: "slidesContainer",
            ref: slidesContainer,
            class: "va-carousel__slides",
            style: normalizeStyle(unref(computedSlidesStyle)),
            role: "list"
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(slides), (item, index) => {
              return openBlock(), createElementBlock("div", {
                key: item,
                role: "listitem",
                class: "va-carousel__slide",
                style: normalizeStyle(slideStyleComputed.value),
                "aria-hidden": !isCurrentSlide(index),
                "aria-current": isCurrentSlide(index),
                "aria-label": unref(tp)(_ctx.$props.ariaSlideOfLabel, { index: index + 1, length: unref(slides).length })
              }, [
                renderSlot(_ctx.$slots, "default", normalizeProps$1(guardReactiveProps({ item, index, goTo: unref(goToWithPause), isActive: isCurrentSlide(index) })), () => [
                  createVNode(unref(VaImage), mergeProps$1(unref(vaImageProps), {
                    src: isObjectSlides.value ? item.src : item,
                    alt: isObjectSlides.value ? item.alt : "",
                    draggable: false
                  }), null, 16, ["src", "alt"])
                ])
              ], 12, _hoisted_4$b);
            }), 128))
          ], 4)
        ])
      ], 14, _hoisted_1$Y);
    };
  }
});
const VaCarousel = withConfigTransport$1(_sfc_main$1q);
const useSelectableProps$1 = {
  ...useStatefulProps,
  ...useLoadingProps,
  ...useValidationProps,
  arrayValue: { type: [String, Boolean, Object, Number], default: null },
  label: { type: String, default: "" },
  leftLabel: { type: Boolean, default: false },
  trueValue: { type: null, default: true },
  falseValue: { type: null, default: false },
  indeterminate: { type: Boolean, default: false },
  indeterminateValue: { type: null, default: null },
  disabled: { type: Boolean, default: false },
  readonly: { type: Boolean, default: false }
};
const useSelectableEmits = [...useValidationEmits, "update:modelValue", "focus", "blur"];
const checkDuplicates = (props) => {
  const values = [props.falseValue, props.trueValue];
  if (props.indeterminate) {
    values.push(props.indeterminateValue);
  }
  const hasDuplicates = new Set(values).size !== values.length;
  if (hasDuplicates) {
    throw new Error("falseValue, trueValue, indeterminateValue props should have strictly different values, which is not the case.");
  }
};
const useSelectable = (props, emit2, { input, label, container }) => {
  checkDuplicates(props);
  const reset = () => withoutValidation(() => {
    emit2("update:modelValue", false);
    resetValidation();
  });
  const focus = () => {
    var _a2;
    (_a2 = unwrapEl(input.value)) == null ? void 0 : _a2.focus();
  };
  const { valueComputed } = useStateful(props, emit2);
  const {
    computedError,
    computedErrorMessages,
    validationAriaAttributes,
    listeners: validationListeners,
    withoutValidation,
    resetValidation,
    isDirty: isDirty2,
    isTouched,
    isError,
    isLoading,
    isValid
  } = useValidation(props, emit2, { reset, focus, value: valueComputed });
  const { isFocused } = useFocus();
  const onBlur = (event) => {
    emit2("blur", event);
    isFocused.value = false;
    validationListeners.onBlur();
  };
  const onFocus = (event) => {
    isFocused.value = true;
    emit2("focus", event);
  };
  const isIndeterminate = computed(() => props.indeterminate && valueComputed.value === props.indeterminateValue);
  const modelIsArray = computed(() => props.arrayValue !== void 0 && props.arrayValue !== null);
  const isChecked = computed(() => {
    var _a2;
    if (modelIsArray.value) {
      return (_a2 = props.modelValue) == null ? void 0 : _a2.includes(props.arrayValue);
    }
    return valueComputed.value === props.trueValue;
  });
  const toggleSelection = () => {
    if (props.readonly || props.disabled || props.loading) {
      return;
    }
    if (modelIsArray.value) {
      if (!props.modelValue) {
        emit2("update:modelValue", [props.arrayValue]);
      } else if (!Array.isArray(props.modelValue)) {
        emit2("update:modelValue", props.modelValue === props.arrayValue ? [] : [props.modelValue, props.arrayValue]);
      } else if (props.modelValue.includes(props.arrayValue)) {
        emit2("update:modelValue", props.modelValue.filter((option) => option !== props.arrayValue));
      } else {
        emit2("update:modelValue", props.modelValue.concat(props.arrayValue));
      }
      return;
    }
    if (props.indeterminate) {
      if (isIndeterminate.value) {
        valueComputed.value = props.trueValue;
      } else if (isChecked.value) {
        valueComputed.value = props.falseValue;
      } else {
        valueComputed.value = props.indeterminateValue;
      }
      return;
    }
    if (isChecked.value) {
      valueComputed.value = props.falseValue;
    } else {
      valueComputed.value = props.trueValue;
    }
  };
  return {
    isDirty: isDirty2,
    isTouched,
    isError,
    isLoading,
    isValid,
    isChecked,
    isIndeterminate,
    onBlur,
    onFocus,
    toggleSelection,
    reset,
    focus,
    computedError,
    computedErrorMessages,
    validationAriaAttributes
  };
};
var _a;
function useKeyboardOnlyFocus() {
  const hasKeyboardFocus = ref(false);
  let previouslyClicked2 = false;
  const keyboardFocusListeners = {
    mousedown: () => {
      previouslyClicked2 = true;
    },
    focus: () => {
      if (!previouslyClicked2) {
        hasKeyboardFocus.value = true;
      }
      previouslyClicked2 = false;
    },
    blur: () => {
      hasKeyboardFocus.value = false;
      previouslyClicked2 = false;
    }
  };
  return {
    hasKeyboardFocus,
    keyboardFocusListeners
  };
}
let previouslyClicked = false;
(_a = getWindow$1()) == null ? void 0 : _a.addEventListener("mousedown", () => {
  previouslyClicked = true;
  setTimeout(() => {
    previouslyClicked = false;
  }, 300);
});
function useKeyboardOnlyFocusGlobal() {
  const hasKeyboardFocus = ref(false);
  const keyboardFocusListeners = {
    focus: () => {
      if (!previouslyClicked) {
        hasKeyboardFocus.value = true;
      }
    },
    blur: () => {
      hasKeyboardFocus.value = false;
    }
  };
  return {
    hasKeyboardFocus,
    keyboardFocusListeners
  };
}
const _hoisted_1$X = ["id", "indeterminate", "value", "checked"];
const _hoisted_2$r = ["for"];
const VaCheckboxValueType = [Boolean, Array, String, Object];
const _sfc_main$1p = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaCheckbox"
  },
  __name: "VaCheckbox",
  props: {
    ...useSelectableProps$1,
    ...useComponentPresetProp,
    modelValue: { type: VaCheckboxValueType, default: false },
    color: { type: String, default: "primary" },
    checkedIcon: { type: String, default: "va-check" },
    indeterminate: { type: Boolean, default: false },
    indeterminateValue: { type: VaCheckboxValueType, default: null },
    indeterminateIcon: { type: String, default: "remove" },
    id: { type: String, default: "" },
    name: { type: String, default: "" },
    ariaLabel: { type: String, default: void 0 },
    vertical: { type: Boolean, default: false }
  },
  emits: useSelectableEmits,
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const elements = {
      container: shallowRef(),
      input: shallowRef(),
      label: shallowRef()
    };
    const {
      isChecked,
      computedError,
      isIndeterminate,
      computedErrorMessages,
      validationAriaAttributes,
      toggleSelection,
      onBlur,
      onFocus,
      isDirty: isDirty2,
      isTouched,
      isError,
      isLoading,
      isValid
    } = useSelectable(props, emit2, elements);
    const { getColor } = useColors();
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const { textColorComputed } = useTextColor(computed(() => getColor(props.color)));
    const isActive = computed(() => isChecked.value || isIndeterminate.value);
    const computedClass = computed(() => ({
      "va-checkbox--selected": isChecked.value,
      "va-checkbox--readonly": props.readonly,
      "va-checkbox--disabled": props.disabled,
      "va-checkbox--indeterminate": props.indeterminate,
      "va-checkbox--error": computedError.value,
      "va-checkbox--left-label": props.leftLabel,
      "va-checkbox--on-keyboard-focus": hasKeyboardFocus.value
    }));
    const getPaddingStyle = () => {
      switch (true) {
        case !props.label:
          return "";
        case props.vertical:
          return "var(--va-checkbox-vertical-padding)";
        case Boolean(props.arrayValue):
          return "var(--va-checkbox-horizontal-padding)";
        case props.leftLabel:
          return "var(--va-checkbox-right-padding)";
        default:
          return "var(--va-checkbox-left-padding)";
      }
    };
    const labelStyle = computed(() => {
      return {
        color: computedError.value ? getColor("danger") : props.success ? getColor("success") : "",
        padding: getPaddingStyle()
      };
    });
    const inputStyle = computed(() => {
      const style = {
        background: isActive.value ? getColor(props.color) : "",
        borderColor: isActive.value ? getColor(props.color) : ""
      };
      if (computedError.value) {
        style.borderColor = getColor("danger");
      }
      if (props.success) {
        style.borderColor = getColor("success");
      }
      return style;
    });
    const computedIconName = computed(
      () => props.indeterminate && isIndeterminate.value ? props.indeterminateIcon : props.checkedIcon
    );
    const uniqueId = useComponentUuid();
    const computedId = computed(() => props.id || String(uniqueId));
    const computedName = computed(() => props.name || String(uniqueId));
    const inputAttributesComputed = computed(() => ({
      name: computedName.value,
      disabled: props.disabled,
      readonly: props.readonly,
      tabindex: props.disabled ? -1 : 0,
      "aria-label": props.ariaLabel,
      "aria-disabled": props.disabled,
      "aria-readOnly": props.readonly,
      "aria-checked": isActive.value,
      ...validationAriaAttributes.value
    }));
    const displayVal = computed(() => props.vertical ? "--va-checkbox-display-flex" : "var(--va-checkbox-display)");
    __expose({
      toggleSelection,
      isDirty: isDirty2,
      isTouched,
      isError,
      isLoading,
      isValid
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$1X), {
        class: normalizeClass(["va-checkbox", computedClass.value]),
        disabled: _ctx.disabled,
        success: _ctx.success,
        messages: _ctx.messages,
        error: unref(computedError),
        "error-messages": unref(computedErrorMessages),
        "error-count": _ctx.errorCount,
        style: normalizeStyle(`--va-display-val: ${String(displayVal.value)}`)
      }, {
        default: withCtx(() => [
          createBaseVNode("div", {
            ref: "container",
            class: "va-checkbox__input-container",
            onClick: _cache[6] || (_cache[6] = //@ts-ignore
            (...args) => unref(toggleSelection) && unref(toggleSelection)(...args)),
            onBlur: _cache[7] || (_cache[7] = //@ts-ignore
            (...args) => unref(onBlur) && unref(onBlur)(...args))
          }, [
            createBaseVNode("div", {
              class: "va-checkbox__square",
              style: normalizeStyle(inputStyle.value),
              onSelectstart: _cache[4] || (_cache[4] = withModifiers(() => {
              }, ["prevent"]))
            }, [
              createBaseVNode("input", mergeProps$1({
                ref: "input",
                type: "checkbox",
                class: "va-checkbox__input",
                id: computedId.value,
                indeterminate: __props.indeterminate,
                value: _ctx.label,
                checked: isActive.value
              }, inputAttributesComputed.value, toHandlers(unref(keyboardFocusListeners), true), {
                onFocus: _cache[0] || (_cache[0] = //@ts-ignore
                (...args) => unref(onFocus) && unref(onFocus)(...args)),
                onBlur: _cache[1] || (_cache[1] = //@ts-ignore
                (...args) => unref(onBlur) && unref(onBlur)(...args)),
                onClick: _cache[2] || (_cache[2] = withModifiers(() => {
                }, ["stop", "prevent"])),
                onKeypress: _cache[3] || (_cache[3] = withModifiers(
                  //@ts-ignore
                  (...args) => unref(toggleSelection) && unref(toggleSelection)(...args),
                  ["prevent"]
                ))
              }), null, 16, _hoisted_1$X),
              isActive.value ? (openBlock(), createBlock(unref(VaIcon), {
                key: 0,
                class: "va-checkbox__icon",
                name: computedIconName.value,
                color: unref(textColorComputed)
              }, null, 8, ["name", "color"])) : createCommentVNode("", true)
            ], 36),
            _ctx.label || _ctx.$slots.label ? (openBlock(), createElementBlock("label", {
              key: 0,
              ref: "label",
              class: "va-checkbox__label",
              for: computedId.value,
              style: normalizeStyle(labelStyle.value),
              onBlur: _cache[5] || (_cache[5] = //@ts-ignore
              (...args) => unref(onBlur) && unref(onBlur)(...args))
            }, [
              renderSlot(_ctx.$slots, "label", {}, () => [
                createTextVNode(toDisplayString(_ctx.label), 1)
              ])
            ], 44, _hoisted_2$r)) : createCommentVNode("", true)
          ], 544)
        ]),
        _: 3
      }, 8, ["class", "disabled", "success", "messages", "error", "error-messages", "error-count", "style"]);
    };
  }
});
const VaCheckbox = withConfigTransport$1(_sfc_main$1p);
const _hoisted_1$W = { class: "va-chip__content" };
const _sfc_main$1o = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaChip"
  },
  __name: "VaChip",
  props: {
    ...useRouterLinkProps,
    ...useColorProps,
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: Boolean, default: true },
    closeable: { type: Boolean, default: false },
    outline: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    square: { type: Boolean, default: false },
    shadow: { type: Boolean, default: false },
    flat: { type: Boolean, default: false },
    icon: { type: String, default: "" },
    tag: { type: String, default: "span" },
    size: {
      type: String,
      default: "medium",
      validator: (value) => ["small", "medium", "large"].includes(value)
    },
    ariaCloseLabel: useTranslationProp("$t:close")
  },
  emits: [...useStatefulEmits, "focus"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const borderColor = computed(() => props.outline ? colorComputed.value : "");
    const isTransparentBackground = computed(() => Boolean(props.outline || props.flat));
    const { textColorComputed } = useTextColor(colorComputed, isTransparentBackground);
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const shadowStyle = computed(() => {
      if (!props.shadow || props.flat || props.outline || props.disabled || hasKeyboardFocus.value) {
        return;
      }
      return `0 0.125rem 0.19rem 0 ${getBoxShadowColor(colorComputed.value)}`;
    });
    const { valueComputed } = useStateful(props, emit2);
    const { tagComputed, hrefComputed } = useRouterLink(props);
    const { isHovered, onMouseEnter, onMouseLeave } = useHover();
    const close = () => {
      if (!props.disabled) {
        valueComputed.value = false;
      }
    };
    const iconSize = computed(() => props.size);
    const tabIndexComputed = computed(() => props.disabled ? -1 : 0);
    const computedClass = useBem("va-chip", () => ({
      ...pick(props, ["disabled", "readonly", "square"]),
      small: props.size === "small",
      large: props.size === "large"
    }));
    const computedStyle = computed(() => {
      const result = {
        color: textColorComputed.value,
        borderColor: borderColor.value,
        background: "",
        boxShadow: shadowStyle.value
      };
      if (props.outline || props.flat) {
        if (hasKeyboardFocus.value) {
          result.background = getFocusColor(colorComputed.value);
        } else if (!props.readonly && isHovered.value) {
          result.background = getHoverColor(colorComputed.value);
        }
      } else {
        result.background = colorComputed.value;
      }
      return result;
    });
    const { tp } = useTranslation();
    __expose({
      close
    });
    return (_ctx, _cache) => {
      return unref(valueComputed) ? (openBlock(), createBlock(resolveDynamicComponent(unref(tagComputed)), {
        key: 0,
        class: normalizeClass(["va-chip", unref(computedClass)]),
        href: unref(hrefComputed),
        target: _ctx.target,
        to: _ctx.to,
        replace: _ctx.replace,
        exact: _ctx.exact,
        "active-class": _ctx.activeClass,
        "exact-active-class": _ctx.exactActiveClass,
        style: normalizeStyle(computedStyle.value)
      }, {
        default: withCtx(() => [
          createBaseVNode("span", mergeProps$1({
            class: "va-chip__inner",
            onFocus: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("focus")),
            onMouseenter: _cache[1] || (_cache[1] = //@ts-ignore
            (...args) => unref(onMouseEnter) && unref(onMouseEnter)(...args)),
            onMouseleave: _cache[2] || (_cache[2] = //@ts-ignore
            (...args) => unref(onMouseLeave) && unref(onMouseLeave)(...args))
          }, toHandlers(unref(keyboardFocusListeners), true)), [
            __props.icon ? (openBlock(), createBlock(unref(VaIcon), {
              key: 0,
              class: "va-chip__icon",
              name: __props.icon,
              size: iconSize.value
            }, null, 8, ["name", "size"])) : createCommentVNode("", true),
            createBaseVNode("span", _hoisted_1$W, [
              renderSlot(_ctx.$slots, "default")
            ]),
            __props.closeable ? (openBlock(), createBlock(unref(VaIcon), {
              key: 1,
              role: "button",
              name: "va-close",
              class: "va-chip__close-icon",
              "aria-label": unref(tp)(_ctx.$props.ariaCloseLabel),
              tabindex: tabIndexComputed.value,
              size: iconSize.value,
              onClick: withModifiers(close, ["stop"]),
              onKeydown: [
                withKeys(withModifiers(close, ["stop"]), ["enter"]),
                withKeys(withModifiers(close, ["stop"]), ["space"])
              ]
            }, null, 8, ["aria-label", "tabindex", "size", "onKeydown"])) : createCommentVNode("", true)
          ], 16)
        ]),
        _: 3
      }, 8, ["href", "target", "to", "replace", "exact", "active-class", "exact-active-class", "class", "style"])) : createCommentVNode("", true);
    };
  }
});
const VaChip = withConfigTransport$1(_sfc_main$1o);
const _hoisted_1$V = { class: "va-collapse__header__text" };
const _hoisted_2$q = ["id", "aria-labelledby"];
const _hoisted_3$j = { class: "va-collapse__content" };
const _sfc_main$1n = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaCollapse"
  },
  __name: "VaCollapse",
  props: {
    ...useComponentPresetProp,
    ...useStatefulProps,
    modelValue: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    header: { type: String, default: "" },
    icon: { type: String, default: "" },
    color: { type: String, default: void 0 },
    bodyColor: { type: String, default: void 0 },
    textColor: { type: String, default: "" },
    bodyTextColor: { type: String, default: "" },
    iconColor: { type: String, default: "secondary" },
    colorAll: { type: Boolean, default: false },
    stateful: { type: Boolean, default: true }
  },
  emits: ["update:modelValue", ...useSelectableEmits],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const body = shallowRef();
    const { valueComputed } = useStateful(props, emit2, "modelValue");
    const { getColor, getTextColor, setHSLAColor: setHSLAColor2 } = useColors();
    const { accordionProps, accordionItemValue } = useAccordionItem();
    const computedModelValue = computed({
      get() {
        if (valueComputed.userProvided) {
          return valueComputed.value;
        }
        if (!isNilValue(accordionItemValue)) {
          return accordionItemValue.value;
        }
        return valueComputed.value;
      },
      set(v) {
        if (!isNilValue(accordionItemValue)) {
          accordionItemValue.value = v;
        }
        valueComputed.value = v;
      }
    });
    if (valueComputed.userProvided && !isNilValue(accordionItemValue)) {
      accordionItemValue.value = valueComputed.value;
    }
    const bodyHeight = ref();
    useResizeObserver([body], ([body2]) => {
      bodyHeight.value = body2.contentRect.height ?? 0;
    });
    const height = computed(() => computedModelValue.value ? bodyHeight.value : 0);
    const getTransition = () => {
      const duration = height.value / 1e3 * 0.2;
      return `${duration > 0.2 ? duration : 0.2}s`;
    };
    const contentBackground = computed(() => {
      if (props.bodyColor) {
        return getColor(props.bodyColor);
      }
      return props.color && props.colorAll ? setHSLAColor2(getColor(props.color), { a: 0.07 }) : void 0;
    });
    const headerBackground = computed(() => {
      return props.color ? getColor(props.color) : void 0;
    });
    const uniqueId = useComponentUuid();
    const headerIdComputed = computed(() => `header-${uniqueId}`);
    const panelIdComputed = computed(() => `panel-${uniqueId}`);
    const tabIndexComputed = computed(() => props.disabled ? -1 : 0);
    const headerAttributes = computed(() => ({
      id: headerIdComputed.value,
      tabindex: tabIndexComputed.value,
      "aria-controls": panelIdComputed.value,
      "aria-expanded": computedModelValue.value,
      "aria-disabled": props.disabled,
      role: "button"
    }));
    const isHeightChanging = ref(false);
    watch(height, (newValue, oldValue) => {
      if (oldValue === void 0) {
        return;
      }
      if (isHeightChanging.value === true) {
        return;
      }
      isHeightChanging.value = true;
    });
    const onTransitionEnd = (e) => {
      if (e.propertyName === "height" && e.target === e.currentTarget) {
        isHeightChanging.value = false;
      }
    };
    const computedClasses = useBem("va-collapse", () => ({
      ...pick(props, ["disabled"]),
      expanded: computedModelValue.value,
      active: computedModelValue.value,
      popout: !!(accordionProps.value.popout && computedModelValue.value),
      inset: !!(accordionProps.value.inset && computedModelValue.value),
      "height-changing": isHeightChanging.value,
      "colored-body": Boolean(contentBackground.value),
      "colored-header": Boolean(headerBackground.value)
    }));
    const toggle = () => {
      if (props.disabled) {
        return;
      }
      computedModelValue.value = !computedModelValue.value;
    };
    const { textColorComputed } = useTextColor(headerBackground);
    const headerStyle = computed(() => ({
      color: textColorComputed.value,
      backgroundColor: headerBackground.value
    }));
    const doRenderBody = computed(() => {
      if (computedModelValue.value) {
        return true;
      }
      if (isHeightChanging.value) {
        return true;
      }
      return false;
    });
    const contentStyle = computed(() => {
      return {
        height: `${height.value}px`,
        transitionDuration: getTransition(),
        background: computedModelValue.value ? contentBackground.value : "",
        color: props.bodyTextColor ? getColor(props.bodyTextColor) : contentBackground.value ? getColor(getTextColor(contentBackground.value)) : "currentColor"
      };
    });
    __expose({
      toggle
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["va-collapse", unref(computedClasses)])
      }, [
        createBaseVNode("div", {
          class: "va-collapse__header-wrapper",
          onClick: toggle,
          onKeydown: [
            withKeys(toggle, ["enter"]),
            withKeys(toggle, ["space"])
          ]
        }, [
          renderSlot(_ctx.$slots, "header", normalizeProps$1(guardReactiveProps({
            value: computedModelValue.value,
            bind: headerAttributes.value,
            attributes: headerAttributes.value,
            attrs: headerAttributes.value,
            iconAttrs: {
              class: [
                "va-collapse__expand-icon",
                computedModelValue.value ? "a-collapse__expand-icon--expanded" : "a-collapse__expand-icon--collapsed"
              ]
            },
            text: __props.header
          })), () => [
            createBaseVNode("div", mergeProps$1(headerAttributes.value, {
              class: "va-collapse__header",
              style: headerStyle.value
            }), [
              __props.icon ? (openBlock(), createBlock(unref(VaIcon), {
                key: 0,
                class: "va-collapse__header__icon",
                name: __props.icon
              }, null, 8, ["name"])) : createCommentVNode("", true),
              renderSlot(_ctx.$slots, "header-content", normalizeProps$1(guardReactiveProps({ header: __props.header })), () => [
                createBaseVNode("div", _hoisted_1$V, toDisplayString(__props.header), 1)
              ]),
              renderSlot(_ctx.$slots, "expand-icon", {}, () => [
                createVNode(unref(VaIcon), {
                  class: normalizeClass(["va-collapse__expand-icon", computedModelValue.value ? "va-collapse__expand-icon--expanded" : "va-collapse__expand-icon--collapsed"]),
                  name: "va-arrow-down"
                }, null, 8, ["class"])
              ])
            ], 16)
          ])
        ], 32),
        createBaseVNode("div", {
          class: normalizeClass(["va-collapse__body-wrapper", {
            "va-collapse__body-wrapper--bordered": !_ctx.$slots.body && !_ctx.$slots.header
          }]),
          style: normalizeStyle(contentStyle.value),
          onTransitionend: onTransitionEnd
        }, [
          doRenderBody.value ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "va-collapse__body",
            ref_key: "body",
            ref: body,
            role: "region",
            id: panelIdComputed.value,
            "aria-labelledby": headerIdComputed.value
          }, [
            renderSlot(_ctx.$slots, "body", {}, () => [
              createBaseVNode("div", _hoisted_3$j, [
                renderSlot(_ctx.$slots, "default", {}, () => [
                  renderSlot(_ctx.$slots, "content")
                ])
              ])
            ])
          ], 8, _hoisted_2$q)) : createCommentVNode("", true)
        ], 38)
      ], 2);
    };
  }
});
const VaCollapse = withConfigTransport$1(_sfc_main$1n);
const _sfc_main$1m = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaColorIndicator"
  },
  __name: "VaColorIndicator",
  props: {
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: Boolean, default: null },
    color: { type: String, default: "" },
    square: { type: Boolean, default: false },
    size: { type: String, default: "1rem" }
  },
  emits: [...useStatefulEmits],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const { valueComputed } = useStateful(props, emit2);
    const { getColor } = useColors();
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const colorComputed = computed(() => getColor(props.color));
    const borderRadiusComputed = computed(() => props.square ? "0px" : "50%");
    const computedStyle = computed(() => ({
      backgroundColor: colorComputed.value,
      height: props.size,
      width: props.size
    }));
    const computedClass = computed(() => ({
      "va-color-indicator--selected": valueComputed.value,
      "va-color-indicator--on-keyboard-focus": hasKeyboardFocus.value
    }));
    const toggleModelValue = () => {
      valueComputed.value = !valueComputed.value;
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", mergeProps$1({
        class: ["va-color-indicator", computedClass.value],
        style: [computedStyle.value, `--va-border-radius-computed: ${String(borderRadiusComputed.value)}`],
        onClick: toggleModelValue,
        onKeydown: [
          withKeys(toggleModelValue, ["enter"]),
          withKeys(toggleModelValue, ["space"])
        ]
      }, toHandlers(unref(keyboardFocusListeners), true)), [
        createBaseVNode("div", {
          class: "va-color-indicator__core",
          style: normalizeStyle(computedStyle.value)
        }, null, 4)
      ], 16);
    };
  }
});
const VaColorIndicator = withConfigTransport$1(_sfc_main$1m);
const _hoisted_1$U = {
  key: 0,
  class: "va-input-label__required-mark"
};
const _sfc_main$1l = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaInputLabel"
  },
  __name: "VaInputLabel",
  props: {
    label: {
      type: String,
      default: ""
    },
    requiredMark: {
      type: Boolean,
      default: false
    },
    color: {
      type: String,
      default: "primary"
    }
  },
  setup(__props) {
    const { getColor } = useColors();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("label", {
        "aria-hidden": "true",
        class: "va-input-label",
        style: normalizeStyle({ color: unref(getColor)(_ctx.$props.color, void 0, true) })
      }, [
        renderSlot(_ctx.$slots, "default", normalizeProps$1(guardReactiveProps({ label: __props.label, requiredMark: __props.requiredMark, color: unref(getColor)(_ctx.$props.color) })), () => [
          createTextVNode(toDisplayString(__props.label) + " ", 1),
          __props.requiredMark ? (openBlock(), createElementBlock("span", _hoisted_1$U, " * ")) : createCommentVNode("", true)
        ])
      ], 4);
    };
  }
});
const useInputFieldAriaProps = {
  label: { type: String, default: "" },
  inputAriaLabel: useTranslationProp("$t:inputField"),
  inputAriaLabelledby: { type: String },
  inputAriaDescribedby: { type: String }
};
const useInputFieldAria = (props) => {
  const id = useComponentUuid();
  const labelId = `input-label-${id}`;
  const characterCountId = `input-character-count-${id}`;
  const ariaAttributes = computed(() => ({
    "aria-label": props.label !== "" ? props.label : props.inputAriaLabel,
    "aria-labelledby": props.inputAriaLabelledby ? props.inputAriaLabelledby : labelId,
    "aria-describedby": props.inputAriaDescribedby ? props.inputAriaDescribedby : characterCountId
  }));
  return {
    labelId,
    characterCountId,
    ariaAttributes
  };
};
const WithSlotInheritance = (component) => {
  return /* @__PURE__ */ defineComponent({
    name: "ProxySlots",
    props: {
      inheritSlots: { type: Array, required: true }
    },
    render() {
      var _a2;
      const parentSlots = ((_a2 = this.$parent) == null ? void 0 : _a2.$slots) || {};
      const slotsToProxy = this.$props.inheritSlots || Object.keys(parentSlots);
      const slots = slotsToProxy.reduce(
        (slots2, name) => {
          if (parentSlots[name]) {
            slots2[name] = parentSlots[name];
          }
          return slots2;
        },
        {}
      );
      return h(component, this.$attrs, {
        ...slots,
        ...this.$slots
      });
    }
  });
};
const useFormFieldProps = {
  disabled: { type: Boolean, default: false },
  readonly: { type: Boolean, default: false }
};
const useFormField = (prefix2, props) => {
  const computedClasses = useBem(prefix2, computed(() => pick(props, ["disabled", "readonly"])));
  return { computedClasses };
};
const useFocusDeep = (el) => {
  const focused = useActiveElement();
  const current = useCurrentElement(el ? useHTMLElement(el) : void 0);
  let previouslyFocusedElement = null;
  const isFocused = computed({
    get() {
      var _a2;
      if (!focused.value) {
        return false;
      }
      if (focused.value === current.value) {
        return true;
      }
      const isFocused2 = (_a2 = current.value) == null ? void 0 : _a2.contains(focused.value);
      if (isFocused2) {
        previouslyFocusedElement = focused.value;
      }
      return isFocused2;
    },
    set(value) {
      var _a2;
      let target = previouslyFocusedElement ?? current.value;
      if (!((_a2 = current.value) == null ? void 0 : _a2.contains(target))) {
        target = current.value;
      }
      if (value) {
        target == null ? void 0 : target.focus();
      } else {
        target == null ? void 0 : target.blur();
      }
    }
  });
  return Object.assign(isFocused, {
    /** Focus `el` if focus is not set to any other element */
    focusIfNothingIfFocused: () => {
      if (focused.value === document.body) {
        isFocused.value = true;
      }
    },
    focusPreviousElement: () => {
      if (previouslyFocusedElement) {
        previouslyFocusedElement.focus();
      } else {
        document.body.focus();
      }
    }
  });
};
const VaInputLabelProps = extractComponentProps(_sfc_main$1l);
const _sfc_main$1k = /* @__PURE__ */ defineComponent({
  name: "VaInputWrapper",
  components: { VaMessageList: WithSlotInheritance(VaMessageList), VaIcon, VaInputLabel: _sfc_main$1l },
  props: {
    ...useComponentPresetProp,
    ...useInputFieldAriaProps,
    ...useFormFieldProps,
    ...useValidationProps,
    ...VaInputLabelProps,
    modelValue: { type: null, default: "" },
    counter: { type: Boolean },
    maxLength: { type: [Number, String], default: void 0 },
    label: { type: String, default: "" },
    placeholder: { type: String, default: "" },
    color: { type: String, default: "primary" },
    background: { type: String },
    success: { type: Boolean, default: false },
    loading: { type: Boolean, default: false },
    requiredMark: { type: Boolean, default: false },
    innerLabel: { type: Boolean, default: false }
  },
  emits: [
    "click",
    "click-prepend",
    "click-append",
    "click-prepend-inner",
    "click-append-inner",
    "click-field",
    "update:modelValue"
  ],
  setup(props, { emit: emit2, slots }) {
    const { getColor } = useColors();
    const [vModel] = useSyncProp("modelValue", props, emit2, "");
    const inputRef = ref();
    const isFocused = useFocusDeep();
    const counterValue = computed(
      () => props.counter && typeof vModel.value === "string" ? vModel.value.length : void 0
    );
    const wrapperClass = useBem("va-input-wrapper", () => ({
      ...pick(props, ["success", "error", "disabled", "readonly"]),
      focused: Boolean(isFocused.value),
      labeled: Boolean(props.label || slots.label),
      labeledInner: Boolean(props.label || slots.label) && props.innerLabel
    }));
    const colorComputed = computed(() => getColor(props.color));
    const backgroundComputed = computed(() => props.background ? getColor(props.background) : "#ffffff00");
    const messagesComputed = computed(() => props.error ? props.errorMessages : props.messages);
    const { textColorComputed } = useTextColor(backgroundComputed);
    const maxLengthComputed = useNumericProp("maxLength");
    const messagesColor = computed(() => {
      if (props.error) {
        return "danger";
      }
      if (props.success) {
        return "success";
      }
      return "";
    });
    const errorLimit = computed(() => props.error ? Number(props.errorCount) : 99);
    const isCounterVisible = computed(() => counterValue.value !== void 0);
    const counterComputed = computed(
      () => maxLengthComputed.value !== void 0 ? `${counterValue.value}/${maxLengthComputed.value}` : counterValue.value
    );
    const {
      labelId,
      characterCountId,
      ariaAttributes
    } = useInputFieldAria(props);
    const vaInputLabelProps = filterComponentProps(VaInputLabelProps);
    const focus = () => {
      isFocused.value = true;
    };
    const blur = () => {
      isFocused.value = false;
    };
    return {
      inputRef,
      focus,
      blur,
      labelId,
      characterCountId,
      ariaAttributes,
      vModel,
      counterValue,
      vaInputLabelProps,
      wrapperClass,
      textColorComputed,
      isCounterVisible,
      counterComputed,
      colorComputed,
      backgroundComputed,
      messagesColor,
      messagesComputed,
      errorLimit
    };
  }
});
const _hoisted_1$T = { class: "va-input-wrapper__fieldset va-input-wrapper__size-keeper" };
const _hoisted_2$p = { class: "va-input-wrapper__container" };
const _hoisted_3$i = { class: "va-input-wrapper__text" };
const _hoisted_4$a = ["placeholder", "readonly", "disabled"];
const _hoisted_5$7 = ["id"];
const _hoisted_6$2 = { class: "va-input-wrapper__counter" };
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VaInputLabel = resolveComponent("VaInputLabel");
  const _component_va_icon = resolveComponent("va-icon");
  const _component_va_message_list = resolveComponent("va-message-list");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["va-input-wrapper", _ctx.wrapperClass]),
    onClick: _cache[6] || (_cache[6] = ($event) => _ctx.$emit("click", $event)),
    style: normalizeStyle(`--va-background-computed: ${String(_ctx.backgroundComputed)};--va-color-computed: ${String(_ctx.colorComputed)};--va-text-color-computed: ${String(_ctx.textColorComputed)}`)
  }, [
    createBaseVNode("fieldset", _hoisted_1$T, [
      createVNode(_component_va_message_list, {
        color: _ctx.messagesColor,
        "model-value": _ctx.messagesComputed,
        limit: _ctx.errorLimit,
        "inherit-slots": ["message", "messages"]
      }, {
        default: withCtx(({ ariaAttributes: messagesChildAriaAttributes }) => [
          (_ctx.$props.label || _ctx.$slots.label) && !_ctx.$props.innerLabel ? (openBlock(), createBlock(_component_VaInputLabel, mergeProps$1({
            key: 0,
            class: "va-input-wrapper__label va-input-wrapper__label--outer"
          }, _ctx.vaInputLabelProps, { id: _ctx.labelId }), {
            default: withCtx((bind) => [
              renderSlot(_ctx.$slots, "label", normalizeProps$1(guardReactiveProps(bind)))
            ]),
            _: 3
          }, 16, ["id"])) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_2$p, [
            _ctx.$slots.prepend ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "va-input-wrapper__prepend-inner",
              onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click-prepend"))
            }, [
              renderSlot(_ctx.$slots, "prepend")
            ])) : createCommentVNode("", true),
            createBaseVNode("div", {
              onClick: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("click-field", $event)),
              class: "va-input-wrapper__field"
            }, [
              _ctx.$slots.prependInner ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "va-input-wrapper__prepend-inner",
                ref: "container",
                onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("click-prepend-inner", $event))
              }, [
                renderSlot(_ctx.$slots, "prependInner")
              ], 512)) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_3$i, [
                (_ctx.$props.label || _ctx.$slots.label) && _ctx.$props.innerLabel ? (openBlock(), createBlock(_component_VaInputLabel, mergeProps$1({
                  key: 0,
                  class: "va-input-wrapper__label va-input-wrapper__label--inner"
                }, _ctx.vaInputLabelProps, { id: _ctx.labelId }), {
                  default: withCtx((bind) => [
                    renderSlot(_ctx.$slots, "label", normalizeProps$1(guardReactiveProps(bind)))
                  ]),
                  _: 3
                }, 16, ["id"])) : createCommentVNode("", true),
                renderSlot(_ctx.$slots, "default", normalizeProps$1(guardReactiveProps({ ariaAttributes: { ...messagesChildAriaAttributes, ..._ctx.ariaAttributes }, value: _ctx.vModel })), () => [
                  withDirectives(createBaseVNode("input", mergeProps$1({ ...messagesChildAriaAttributes, ..._ctx.ariaAttributes }, {
                    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.vModel = $event),
                    ref: "inputRef",
                    placeholder: _ctx.$props.placeholder,
                    readonly: _ctx.$props.readonly,
                    disabled: _ctx.$props.disabled
                  }), null, 16, _hoisted_4$a), [
                    [vModelDynamic, _ctx.vModel]
                  ])
                ])
              ]),
              _ctx.success ? (openBlock(), createBlock(_component_va_icon, {
                key: 1,
                color: "success",
                name: "va-check-circle",
                class: "va-input-wrapper__icon va-input-wrapper__icon--success"
              })) : createCommentVNode("", true),
              _ctx.error ? (openBlock(), createBlock(_component_va_icon, {
                key: 2,
                color: "danger",
                name: "va-warning",
                class: "va-input-wrapper__icon va-input-wrapper__icon--error"
              })) : createCommentVNode("", true),
              _ctx.$props.loading ? (openBlock(), createBlock(_component_va_icon, {
                key: 3,
                color: _ctx.$props.color,
                name: "va-loading",
                spin: "counter-clockwise",
                class: "va-input-wrapper__icon va-input-wrapper__icon--loading"
              }, null, 8, ["color"])) : createCommentVNode("", true),
              renderSlot(_ctx.$slots, "icon"),
              _ctx.$slots.appendInner ? (openBlock(), createElementBlock("div", {
                key: 4,
                class: "va-input-wrapper__append-inner",
                onClick: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("click-append-inner", $event))
              }, [
                renderSlot(_ctx.$slots, "appendInner")
              ])) : createCommentVNode("", true)
            ]),
            _ctx.$slots.append ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: "va-input-wrapper__append-inner",
              onClick: _cache[5] || (_cache[5] = ($event) => _ctx.$emit("click-append"))
            }, [
              renderSlot(_ctx.$slots, "append")
            ])) : createCommentVNode("", true)
          ]),
          _ctx.isCounterVisible ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: "va-input-wrapper__counter-wrapper",
            id: _ctx.characterCountId
          }, [
            renderSlot(_ctx.$slots, "counter", normalizeProps$1(guardReactiveProps({ valueLength: _ctx.counterValue, maxLength: _ctx.$props.maxLength })), () => [
              createBaseVNode("div", _hoisted_6$2, toDisplayString(_ctx.counterComputed), 1)
            ])
          ], 8, _hoisted_5$7)) : createCommentVNode("", true)
        ]),
        _: 3
      }, 8, ["color", "model-value", "limit"])
    ])
  ], 6);
}
const _VaInputWrapper = /* @__PURE__ */ _export_sfc(_sfc_main$1k, [["render", _sfc_render$3]]);
const VaInputWrapper = withConfigTransport$1(_VaInputWrapper);
const combineFunctions = (...list) => {
  return (...args) => list.forEach((fn) => fn(...args));
};
const useFocusableProps = {
  /** Focus element when mounted */
  autofocus: { type: Boolean, default: false }
};
const useFocusable = (el, props) => {
  const focus = () => {
    focusElement(unwrapEl(el.value));
  };
  const blur = () => {
    blurElement(unwrapEl(el.value));
  };
  onMounted(() => {
    if (props.autofocus) {
      focus();
    }
  });
  return {
    focus,
    blur
  };
};
const useClearableProps = {
  clearable: { type: Boolean, default: false },
  clearableIcon: { type: String, default: "va-clear" },
  clearValue: { type: String, default: "" }
};
const useClearableEmits = ["clear"];
const useClearable = (props, inputValue, el, hasError) => {
  const { isFocused, onFocus, onBlur } = useFocus(el);
  const clearedValues = [null, void 0, props.clearValue];
  const canBeCleared = computed(() => props.clearable && !props.disabled && !props.readonly && !clearedValues.includes(inputValue.value));
  const clearIconColor = computed(() => {
    if (isFocused == null ? void 0 : isFocused.value) {
      return props.color || "primary";
    }
    if (hasError == null ? void 0 : hasError.value) {
      return "danger";
    }
    if (props.success) {
      return "success";
    }
    return "secondary";
  });
  const clearIconProps = computed(() => ({
    name: props.clearableIcon,
    color: clearIconColor.value,
    size: "medium",
    tabindex: canBeCleared.value ? 0 : -1
  }));
  return {
    canBeCleared,
    clearIconColor,
    clearIconProps,
    onFocus,
    onBlur
  };
};
const useDeprecatedCondition = (validators) => {
  if (!isDev) {
    return void 0;
  }
  const instance = getCurrentInstance();
  if (!instance) {
    throw new Error("`useDeprecated` hook must be used only inside of setup function!");
  }
  validators.forEach((validator) => {
    const message = validator();
    if (typeof message === "string") {
      warn(`(${instance.type.name} component) ${message}`);
    }
  });
};
const VaInputWrapperProps$4 = extractComponentProps(VaInputWrapper);
const { createEmits: createInputEmits$1, createListeners: createInputListeners$1 } = useEmitProxy(
  ["change", "keyup", "keypress", "keydown", "focus", "blur", "input"]
);
const { createEmits: createFieldEmits$1, createListeners: createFieldListeners$1 } = useEmitProxy([
  "click",
  "click-prepend",
  "click-append",
  "click-prepend-inner",
  "click-append-inner"
]);
const _sfc_main$1j = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaInput"
  },
  __name: "VaInput",
  props: {
    ...VaInputWrapperProps$4,
    ...useFormFieldProps,
    ...useFocusableProps,
    ...useValidationProps,
    ...useClearableProps,
    ...useComponentPresetProp,
    ...useStatefulProps,
    // input
    placeholder: { type: String, default: "" },
    tabindex: { type: [String, Number], default: 0 },
    modelValue: { type: [Number, String, null], default: "" },
    type: { type: String, default: "text" },
    inputClass: { type: String, default: "" },
    pattern: { type: String },
    inputmode: { type: String, default: "text" },
    counter: { type: Boolean, default: false },
    autocomplete: { type: String },
    // style
    ariaResetLabel: useTranslationProp("$t:reset"),
    /** Set value to input when model value is updated */
    strictBindInputValue: { type: Boolean, default: false }
  },
  emits: [
    "update:modelValue",
    ...useValidationEmits,
    ...useClearableEmits,
    ...createInputEmits$1(),
    ...createFieldEmits$1(),
    ...useStatefulEmits
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    useDeprecatedCondition([
      () => props.type !== "textarea" || 'Use VaTextarea component instead of VaInput with type="textarea"'
    ]);
    const input = shallowRef();
    const { valueComputed } = useStateful(props, emit2, "modelValue");
    const reset = () => withoutValidation(() => {
      valueComputed.value = props.clearValue;
      emit2("clear");
      resetValidation();
    });
    const { focus, blur } = useFocusable(input, props);
    const slots = useSlots();
    const filterSlots = computed(() => {
      const iconSlot = ["icon"];
      return Object.keys(slots).filter((slot) => !iconSlot.includes(slot));
    });
    const { tp } = useTranslation();
    const {
      isValid,
      isTouched,
      isDirty: isDirty2,
      computedError,
      computedErrorMessages,
      listeners: { onBlur },
      validationAriaAttributes,
      isLoading,
      withoutValidation,
      resetValidation
    } = useValidation(props, emit2, { reset, focus, value: valueComputed });
    const { modelValue } = toRefs(props);
    const {
      canBeCleared,
      clearIconProps
    } = useClearable(props, modelValue, input, computedError);
    const inputListeners = createInputListeners$1(emit2);
    const inputEvents = {
      ...inputListeners,
      onBlur: combineFunctions(onBlur, inputListeners.onBlur)
    };
    const setInputValue = (newValue) => {
      if (!props.strictBindInputValue) {
        return;
      }
      const target = input.value;
      if (!target) {
        return;
      }
      const selectionStart = target.selectionStart || 0;
      const selectionEnd = target.selectionEnd || 0;
      if (target.value !== newValue) {
        target.value = String(newValue);
      }
      target.setSelectionRange(selectionStart, selectionEnd);
    };
    watch(valueComputed, (newValue) => {
      setInputValue(String(newValue));
    }, { immediate: true });
    useEvent("input", () => {
      setInputValue(String(valueComputed.value));
    }, input);
    const tabIndexComputed = computed(() => props.disabled ? -1 : props.tabindex);
    const attrs = useAttrs();
    const computedChildAttributes = computed(() => ({
      "aria-label": props.inputAriaLabel || props.label,
      "aria-labelledby": props.inputAriaLabelledby,
      "aria-required": props.requiredMark,
      tabindex: tabIndexComputed.value,
      class: props.inputClass,
      "aria-disabled": props.disabled,
      "aria-readonly": props.readonly,
      ...validationAriaAttributes.value
    }));
    const computedInputAttributes = computed(() => ({
      ...computedChildAttributes.value,
      ...pick(props, ["type", "disabled", "readonly", "placeholder", "pattern", "inputmode", "name", "autocomplete"]),
      ...pick(attrs, ["minlength", "minlength"])
    }));
    const valueLengthComputed = computed(
      () => props.counter && typeof valueComputed.value === "string" ? valueComputed.value.length : void 0
    );
    const onFieldClick = (e) => {
      if (!e.target || !("tagName" in e.target)) {
        return;
      }
      if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA") {
        return;
      }
      focus();
    };
    const wrapperProps = filterComponentProps(VaInputWrapperProps$4);
    const fieldListeners = createFieldListeners$1(emit2);
    __expose({
      isValid,
      isDirty: isDirty2,
      isTouched,
      isLoading,
      computedError,
      computedErrorMessages,
      reset,
      focus,
      blur,
      value: valueComputed,
      withoutValidation,
      resetValidation
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaInputWrapper), mergeProps$1({
        ...unref(fieldListeners),
        ...unref(wrapperProps)
      }, {
        class: ["va-input", _ctx.$attrs.class],
        style: _ctx.$attrs.style,
        loading: _ctx.$props.loading || unref(isLoading),
        error: unref(computedError),
        "error-messages": unref(computedErrorMessages),
        "error-count": _ctx.errorCount,
        "counter-value": valueLengthComputed.value,
        onClick: onFieldClick
      }), createSlots$1({
        icon: withCtx((slotScope) => [
          unref(canBeCleared) ? (openBlock(), createBlock(unref(VaIcon), mergeProps$1({
            key: 0,
            role: "button",
            "aria-label": unref(tp)(_ctx.$props.ariaResetLabel)
          }, unref(clearIconProps), {
            onClick: withModifiers(reset, ["stop"]),
            onKeydown: [
              withKeys(withModifiers(reset, ["stop"]), ["enter"]),
              withKeys(withModifiers(reset, ["stop"]), ["space"])
            ]
          }), null, 16, ["aria-label", "onKeydown"])) : createCommentVNode("", true),
          renderSlot(_ctx.$slots, "icon", normalizeProps$1(guardReactiveProps(slotScope)))
        ]),
        default: withCtx(() => [
          !_ctx.$slots.content ? withDirectives((openBlock(), createElementBlock("input", mergeProps$1({
            key: 0,
            ref_key: "input",
            ref: input,
            class: "va-input__content__input"
          }, { ...computedInputAttributes.value, ...inputEvents }, {
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(valueComputed) ? valueComputed.value = $event : null)
          }), null, 16)), [
            [vModelDynamic, unref(valueComputed)]
          ]) : createCommentVNode("", true)
        ]),
        _: 2
      }, [
        renderList(filterSlots.value, (name) => {
          return {
            name,
            fn: withCtx((slotScope) => [
              renderSlot(_ctx.$slots, name, normalizeProps$1(guardReactiveProps(slotScope)))
            ])
          };
        })
      ]), 1040, ["class", "style", "loading", "error", "error-messages", "error-count", "counter-value"]);
    };
  }
});
const VaInput = withConfigTransport$1(_sfc_main$1j);
const _hoisted_1$S = { class: "va-color-input" };
const VaInputProps = extractComponentProps(VaInput);
const _sfc_main$1i = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaColorInput"
  },
  __name: "VaColorInput",
  props: {
    ...VaInputProps,
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: String, default: null },
    disabled: { type: Boolean, default: false },
    indicator: {
      type: String,
      default: "dot",
      validator: (value) => ["dot", "square"].includes(value)
    },
    ariaOpenColorPickerLabel: useTranslationProp("$t:openColorPicker")
  },
  emits: [...useStatefulEmits],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const colorPicker = shallowRef();
    const { valueComputed } = useStateful(props, emit2);
    const callPickerDialog = () => {
      var _a2;
      return !props.disabled && ((_a2 = colorPicker.value) == null ? void 0 : _a2.click());
    };
    const tabIndexComputed = computed(() => props.disabled ? -1 : 0);
    const inputValue = computed({
      get: () => props.modelValue,
      set: throttle((value) => emit2("update:modelValue", value), 500)
    });
    const vaInputProps = filterComponentProps(VaInputProps);
    const { tp } = useTranslation();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$S, [
        createVNode(unref(VaInput), mergeProps$1(unref(vaInputProps), {
          modelValue: unref(valueComputed),
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(valueComputed) ? valueComputed.value = $event : null),
          class: "va-color-input__input",
          tabindex: tabIndexComputed.value
        }), {
          appendInner: withCtx(() => [
            createVNode(unref(VaColorIndicator), {
              class: "va-color-input__dot",
              role: "button",
              "aria-label": unref(tp)(_ctx.$props.ariaOpenColorPickerLabel),
              "aria-disabled": _ctx.$props.disabled,
              tabindex: tabIndexComputed.value,
              color: unref(valueComputed),
              indicator: _ctx.$props.indicator,
              size: "16px",
              onClick: callPickerDialog,
              onKeydown: [
                withKeys(callPickerDialog, ["space"]),
                withKeys(callPickerDialog, ["enter"])
              ]
            }, null, 8, ["aria-label", "aria-disabled", "tabindex", "color", "indicator"])
          ]),
          _: 1
        }, 16, ["modelValue", "tabindex"]),
        withDirectives(createBaseVNode("input", {
          ref_key: "colorPicker",
          ref: colorPicker,
          type: "color",
          class: "va-color-input__hidden-input",
          "aria-hidden": "true",
          tabindex: "-1",
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => inputValue.value = $event)
        }, null, 512), [
          [vModelText, inputValue.value]
        ])
      ]);
    };
  }
});
const VaColorInput = withConfigTransport$1(_sfc_main$1i);
const _hoisted_1$R = ["aria-label"];
const _sfc_main$1h = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaColorPalette"
  },
  __name: "VaColorPalette",
  props: {
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: String, default: null },
    palette: { type: Array, default: () => [] },
    indicator: {
      type: String,
      default: "dot",
      validator: (value) => ["dot", "square"].includes(value)
    },
    ariaLabel: useTranslationProp("$t:colorSelection"),
    ariaIndicatorLabel: useTranslationProp("$t:color")
  },
  emits: [...useStatefulEmits],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const { valueComputed } = useStateful(props, emit2);
    const isSelected = (color) => valueComputed.value === color;
    const { tp } = useTranslation();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("ul", {
        class: "va-color-palette",
        role: "listbox",
        "aria-label": unref(tp)(_ctx.$props.ariaLabel)
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(__props.palette, (color, index) => {
          return openBlock(), createBlock(unref(VaColorIndicator), {
            key: index,
            role: "option",
            "aria-label": unref(tp)(_ctx.$props.ariaIndicatorLabel, { color }),
            "aria-selected": isSelected(color),
            tabindex: "0",
            modelValue: isSelected(color),
            color,
            square: __props.indicator === "square",
            "onUpdate:modelValue": ($event) => valueComputed.value = color
          }, null, 8, ["aria-label", "aria-selected", "modelValue", "color", "square", "onUpdate:modelValue"]);
        }), 128))
      ], 8, _hoisted_1$R);
    };
  }
});
const VaColorPalette = withConfigTransport$1(_sfc_main$1h);
const _sfc_main$1g = {
  name: "VaContent"
};
const _hoisted_1$Q = { class: "va-typography-block" };
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$Q, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
const _VaContent = /* @__PURE__ */ _export_sfc(_sfc_main$1g, [["render", _sfc_render$2]]);
const VaContent = withConfigTransport$1(_VaContent);
const safeCSSLength = (length) => typeof length === "number" ? `${length}px` : length;
function useCounterPropsValidation(props) {
  const validateCounterProps = () => {
    const val = Number(props.modelValue);
    const max2 = Number(props.max);
    const min2 = Number(props.min);
    const step = Number(props.step);
    if (Number.isNaN(val)) {
      warn("The value is not a number or cannot be reduced to a number.");
      return;
    }
    if (min2 && max2 && min2 > max2) {
      warn(`The maximum value (${max2}) can not be less than the minimum value (${min2}).`);
    }
    if (min2 && val < min2) {
      warn(`The value of the counter (${val}) can not be less than the minimum value (${min2}).`);
    }
    if (max2 && val > max2) {
      warn(`The value of the counter (${val}) can not be greater than the maximum value (${max2}).`);
    }
    if (min2 && max2 && step > max2 - min2) {
      warn(`The value of the step (${step}) can not be greater than the difference (${max2 - min2}) between maximum value (${max2}) and minimum value (${min2}).`);
    }
  };
  watch(
    [
      () => props.step,
      () => props.min,
      () => props.max
    ],
    validateCounterProps,
    { immediate: true }
  );
}
const toFloat = (num) => {
  return Number(num.toPrecision(13));
};
const isDividable = (num, step) => {
  const result = toFloat(num % step);
  return result === 0 || result === step;
};
function useLongPress(el, options) {
  let timeoutId = -1;
  let intervalId = -1;
  const handleMouseDown = () => {
    var _a2;
    (_a2 = options.onStart) == null ? void 0 : _a2.call(options);
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      intervalId = setInterval(() => {
        var _a22;
        return (_a22 = options.onUpdate) == null ? void 0 : _a22.call(options);
      }, options.interval || 100);
    }, unref(options.delay) || 500);
  };
  const handleMouseUp = () => {
    var _a2;
    clearTimeout(timeoutId);
    clearInterval(intervalId);
    (_a2 = options.onEnd) == null ? void 0 : _a2.call(options);
  };
  const htmlElement = useHTMLElement(el);
  useEvent(["mousedown", "touchstart", "dragstart"], handleMouseDown, htmlElement);
  useEvent([
    "mouseup",
    "mouseleave",
    "touchend",
    "touchcancel",
    "drop",
    "dragend",
    "blur"
  ], handleMouseUp, true);
}
const _hoisted_1$P = ["value", "aria-live"];
const { createEmits: createInputEmits, createListeners: createInputListeners } = useEmitProxy(
  ["change"]
);
const { createEmits: createFieldEmits, createListeners: createFieldListeners } = useEmitProxy([
  { listen: "click-prepend", emit: "click:decrease-button" },
  { listen: "click-append", emit: "click:increase-button" },
  { listen: "click-prepend-inner", emit: "click:decrease-icon" },
  { listen: "click-append-inner", emit: "click:increase-icon" }
]);
const VaInputWrapperProps$3 = extractComponentProps(VaInputWrapper);
const _sfc_main$1f = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaCounter",
    inheritAttrs: false
  },
  __name: "VaCounter",
  props: {
    ...useFormFieldProps,
    ...useStatefulProps,
    ...useComponentPresetProp,
    ...useClearableProps,
    ...VaInputWrapperProps$3,
    // input
    modelValue: { type: [String, Number], default: 0 },
    manualInput: { type: Boolean, default: false },
    min: { type: [Number, String] },
    max: { type: [Number, String] },
    step: { type: [Number, String], default: 1 },
    color: { type: String, default: "primary" },
    // icons & buttons
    increaseIcon: { type: String, default: "va-plus" },
    decreaseIcon: { type: String, default: "va-minus" },
    buttons: { type: Boolean, default: false },
    flat: { type: Boolean, default: true },
    rounded: { type: Boolean, default: false },
    margins: { type: [String, Number], default: "4px" },
    longPressDelay: { type: [Number, String], default: 500 },
    ariaLabel: useTranslationProp("$t:counterValue"),
    ariaDecreaseLabel: useTranslationProp("$t:decreaseCounter"),
    ariaIncreaseLabel: useTranslationProp("$t:increaseCounter")
  },
  emits: [
    "update:modelValue",
    ...useValidationEmits,
    ...createInputEmits(),
    ...createFieldEmits(),
    ...useFocusEmits
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const input = shallowRef();
    const { min: min2 = ref(void 0), max: max2 = ref(void 0), step } = toRefs(props);
    const longPressDelayComputed = useNumericProp("longPressDelay");
    const {
      isFocused,
      focus,
      blur
    } = useFocus(input, emit2);
    const { valueComputed: statefulValue } = useStateful(props, emit2);
    function floatify(num) {
      return parseFloat(Number(num).toFixed(10));
    }
    const valueComputed = computed({
      get() {
        return statefulValue.value;
      },
      set(v) {
        statefulValue.value = floatify(v);
      }
    });
    const reset = () => withoutValidation(() => {
      emit2("update:modelValue", props.clearValue);
      emit2("clear");
      resetValidation();
    });
    const {
      computedError,
      computedErrorMessages,
      withoutValidation,
      resetValidation,
      listeners: validationListeners,
      isDirty: isDirty2,
      isTouched
    } = useValidation(props, emit2, { reset, focus, value: valueComputed });
    const setCountInput = ({ target }) => {
      valueComputed.value = Number(target == null ? void 0 : target.value);
    };
    const setCountChange = ({ target }) => {
      calculateCounterValue(Number(target == null ? void 0 : target.value));
    };
    const getRoundDownWithStep = (value) => {
      if (typeof min2.value === "undefined" || !Number(step.value)) {
        return value;
      }
      return toFloat(Number(min2.value) + Number(step.value) * ((Number(value) - Number(min2.value)) / Number(step.value)));
    };
    const calculateCounterValue = (counterValue) => {
      if (typeof min2.value !== "undefined" && counterValue < Number(min2.value)) {
        valueComputed.value = Number(min2.value);
        return;
      }
      if (typeof max2.value !== "undefined" && counterValue > Number(max2.value)) {
        valueComputed.value = getRoundDownWithStep(Number(max2.value));
        return;
      }
      valueComputed.value = getRoundDownWithStep(counterValue);
    };
    const isMinReached = computed(() => {
      if (isNilValue(min2.value)) {
        return false;
      }
      return Number(valueComputed.value) <= Number(min2.value);
    });
    const isMaxReached = computed(() => {
      if (isNilValue(max2.value)) {
        return false;
      }
      return step.value ? Number(valueComputed.value) > Number(max2.value) - Number(step.value) : Number(valueComputed.value) >= Number(max2.value);
    });
    const tabIndexComputed = computed(() => props.disabled ? -1 : 0);
    const isDecreaseActionDisabled = computed(() => isMinReached.value || props.disabled || props.readonly);
    const isIncreaseActionDisabled = computed(() => isMaxReached.value || props.disabled || props.readonly);
    const decreaseCount = () => {
      if (isDecreaseActionDisabled.value) {
        return;
      }
      calculateCounterValue(Number(valueComputed.value) - Number(step.value));
    };
    const increaseCount = () => {
      if (isIncreaseActionDisabled.value) {
        return;
      }
      calculateCounterValue(Number(valueComputed.value) + Number(step.value));
    };
    useLongPress(useTemplateRef("decreaseButtonRef"), {
      onUpdate: decreaseCount,
      delay: longPressDelayComputed
    });
    useLongPress(useTemplateRef("increaseButtonRef"), {
      onUpdate: increaseCount,
      delay: longPressDelayComputed
    });
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const decreaseIconProps = computed(() => ({
      class: { "va-counter__icon--inactive": isDecreaseActionDisabled.value },
      color: colorComputed.value,
      icon: props.decreaseIcon,
      plain: true,
      disabled: isDecreaseActionDisabled.value,
      readonly: props.readonly,
      tabindex: -1,
      "aria-label": tp(props.ariaDecreaseLabel),
      ...!isDecreaseActionDisabled.value && { onClick: decreaseCount }
    }));
    const increaseIconProps = computed(() => ({
      class: { "va-counter__icon--inactive": isIncreaseActionDisabled.value },
      color: colorComputed.value,
      icon: props.increaseIcon,
      plain: true,
      disabled: isIncreaseActionDisabled.value,
      readonly: props.readonly,
      tabindex: -1,
      "aria-label": tp(props.ariaIncreaseLabel),
      ...!isIncreaseActionDisabled.value && { onClick: increaseCount }
    }));
    const isSquareCorners = computed(() => (typeof props.margins === "string" ? parseFloat(props.margins) : props.margins) === 0);
    const buttonsColor = () => {
      if (isFocused.value) {
        return props.color;
      }
      return "background-border";
    };
    const buttonProps = computed(() => ({
      ...pick(props, ["color"]),
      round: props.rounded,
      preset: props.flat ? "secondary" : "",
      borderColor: props.flat ? buttonsColor() : ""
    }));
    const decreaseButtonProps = computed(() => ({
      ...buttonProps.value,
      icon: props.decreaseIcon,
      disabled: isDecreaseActionDisabled.value,
      "aria-label": tp(props.ariaDecreaseLabel),
      ...!isDecreaseActionDisabled.value && { onClick: decreaseCount }
    }));
    const increaseButtonProps = computed(() => ({
      ...buttonProps.value,
      icon: props.increaseIcon,
      disabled: isIncreaseActionDisabled.value,
      "aria-label": tp(props.ariaIncreaseLabel),
      ...!isIncreaseActionDisabled.value && { onClick: increaseCount }
    }));
    const { tp } = useTranslation();
    const attrs = useAttrs();
    const slots = useSlots();
    const inputAttributesComputed = computed(() => ({
      tabindex: tabIndexComputed.value,
      "aria-label": tp(props.ariaLabel),
      "aria-valuemin": Number(min2.value),
      "aria-valuemax": Number(max2.value),
      ...omit(attrs, ["class", "style"]),
      ...pick(props, ["disabled", "min", "max", "step"]),
      readonly: props.readonly || !props.manualInput
    }));
    const classComputed = computed(() => [
      attrs.class,
      { "va-counter--input-square": isSquareCorners.value },
      { "va-counter--content-slot": slots.content && props.buttons }
    ].filter(Boolean));
    const styleComputed = computed(() => ({
      ...attrs.style || {}
    }));
    const marginComputed = computed(() => safeCSSLength(props.margins));
    useCounterPropsValidation(props);
    const fieldListeners = createFieldListeners(emit2);
    const inputListeners = createInputListeners(emit2);
    const inputWrapperPropsComputed = filterComponentProps(VaInputWrapperProps$3);
    __expose({
      isDirty: isDirty2,
      isTouched,
      focus,
      blur,
      decreaseCount,
      increaseCount,
      reset
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaInputWrapper), mergeProps$1({ class: "va-counter" }, { ...unref(fieldListeners), ...unref(inputWrapperPropsComputed), ...unref(validationListeners) }, {
        class: classComputed.value,
        style: styleComputed.value,
        focused: unref(isFocused),
        error: unref(computedError),
        "error-messages": unref(computedErrorMessages),
        onKeydown: [
          withKeys(withModifiers(increaseCount, ["prevent"]), ["up"]),
          withKeys(withModifiers(increaseCount, ["prevent"]), ["right"]),
          withKeys(withModifiers(decreaseCount, ["prevent"]), ["down"]),
          withKeys(withModifiers(decreaseCount, ["prevent"]), ["left"])
        ]
      }), createSlots$1({
        default: withCtx(() => [
          !_ctx.$slots.content ? (openBlock(), createElementBlock("input", mergeProps$1({
            key: 0,
            ref_key: "input",
            ref: input,
            class: "va-input__content__input",
            type: "number",
            inputmode: "decimal"
          }, { ...inputAttributesComputed.value, ...unref(inputListeners) }, {
            value: valueComputed.value,
            "aria-live": _ctx.$props.disabled ? "off" : "polite",
            onInput: setCountInput,
            onChange: setCountChange
          }), null, 16, _hoisted_1$P)) : createCommentVNode("", true)
        ]),
        _: 2
      }, [
        _ctx.$props.buttons ? {
          name: "prepend",
          fn: withCtx((slotScope) => [
            createBaseVNode("div", {
              class: "va-counter__prepend-wrapper",
              style: normalizeStyle({ marginRight: marginComputed.value }),
              onMousedown: _cache[0] || (_cache[0] = withModifiers(
                //@ts-ignore
                (...args) => unref(focus) && unref(focus)(...args),
                ["prevent"]
              ))
            }, [
              renderSlot(_ctx.$slots, "decreaseAction", normalizeProps$1(guardReactiveProps({ ...slotScope, decreaseCount })), () => [
                createVNode(unref(VaButton), mergeProps$1({ class: "va-counter__button-decrease" }, decreaseButtonProps.value, { ref: "decreaseButtonRef" }), null, 16)
              ])
            ], 36)
          ]),
          key: "0"
        } : {
          name: "prependInner",
          fn: withCtx((slotScope) => [
            createBaseVNode("div", {
              class: "va-counter__prepend-inner",
              onMousedown: _cache[1] || (_cache[1] = withModifiers(
                //@ts-ignore
                (...args) => unref(focus) && unref(focus)(...args),
                ["prevent"]
              ))
            }, [
              renderSlot(_ctx.$slots, "decreaseAction", normalizeProps$1(guardReactiveProps({ ...slotScope, decreaseCount })), () => [
                createVNode(unref(VaButton), mergeProps$1(decreaseIconProps.value, { ref: "decreaseButtonRef" }), null, 16)
              ])
            ], 32)
          ]),
          key: "1"
        },
        _ctx.$props.buttons ? {
          name: "append",
          fn: withCtx((slotScope) => [
            createBaseVNode("div", {
              class: "va-counter__append-wrapper",
              style: normalizeStyle({ marginLeft: marginComputed.value }),
              onMousedown: _cache[2] || (_cache[2] = withModifiers(
                //@ts-ignore
                (...args) => unref(focus) && unref(focus)(...args),
                ["prevent"]
              ))
            }, [
              renderSlot(_ctx.$slots, "increaseAction", normalizeProps$1(guardReactiveProps({ ...slotScope, increaseCount })), () => [
                createVNode(unref(VaButton), mergeProps$1({ class: "va-counter__button-increase" }, increaseButtonProps.value, { ref: "increaseButtonRef" }), null, 16)
              ])
            ], 36)
          ]),
          key: "2"
        } : {
          name: "appendInner",
          fn: withCtx((slotScope) => [
            createBaseVNode("div", {
              class: "va-counter__append-inner",
              onMousedown: _cache[3] || (_cache[3] = withModifiers(
                //@ts-ignore
                (...args) => unref(focus) && unref(focus)(...args),
                ["prevent"]
              ))
            }, [
              renderSlot(_ctx.$slots, "increaseAction", normalizeProps$1(guardReactiveProps({ ...slotScope, increaseCount })), () => [
                createVNode(unref(VaButton), mergeProps$1(increaseIconProps.value, { ref: "increaseButtonRef" }), null, 16)
              ])
            ], 32)
          ]),
          key: "3"
        },
        _ctx.$slots.content ? {
          name: "default",
          fn: withCtx((slotScope) => [
            createBaseVNode("div", {
              ref_key: "input",
              ref: input,
              tabindex: "0",
              class: "va-counter__content-wrapper"
            }, [
              renderSlot(_ctx.$slots, "content", normalizeProps$1(guardReactiveProps({ ...slotScope, value: Number(valueComputed.value) })))
            ], 512)
          ]),
          key: "4"
        } : void 0
      ]), 1040, ["class", "style", "focused", "error", "error-messages", "onKeydown"]);
    };
  }
});
const VaCounter = withConfigTransport$1(_sfc_main$1f);
const useCurrentPageProp = { currentPage: { type: Number } };
const createItemsProp = () => ({
  items: { type: Array, default: () => [] }
});
const useSelectableProp = { selectable: { type: Boolean, default: false } };
const useItemsTrackByProp = { itemsTrackBy: { type: [String, Function], default: "" } };
const sortingOptionsValidator = (options) => {
  const isAllowedOptionsLength = options.length === 2 || options.length === 3;
  const isAvailableOptions = options.every((option) => ["asc", "desc", null].includes(option));
  const isUniqueOptions = options.length === new Set(options).size;
  return isAllowedOptionsLength && isAvailableOptions && isUniqueOptions;
};
const useColumnsProps = {
  ...createItemsProp(),
  columns: { type: Array, default: () => [] },
  sortingOptions: {
    type: Array,
    default: () => ["asc", "desc", null],
    validator: sortingOptionsValidator
  }
};
const buildTableColumn = (source, initialIndex, props) => {
  const input = typeof source === "string" ? { key: source } : source;
  const isValidOptions = input.sortingOptions ? sortingOptionsValidator(input.sortingOptions) : true;
  if (!isValidOptions) {
    warn(`The "sortingOptions" array in the column with "${input.key}" key is invalid. For this column, the "sortingOptions" value is taken as for the table: ${JSON.stringify(props.sortingOptions)}.`);
  }
  return {
    source,
    initialIndex,
    key: input.key,
    name: input.name || input.key,
    label: input.label || startCase(input.key),
    thTitle: input.thTitle || input.headerTitle || input.label || startCase(input.key),
    sortable: input.sortable || false,
    sortingFn: input.sortingFn,
    displayFormatFn: input.displayFormatFn,
    sortingOptions: isValidOptions && input.sortingOptions || props.sortingOptions,
    thAlign: input.thAlign || input.alignHead || "left",
    thVerticalAlign: input.thVerticalAlign || input.verticalAlignHead || "middle",
    tdAlign: input.tdAlign || input.align || "left",
    tdVerticalAlign: input.tdVerticalAlign || input.verticalAlign || "middle",
    width: input.width,
    tdClass: input.tdClass || input.classes,
    thClass: input.thClass || input.headerClasses,
    tdStyle: input.tdStyle || input.style,
    thStyle: input.thStyle || input.headerStyle
  };
};
const buildColumnsFromItems = (props) => {
  return Object.keys(mergeDeepMultiple({}, ...props.items)).map((item, index) => buildTableColumn(item, index, props));
};
const buildNormalizedColumns = (props) => {
  return props.columns.map((item, index) => buildTableColumn(item, index, props));
};
const useColumns = (props) => {
  const columnsComputed = computed(() => {
    if (props.columns.length === 0) {
      return buildColumnsFromItems(props);
    } else {
      return buildNormalizedColumns(props);
    }
  });
  return {
    columnsComputed
  };
};
const useThrottleProps = {
  delay: {
    type: Number,
    default: 0,
    validator: (value) => value >= 0
  }
};
function useThrottleFunction(fn, props) {
  const delay = toRef(props, "delay") ?? 0;
  const isThrottled = ref(true);
  let lastCallResult = void 0;
  return function(...args) {
    const invoke = () => fn.apply(this, args);
    if (!unref(delay)) {
      return invoke();
    }
    if (isThrottled.value) {
      isThrottled.value = false;
      setTimeout(() => isThrottled.value = true, unref(delay));
      lastCallResult = invoke();
    }
    return lastCallResult;
  };
}
function useThrottleValue(value, props) {
  const delay = toRef(props, "delay") ?? 0;
  if (!unref(delay)) {
    return value;
  }
  const isThrottled = ref(true);
  const previousCallValue = ref();
  const previousReturnedValue = ref();
  const currentCallValue = ref();
  watch(value, () => {
    previousCallValue.value = value.value;
    const lastCallValue = setTimeout(() => {
      currentCallValue.value = previousCallValue.value;
    }, unref(delay));
    if (isThrottled.value) {
      isThrottled.value = false;
      currentCallValue.value = value.value;
      previousReturnedValue.value = value.value;
      clearTimeout(lastCallValue);
      setTimeout(() => isThrottled.value = true, unref(delay));
    } else {
      currentCallValue.value = previousReturnedValue.value;
    }
  }, { immediate: true });
  return currentCallValue;
}
const usePaginatedRowsProps = {
  ...useThrottleProps,
  ...useCurrentPageProp,
  perPage: { type: Number }
};
const usePaginatedRows = (sortedRows, props) => {
  const paginatedRows = computed(() => {
    if (!props.perPage || props.perPage < 0) {
      return sortedRows.value;
    }
    if (!props.currentPage || props.currentPage < 0) {
      return sortedRows.value.slice(0, props.perPage);
    }
    const pageStartIndex = props.perPage * (props.currentPage - 1);
    return sortedRows.value.slice(pageStartIndex, pageStartIndex + props.perPage);
  });
  const paginatedRowsThrottled = useThrottleValue(paginatedRows, props);
  return {
    paginatedRows: paginatedRowsThrottled
  };
};
const getItemKey = (source, itemsTrackBy) => typeof itemsTrackBy === "function" ? itemsTrackBy(source) : getValueByPath(source, itemsTrackBy) || source;
const createRowsProps = () => ({
  ...createItemsProp(),
  ...useItemsTrackByProp
});
const buildTableCell = (rowIndex, rowKey, rowData, column) => {
  var _a2;
  const source = getValueByPath(rowData, column.key);
  return {
    rowIndex,
    rowKey,
    rowData,
    column,
    source,
    value: ((_a2 = source == null ? void 0 : source.toString) == null ? void 0 : _a2.call(source)) || ""
  };
};
const buildTableRow = (source, initialIndex, itemsTrackBy, columns) => {
  const itemKey = getItemKey(source, itemsTrackBy);
  return {
    initialIndex,
    itemKey,
    source,
    cells: columns.map((column) => buildTableCell(initialIndex, itemKey, source, column)),
    rowData: source
  };
};
const useRows = (columns, props) => {
  const expandableRows = ref({});
  const rowsComputed = computed(() => props.items.map((rawItem, index) => ({
    ...buildTableRow(rawItem, index, props.itemsTrackBy, columns.value),
    toggleRowDetails: (show) => {
      if (typeof show === "boolean") {
        expandableRows.value[index] = show;
      } else {
        expandableRows.value[index] = !expandableRows.value[index];
      }
    },
    isExpandableRowVisible: !!expandableRows.value[index]
  })));
  return {
    rowsComputed
  };
};
const useSelectableProps = {
  ...useSelectableProp,
  ...useItemsTrackByProp,
  modelValue: { type: Array },
  selectMode: { type: String, default: "multiple" }
};
const useSelectableRow = (paginatedRows, props, emit2) => {
  const selectedItemsFallback = ref([]);
  const selectedItemsSync = computed({
    get() {
      if (props.modelValue === void 0) {
        return selectedItemsFallback.value;
      } else {
        return props.modelValue;
      }
    },
    set(modelValue) {
      if (props.modelValue === void 0) {
        selectedItemsFallback.value = modelValue;
      }
      emit2("update:modelValue", modelValue);
    }
  });
  const prevSelectedRowIndex = ref(-1);
  watch(() => props.selectMode, (newSelectMode, oldSelectMode) => {
    if (newSelectMode === "single" && oldSelectMode === "multiple") {
      selectedItemsSync.value = [];
      setPrevSelectedRowIndex(-1);
    }
  });
  watch(paginatedRows, () => {
    setPrevSelectedRowIndex(-1);
  });
  watch(selectedItemsSync, (currentSelectedItems, previousSelectedItems = []) => {
    emit2("selectionChange", {
      currentSelectedItems,
      previousSelectedItems
    });
  }, { immediate: true });
  const getKey = (source) => getItemKey(source, props.itemsTrackBy);
  const noRowsSelected = computed(() => !paginatedRows.value.some(({ source }) => selectedItemsSync.value.includes(getKey(source))));
  const allRowsSelected = computed(() => {
    if (paginatedRows.value.length === 0) {
      return false;
    }
    return paginatedRows.value.every(({ source }) => selectedItemsSync.value.includes(getKey(source)));
  });
  const severalRowsSelected = computed(() => !noRowsSelected.value && !allRowsSelected.value);
  function isRowSelected(row) {
    return selectedItemsSync.value.includes(getKey(row.source));
  }
  function selectAllRows() {
    selectedItemsSync.value = [.../* @__PURE__ */ new Set([
      ...selectedItemsSync.value,
      ...paginatedRows.value.map((row) => getKey(row.source))
    ])];
  }
  function unselectAllRows() {
    const paginatedRowsKeys = paginatedRows.value.map((row) => getKey(row.source));
    selectedItemsSync.value = selectedItemsSync.value.filter((item) => !paginatedRowsKeys.includes(item));
  }
  function selectRow(row) {
    selectedItemsSync.value = [...selectedItemsSync.value, getKey(row.source)];
  }
  function selectOnlyRow(row) {
    selectedItemsSync.value = [getKey(row.source)];
  }
  function unselectRow(row) {
    const index = selectedItemsSync.value.findIndex((item) => item === getKey(row.source));
    selectedItemsSync.value = [
      ...selectedItemsSync.value.slice(0, index),
      ...selectedItemsSync.value.slice(index + 1)
    ];
  }
  function setPrevSelectedRowIndex(rowInitialIndex) {
    if (rowInitialIndex === -1) {
      prevSelectedRowIndex.value = -1;
    } else {
      const prevSelectedRow = paginatedRows.value.find((row) => row.initialIndex === rowInitialIndex);
      prevSelectedRow ? prevSelectedRowIndex.value = paginatedRows.value.indexOf(prevSelectedRow) : prevSelectedRowIndex.value = -1;
    }
  }
  function getRowsToSelect(targetIndex) {
    let start;
    let end;
    if (isRowSelected(paginatedRows.value[prevSelectedRowIndex.value])) {
      start = Math.min(prevSelectedRowIndex.value, targetIndex);
      end = Math.max(prevSelectedRowIndex.value, targetIndex);
    } else {
      start = Math.min(prevSelectedRowIndex.value + 1, targetIndex);
      end = Math.max(prevSelectedRowIndex.value - 1, targetIndex);
    }
    return paginatedRows.value.slice(start, end + 1);
  }
  function mergeSelection(rowsToSelect) {
    const rowsToSelectedItems = rowsToSelect.map((row) => getKey(row.source));
    if (noRowsSelected.value) {
      selectedItemsSync.value = rowsToSelectedItems;
      return;
    }
    const isInternalSelection = rowsToSelectedItems.every((item) => selectedItemsSync.value.includes(item));
    if (isInternalSelection) {
      selectedItemsSync.value = selectedItemsSync.value.filter((item) => !rowsToSelectedItems.includes(item));
      return;
    }
    selectedItemsSync.value = [.../* @__PURE__ */ new Set([
      ...selectedItemsSync.value,
      ...rowsToSelectedItems
    ])];
  }
  function toggleRowSelection(row) {
    if (!props.selectable) {
      return;
    }
    if (isRowSelected(row)) {
      unselectRow(row);
      props.selectMode === "single" ? setPrevSelectedRowIndex(-1) : setPrevSelectedRowIndex(row.initialIndex);
    } else {
      props.selectMode === "single" ? selectOnlyRow(row) : selectRow(row);
      setPrevSelectedRowIndex(row.initialIndex);
    }
  }
  function ctrlSelectRow(row) {
    if (!props.selectable) {
      return;
    }
    toggleRowSelection(row);
  }
  function shiftSelectRows(row) {
    if (!props.selectable) {
      return;
    }
    if (props.selectMode === "single" || prevSelectedRowIndex.value === -1) {
      return toggleRowSelection(row);
    }
    const targetIndex = paginatedRows.value.indexOf(row);
    mergeSelection(getRowsToSelect(targetIndex));
    setPrevSelectedRowIndex(-1);
  }
  function toggleBulkSelection() {
    if (allRowsSelected.value) {
      unselectAllRows();
    } else {
      selectAllRows();
    }
    setPrevSelectedRowIndex(-1);
  }
  return {
    ctrlSelectRow,
    shiftSelectRows,
    toggleRowSelection,
    toggleBulkSelection,
    isRowSelected,
    noRowsSelected,
    severalRowsSelected,
    allRowsSelected
  };
};
const prefix = "--va-data-table";
const isFunction$1 = (val) => typeof val === "function";
const useStylableProps = {
  ...useSelectableProp,
  selectedColor: { type: String, default: "primary" },
  allowFooterSorting: { type: Boolean, default: false },
  stickyHeader: { type: Boolean, default: false },
  stickyFooter: { type: Boolean, default: false },
  height: { type: [String, Number] }
};
const getClass = (classes) => isFunction$1(classes) ? classes() : classes;
const getStyle = (styles) => isFunction$1(styles) ? styles() : styles;
const useStylable = (props) => {
  const { getColor, getFocusColor: getFocusColor2, getHoverColor: getHoverColor2 } = useColors();
  const color = computed(() => getColor(props.selectedColor));
  const CSSVariables = computed(() => ({
    hoverColor: getHoverColor2(color.value),
    selectedColor: props.selectable ? getFocusColor2(color.value) : void 0,
    tableHeight: props.height ? safeCSSLength(props.height) : "var(--va-data-table-height)",
    theadBg: props.stickyHeader ? "var(--va-data-table-thead-background, var(--va-data-table-header-background))" : "var(--va-data-table-thead-background)",
    tfootBg: props.stickyFooter ? "var(--va-data-table-tfoot-background, var(--va-data-table-header-background))" : "var(--va-data-table-tfoot-background)"
  }));
  const getHeaderCSSVariables = (column) => ({
    [`${prefix}-width`]: column.width && safeCSSLength(column.width),
    [`${prefix}-align`]: column.thAlign,
    [`${prefix}-vertical-align`]: column.thVerticalAlign,
    [`${prefix}-cursor`]: column.sortable ? "pointer" : "default"
  });
  const getCellCSSVariables = (cell) => ({
    [`${prefix}-align`]: cell.column.tdAlign,
    [`${prefix}-vertical-align`]: cell.column.tdVerticalAlign
  });
  const getFooterCSSVariables = (column) => ({
    [`${prefix}-align`]: column.thAlign,
    [`${prefix}-vertical-align`]: column.thVerticalAlign,
    [`${prefix}-cursor`]: props.allowFooterSorting && column.sortable ? "pointer" : "default"
  });
  return {
    CSSVariables,
    getHeaderCSSVariables,
    getCellCSSVariables,
    getFooterCSSVariables,
    getClass,
    getStyle
  };
};
const isFunction = (val) => typeof val === "function";
const isObject = (val) => val !== null && typeof val === "object";
const useBindingProps = {
  rowBind: { type: null },
  cellBind: { type: null }
};
const useBinding = (props) => {
  const getRowBind = (row) => isFunction(props.rowBind) ? props.rowBind(row.source, row.initialIndex) : isObject(props.rowBind) ? props.rowBind : {};
  const getCellBind = (cell, row) => isFunction(props.cellBind) ? props.cellBind(cell.source, row.source, cell.column, row.initialIndex) : isObject(props.cellBind) ? props.cellBind : {};
  return {
    getRowBind,
    getCellBind
  };
};
const useAnimationNameProps = {
  ...useCurrentPageProp,
  animated: { type: Boolean, default: true }
};
const useAnimationName = (props, rows) => {
  const animationType = ref("shuffle");
  const animationName = computed(() => props.animated ? `table-transition-${animationType.value}` : "");
  const oldRowsLength = ref(rows.value.length);
  const isDifferentRowLength = computed(() => rows.value.length !== oldRowsLength.value);
  watch(rows, (newRows, oldRows) => {
    const hasRows = !!(newRows.length && oldRows.length);
    animationType.value = newRows.length > 50 || isDifferentRowLength.value && hasRows ? "fade" : "shuffle";
    oldRowsLength.value = newRows.length;
  });
  watch(() => props.currentPage, () => {
    if (!isDifferentRowLength.value) {
      animationType.value = "shuffle";
    }
  });
  return animationName;
};
const useFilterableProps = {
  ...useThrottleProps,
  filter: { type: String, default: "" },
  filterMethod: { type: Function }
};
const useFilterable = (rawRows, props, emit2) => {
  const filteredRows = computed(() => {
    if (!rawRows.value.length) {
      return rawRows.value;
    }
    if (props.filter === "" && !props.filterMethod) {
      return rawRows.value;
    }
    return rawRows.value.filter(
      (row) => row.cells.some((cell) => {
        if (typeof props.filterMethod === "function") {
          return props.filterMethod(cell.source, cell);
        }
        const cellRegex = new RegExp(props.filter, "i");
        return cellRegex.test(cell.value);
      })
    );
  });
  const filteredRowsThrottled = useThrottleValue(filteredRows, props);
  watch(filteredRowsThrottled, () => {
    emit2("filtered", {
      items: filteredRowsThrottled.value.map((row) => row.source),
      itemsIndexes: filteredRowsThrottled.value.map((row) => row.initialIndex)
    });
  });
  if (filteredRows.value.length !== rawRows.value.length) {
    emit2("filtered", {
      items: filteredRows.value.map((row) => row.source),
      itemsIndexes: filteredRows.value.map((row) => row.initialIndex)
    });
  }
  return {
    filteredRows: filteredRowsThrottled
  };
};
const useSortableProps = {
  ...useThrottleProps,
  sortBy: { type: String },
  columnSorted: { type: Object },
  sortingOrder: { type: [String, null] },
  disableClientSideSorting: { type: Boolean, default: false }
};
const useSortable = (columns, filteredRows, props, emit2) => {
  const sortByFallback = ref("");
  const sortBySync = computed({
    get() {
      if (props.sortBy === void 0) {
        return sortByFallback.value;
      } else {
        return props.sortBy;
      }
    },
    set(value) {
      if (props.sortBy === void 0) {
        sortByFallback.value = value;
      }
      emit2("update:sortBy", value);
    }
  });
  const sortingOrderFallback = ref(null);
  const sortingOrderSync = computed({
    get() {
      if (props.sortingOrder === void 0) {
        return sortingOrderFallback.value;
      } else {
        return props.sortingOrder;
      }
    },
    set(value) {
      if (props.sortingOrder === void 0) {
        sortingOrderFallback.value = value;
      }
      emit2("update:sortingOrder", value);
    }
  });
  const defaultSortingFn = (a, b) => {
    if (typeof a === "string" && typeof b === "string") {
      return a.localeCompare(b);
    }
    if (typeof a === "number" && typeof b === "number") {
      return a - b;
    }
    const aParsed = parseFloat(a);
    const bParsed = parseFloat(b);
    if (!isNaN(aParsed) && !isNaN(bParsed)) {
      return aParsed - bParsed;
    }
    if (!isNaN(aParsed)) {
      return -1;
    }
    if (!isNaN(bParsed)) {
      return 1;
    }
    return 0;
  };
  const sortedRows = computed(() => {
    if (props.disableClientSideSorting) {
      return filteredRows.value;
    }
    if (filteredRows.value.length <= 1) {
      return filteredRows.value;
    }
    const columnIndex = columns.value.findIndex(
      ({ name, sortable }) => sortBySync.value === name && sortable
    );
    const column = columns.value[columnIndex];
    if (!column) {
      return filteredRows.value;
    }
    const sortingOrderRatio = sortingOrderSync.value === "desc" ? -1 : 1;
    return [...filteredRows.value].sort((a, b) => {
      if (sortingOrderSync.value === null) {
        return a.initialIndex - b.initialIndex;
      } else {
        const firstSource = a.cells[columnIndex].source;
        const secondSource = b.cells[columnIndex].source;
        return sortingOrderRatio * (typeof column.sortingFn === "function" ? column.sortingFn(firstSource, secondSource) : defaultSortingFn(firstSource, secondSource));
      }
    });
  });
  watch(sortedRows, () => {
    emit2("sorted", {
      sortBy: sortBySync.value,
      sortingOrder: sortingOrderSync.value,
      items: sortedRows.value.map((row) => row.source),
      itemsIndexes: sortedRows.value.map((row) => row.initialIndex)
    });
  });
  const getNextSortingOptionsValue = (value, options) => {
    const index = options.findIndex((sortingValue) => sortingValue === value);
    return index !== -1 ? options[(index + 1) % options.length] : options[0];
  };
  function toggleSorting(column) {
    let value;
    if (column.name === sortBySync.value) {
      value = getNextSortingOptionsValue(sortingOrderSync.value, column.sortingOptions);
    } else {
      sortBySync.value = column.name;
      value = column.sortingOptions[0];
    }
    sortingOrderSync.value = value;
    emit2("columnSorted", { columnName: column.name, value, column });
  }
  const toggleSortingThrottled = useThrottleFunction(toggleSorting, props);
  const sortingOrderIconName = computed(() => {
    return sortingOrderSync.value === "asc" ? "va-sort-asc" : sortingOrderSync.value === "desc" ? "va-sort-desc" : "va-unsorted";
  });
  return {
    sortBySync,
    sortingOrderSync,
    toggleSorting: toggleSortingThrottled,
    sortedRows,
    sortingOrderIconName
  };
};
const unrefElement = (el) => {
  const e = unref(el);
  return unwrapEl(e);
};
const useElementRef = () => {
  const el = shallowRef();
  return computed({
    get() {
      return unrefElement(el);
    },
    set(node) {
      el.value = node;
    }
  });
};
const useTableScrollProps = {
  scrollTopMargin: { type: [Number, String], default: 0 },
  scrollBottomMargin: { type: [Number, String], default: 0 }
};
const useTableScrollEmits = ["scroll:top", "scroll:bottom"];
const useTableScroll = (props, emit2) => {
  var _a2;
  const vNodeProps = (_a2 = getCurrentInstance()) == null ? void 0 : _a2.vnode.props;
  const doRenderTopTrigger = (vNodeProps == null ? void 0 : vNodeProps["onScroll:top"]) !== void 0;
  const doRenderBottomTrigger = (vNodeProps == null ? void 0 : vNodeProps["onScroll:bottom"]) !== void 0;
  const scrollContainer = useElementRef();
  const topTrigger = useElementRef();
  const bottomTrigger = useElementRef();
  const scrollTopMarginComputed = useNumericProp("scrollTopMargin");
  const scrollBottomMarginComputed = useNumericProp("scrollBottomMargin");
  const isObservable = computed(() => !!scrollContainer.value);
  const intersectionHandler = (entries) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        entry.target === topTrigger.value ? emit2("scroll:top") : emit2("scroll:bottom");
      }
    });
  };
  const targets = computed(() => {
    const list = [];
    if (isObservable.value) {
      topTrigger.value && list.push(topTrigger.value);
      bottomTrigger.value && list.push(bottomTrigger.value);
    }
    return list;
  });
  const options = computed(() => ({
    root: scrollContainer.value,
    rootMargin: `${scrollTopMarginComputed.value ?? 0}px 0px ${scrollBottomMarginComputed.value ?? 0}px 0px`
  }));
  useIntersectionObserver(intersectionHandler, options, targets);
  return {
    scrollContainer,
    topTrigger,
    bottomTrigger,
    doRenderTopTrigger,
    doRenderBottomTrigger
  };
};
const _hoisted_1$O = { class: "va-data-table__table-tr" };
const _hoisted_2$o = {
  key: 0,
  scope: "col",
  class: "va-data-table__table-th va-data-table__table-cell-select"
};
const _hoisted_3$h = ["title", "onClick", "onKeydown"];
const _hoisted_4$9 = { class: "va-data-table__table-th-wrapper" };
const _hoisted_5$6 = { key: 0 };
const _sfc_main$1e = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaDataTableThRow"
  },
  __name: "VaDataTableThRow",
  props: {
    ...useStylableProps,
    selectMode: { type: String, default: "multiple" },
    allRowsSelected: { type: Boolean, default: false },
    severalRowsSelected: { type: Boolean, default: false },
    columns: { type: Array, required: true },
    isFooter: { type: Boolean, default: false },
    sortBySync: { type: String, required: true },
    sortingOrderIconName: { type: String, required: true },
    sortingOrderSync: { type: String, default: null },
    ariaSelectAllRowsLabel: useTranslationProp("$t:selectAllRows"),
    ariaSortColumnByLabel: useTranslationProp("$t:sortColumnBy")
  },
  emits: [
    "toggleBulkSelection",
    "toggleSorting"
  ],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const { tp } = useTranslation();
    const {
      getFooterCSSVariables,
      getHeaderCSSVariables,
      getClass: getClass2,
      getStyle: getStyle2
    } = useStylable(props);
    const getAriaAttributes = (column) => {
      const ariaSort = props.sortingOrderSync && props.sortBySync === column.name ? props.sortingOrderSync === "asc" ? "ascending" : "descending" : "none";
      const ariaLabel = column.sortable ? tp(props.ariaSortColumnByLabel, { name: column.label }) : void 0;
      return {
        "aria-sort": ariaSort,
        "aria-label": ariaLabel
      };
    };
    const sortByColumn = (column) => {
      if (props.isFooter && !props.allowFooterSorting || !column.sortable) {
        return;
      }
      emit2("toggleSorting", column);
    };
    const toggleBulkSelection = () => emit2("toggleBulkSelection");
    const getColumnStyles = (column) => {
      return [
        column.width ? { minWidth: column.width, maxWidth: column.width } : {},
        props.isFooter ? getFooterCSSVariables(column) : getHeaderCSSVariables(column),
        getStyle2(column.thStyle)
      ];
    };
    const slotNameComputed = computed(() => props.isFooter ? "footer" : "header");
    const multiplySelectAvailable = computed(() => props.selectMode === "multiple");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("tr", _hoisted_1$O, [
        _ctx.$props.selectable ? (openBlock(), createElementBlock("th", _hoisted_2$o, [
          multiplySelectAvailable.value ? (openBlock(), createBlock(unref(VaCheckbox), {
            key: 0,
            class: "va-data-table__table-cell-checkbox",
            "model-value": _ctx.$props.severalRowsSelected ? "idl" : _ctx.$props.allRowsSelected,
            "aria-label": unref(tp)(_ctx.$props.ariaSelectAllRowsLabel),
            "true-value": true,
            "false-value": false,
            color: _ctx.$props.selectedColor,
            "indeterminate-value": "idl",
            indeterminate: "",
            "onUpdate:modelValue": toggleBulkSelection
          }, null, 8, ["model-value", "aria-label", "color"])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true),
        (openBlock(true), createElementBlock(Fragment, null, renderList(__props.columns, (column) => {
          return openBlock(), createElementBlock("th", mergeProps$1({
            key: column.name,
            scope: "col",
            class: ["va-data-table__table-th", unref(getClass2)(column.thClass)],
            title: column.thTitle,
            style: getColumnStyles(column)
          }, getAriaAttributes(column), {
            onClick: withModifiers(($event) => sortByColumn(column), ["exact"]),
            onKeydown: withKeys(withModifiers(($event) => sortByColumn(column), ["stop"]), ["enter"])
          }), [
            createBaseVNode("div", _hoisted_4$9, [
              `${slotNameComputed.value}(${column.name})` in _ctx.$slots ? (openBlock(), createElementBlock("span", _hoisted_5$6, [
                renderSlot(_ctx.$slots, `${slotNameComputed.value}(${column.name})`, normalizeProps$1(guardReactiveProps({ label: column.label, key: column.key })))
              ])) : renderSlot(_ctx.$slots, slotNameComputed.value, normalizeProps$1(mergeProps$1({ key: 1 }, { label: column.label, key: column.key })), () => [
                createBaseVNode("span", null, toDisplayString(column.label), 1)
              ]),
              column.sortable ? (openBlock(), createBlock(unref(VaIcon), {
                key: 2,
                class: normalizeClass(["va-data-table__table-th-sorting-icon", { active: __props.sortBySync === column.name && __props.sortingOrderSync !== null }]),
                size: "small",
                role: column.sortable ? "button" : void 0,
                tabindex: column.sortable ? 0 : -1,
                name: __props.sortingOrderIconName,
                onSelectstart: withModifiers(() => {
                }, ["prevent"])
              }, null, 8, ["class", "role", "tabindex", "name"])) : createCommentVNode("", true)
            ])
          ], 16, _hoisted_3$h);
        }), 128))
      ]);
    };
  }
});
const VaDataTableThRow = withConfigTransport$1(_sfc_main$1e);
const { isParsablePositiveMeasure, parseSizeValue } = useParsableMeasure();
const validateSizeProp = (v, propName) => {
  const isProperValue = isParsablePositiveMeasure(v);
  !isProperValue && warn(`[va-virtual-scroller] ${propName} should be number or parsable int greater or equal to 0. Provided: ${v}.`);
  return isProperValue;
};
const useVirtualScrollerSizesProps = {
  horizontal: { type: Boolean, default: false },
  itemSize: {
    type: [Number, String],
    default: 0,
    validator: (v) => {
      return validateSizeProp(v, "itemSize");
    }
  },
  wrapperSize: {
    type: [Number, String],
    default: 100,
    validator: (v) => {
      return v === "auto" || validateSizeProp(v, "wrapperSize");
    }
  }
};
const useVirtualScrollerSizes = (props, scrollPosition) => {
  const list = shallowRef();
  const wrapper = shallowRef();
  const clientSizeMeasure = computed(() => props.horizontal ? "clientWidth" : "clientHeight");
  const wrapperSize = computed(() => {
    var _a2;
    if (props.wrapperSize === "auto") {
      return ((_a2 = wrapper.value) == null ? void 0 : _a2[clientSizeMeasure.value]) || 0;
    }
    return parseSizeValue(props.wrapperSize, pageFontSize);
  });
  const pageFontSize = ref(16);
  const handleWindowResize = () => {
    pageFontSize.value = parseFloat(getComputedStyle(document.documentElement).fontSize);
    calcAverageItemsSize();
  };
  useEvent("resize", handleWindowResize, true);
  const itemSizeCalculated = ref(0);
  const calcAverageItemsSize = () => {
    if (!list.value) {
      return;
    }
    const sizes = [];
    const itemsList = list.value.children;
    const itemsAmount = itemsList.length;
    for (let i = 0; i < itemsAmount; i++) {
      const currentChild = list.value.children.item(i);
      currentChild && sizes.push(currentChild[clientSizeMeasure.value]);
    }
    itemSizeCalculated.value = itemsAmount ? Math.trunc(sizes.reduce((acc, el) => acc + el, 0) / (itemsAmount - 1)) : 0;
  };
  const instance = getCurrentInstance();
  onMounted(() => {
    var _a2, _b;
    if (!list.value) {
      list.value = (_b = (_a2 = instance == null ? void 0 : instance.parent) == null ? void 0 : _a2.refs) == null ? void 0 : _b.list;
    }
    calcAverageItemsSize();
  });
  watch(scrollPosition, calcAverageItemsSize);
  watch(wrapperSize, calcAverageItemsSize);
  let oldItemSize = 0;
  const itemSize = computed(() => {
    const sizeParsed = parseSizeValue(props.itemSize, pageFontSize);
    const result = Math.max(sizeParsed, itemSizeCalculated.value, 1);
    const diff = Math.abs(oldItemSize / result * 100 - 100);
    if (diff > 5 || oldItemSize === 0) {
      oldItemSize = result;
      return result;
    }
    return oldItemSize;
  });
  return { list, wrapper, itemSize, wrapperSize };
};
const useTrackByProps = {
  trackBy: {
    type: [String, Number, Function],
    default: ""
  }
};
const useTrackBy = (props) => {
  const getKey = (item, index, defaultValue) => {
    if (props.trackBy && item && typeof item === "object" && !isFunction$2(props.trackBy)) {
      const isArrayItem = Array.isArray(item);
      let key;
      if (isArrayItem && !isNaN(+props.trackBy)) {
        key = item[+props.trackBy];
      }
      if (!isArrayItem) {
        key = item[props.trackBy];
      }
      if (key || key === 0) {
        return key;
      }
      warn(`${isArrayItem ? "Index" : "Key"} '${props.trackBy}' wasn't found in provided ${isArrayItem ? "array" : "object"}: `, item);
    }
    if (isFunction$2(props.trackBy)) {
      return props.trackBy(item);
    }
    return defaultValue;
  };
  return { getKey };
};
const _sfc_main$1d = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaVirtualScroller"
  },
  __name: "VaVirtualScroller",
  props: {
    ...useTrackByProps,
    ...useVirtualScrollerSizesProps,
    items: { type: Array, default: () => [] },
    bench: { type: [Number, String], default: 10, validator: (v) => Number(v) >= 0 },
    disabled: { type: Boolean, default: false },
    table: { type: Boolean, default: false }
  },
  emits: ["scroll:bottom"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const listScrollPosition = ref(0);
    const benchComputed = useNumericProp("bench");
    const scrollDirection = computed(() => props.horizontal ? "scrollLeft" : "scrollTop");
    const handleScroll = () => {
      if (!wrapper.value) {
        return;
      }
      listScrollPosition.value = wrapper.value[scrollDirection.value];
    };
    if (!props.disabled) {
      useEvent("scroll", handleScroll, true);
    }
    const { list, wrapper, itemSize, wrapperSize } = useVirtualScrollerSizes(props, listScrollPosition);
    const { getKey } = useTrackBy(props);
    const uniqueKey = (item, index, defaultValue) => getKey(item, index, defaultValue);
    watch(listScrollPosition, (newValue) => {
      if (newValue + wrapperSize.value === containerSize.value) {
        emit2("scroll:bottom");
      }
    });
    const renderStartIndex = computed(() => {
      return Math.max(0, Math.floor(listScrollPosition.value / itemSize.value) - benchComputed.value);
    });
    const renderItemsAmount = computed(() => {
      var _a2;
      if (!((_a2 = props.items) == null ? void 0 : _a2.length)) {
        return 0;
      }
      return props.disabled ? props.items.length : Math.min(props.items.length - renderStartIndex.value, Math.ceil(wrapperSize.value / itemSize.value) + benchComputed.value * 2);
    });
    const renderEndIndex = computed(() => renderStartIndex.value + renderItemsAmount.value);
    const renderBuffer = computed(() => {
      var _a2;
      if (!((_a2 = props.items) == null ? void 0 : _a2.length)) {
        return [];
      }
      return props.items.slice(renderStartIndex.value, renderEndIndex.value);
    });
    const sizeAttribute = computed(() => props.horizontal ? "width" : "height");
    const isDisabledVirtualTable = computed(() => props.table && props.disabled);
    const wrapperStyleComputed = computed(() => ({
      [sizeAttribute.value]: isDisabledVirtualTable.value || !wrapperSize.value ? void 0 : `${wrapperSize.value}px`
    }));
    const wrapperClassComputed = useBem("va-virtual-scroller", () => ({
      ...pick(props, ["horizontal"])
    }));
    const containerSize = computed(() => {
      var _a2;
      return (((_a2 = props.items) == null ? void 0 : _a2.length) ?? 0) * itemSize.value;
    });
    const containerStyleComputed = computed(() => ({
      [sizeAttribute.value]: isDisabledVirtualTable.value ? void 0 : `${containerSize.value}px`
    }));
    const currentListOffset = computed(() => renderStartIndex.value * itemSize.value);
    const listStyleComputed = computed(() => ({
      transform: `translate${props.horizontal ? "X" : "Y"}(${currentListOffset.value}px)`
    }));
    const scrollToAttribute = computed(() => props.horizontal ? "left" : "top");
    const virtualScrollTo = (index) => {
      var _a2;
      if (!index && index !== 0) {
        return;
      }
      (_a2 = wrapper.value) == null ? void 0 : _a2.scrollTo({ [scrollToAttribute.value]: index * itemSize.value });
    };
    __expose({
      scrollToAttribute,
      virtualScrollTo
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "wrapper",
        ref: wrapper,
        class: normalizeClass(["va-virtual-scroller", unref(wrapperClassComputed)]),
        style: normalizeStyle(wrapperStyleComputed.value)
      }, [
        renderSlot(_ctx.$slots, "content", normalizeProps$1(guardReactiveProps({ containerStyleComputed: containerStyleComputed.value, listStyleComputed: listStyleComputed.value, renderBuffer: renderBuffer.value, uniqueKey, currentListOffset: currentListOffset.value })), () => [
          createBaseVNode("div", {
            class: "va-virtual-scroller__container",
            style: normalizeStyle(containerStyleComputed.value)
          }, [
            createBaseVNode("div", {
              ref_key: "list",
              ref: list,
              role: "list",
              class: "va-virtual-scroller__list",
              style: normalizeStyle(listStyleComputed.value)
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(renderBuffer.value, (item, index) => {
                return renderSlot(_ctx.$slots, "default", normalizeProps$1(mergeProps$1({
                  key: uniqueKey(item, index)
                }, { item, index: renderStartIndex.value + index })));
              }), 128))
            ], 4)
          ], 4)
        ])
      ], 6);
    };
  }
});
const VaVirtualScroller = withConfigTransport$1(_sfc_main$1d);
const _hoisted_1$N = {
  key: 0,
  class: "va-inner-loading__overlay",
  "aria-hidden": "true"
};
const _sfc_main$1c = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaInnerLoading"
  },
  __name: "VaInnerLoading",
  props: {
    ...useLoadingProps,
    ...useComponentPresetProp,
    color: { type: String },
    icon: { type: String, default: "va-loading" },
    size: { type: [Number, String], default: 30 }
  },
  setup(__props) {
    const props = __props;
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const computedClass = computed(() => ({
      "va-inner-loading--active": props.loading
    }));
    const ariaAttributesComputed = computed(() => ({
      "aria-busy": props.loading
    }));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", mergeProps$1({
        class: ["va-inner-loading", computedClass.value],
        "aria-live": "polite"
      }, ariaAttributesComputed.value), [
        renderSlot(_ctx.$slots, "default"),
        _ctx.$props.loading ? (openBlock(), createElementBlock("div", _hoisted_1$N, [
          renderSlot(_ctx.$slots, "loading", {}, () => [
            createVNode(unref(VaIcon), {
              class: "va-inner-loading__spinner",
              spin: "counter-clockwise",
              color: colorComputed.value,
              size: _ctx.$props.size,
              name: _ctx.$props.icon
            }, null, 8, ["color", "size", "name"])
          ])
        ])) : createCommentVNode("", true)
      ], 16);
    };
  }
});
const VaInnerLoading = withConfigTransport$1(_sfc_main$1c);
const _hoisted_1$M = { key: 0 };
const _hoisted_2$n = {
  ref: "list",
  class: "va-data-table__table-tbody"
};
const _hoisted_3$g = {
  key: "showNoDataHtml",
  class: "va-data-table__table-tr"
};
const _hoisted_4$8 = {
  class: "va-data-table__table-td no-data",
  colspan: "99999"
};
const _hoisted_5$5 = ["innerHTML"];
const _hoisted_6$1 = {
  key: "showNoDataFilteredHtml",
  class: "va-data-table__table-tr"
};
const _hoisted_7$1 = {
  class: "va-data-table__table-td no-data",
  colspan: "99999"
};
const _hoisted_8$1 = ["innerHTML"];
const _hoisted_9 = ["onClick", "onDblclick", "onContextmenu"];
const _hoisted_10 = {
  key: 0,
  class: "va-data-table__grid-column-header"
};
const _hoisted_11 = {
  key: 0,
  class: "va-data-table__table-tr"
};
const VaVirtualScrollerProps = extractComponentProps(VaVirtualScroller, ["items", "trackBy", "horizontal", "disabled", "table"]);
const VaDataTableThRowProps = extractComponentProps(VaDataTableThRow);
const _sfc_main$1b = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaDataTable",
    inheritAttrs: false
  },
  __name: "VaDataTable",
  props: {
    ...useComponentPresetProp,
    ...VaVirtualScrollerProps,
    ...useAnimationNameProps,
    ...useBindingProps,
    ...useTableScrollProps,
    ...useSortableProps,
    ...useStylableProps,
    ...useColumnsProps,
    ...useFilterableProps,
    ...usePaginatedRowsProps,
    ...createRowsProps(),
    ...useSelectableProps,
    ...useThrottleProps,
    ...pick(VaDataTableThRowProps, ["ariaSelectAllRowsLabel", "ariaSortColumnByLabel"]),
    hoverable: { type: Boolean, default: false },
    clickable: { type: Boolean, default: false },
    loading: { type: Boolean, default: false },
    loadingColor: { type: String, default: "primary" },
    noDataHtml: { type: String, default: "No items" },
    noDataFilteredHtml: { type: String, default: "No items match the provided filtering condition" },
    hideDefaultHeader: { type: Boolean, default: false },
    footerClone: { type: Boolean, default: false },
    striped: { type: Boolean, default: false },
    virtualScroller: { type: Boolean, default: false },
    virtualTrackBy: { type: [String, Number], default: "initialIndex" },
    grid: { type: Boolean, default: false },
    gridColumns: { type: [Number, String], default: 0 },
    wrapperSize: { type: [Number, String], default: "auto" },
    ariaSelectRowLabel: useTranslationProp("$t:selectRowByIndex")
  },
  emits: [
    "update:modelValue",
    // `modelValue` is selectedItems
    "update:sortBy",
    "update:sortingOrder",
    "filtered",
    "sorted",
    "selectionChange",
    "row:click",
    "row:dblclick",
    "row:contextmenu",
    "columnSorted",
    ...useTableScrollEmits
  ],
  setup(__props, { emit: __emit }) {
    const { tp } = useTranslation();
    const props = __props;
    const emit2 = __emit;
    const { columnsComputed } = useColumns(props);
    const { rowsComputed } = useRows(columnsComputed, props);
    const { filteredRows } = useFilterable(rowsComputed, props, emit2);
    const {
      sortBySync,
      sortingOrderSync,
      toggleSorting,
      sortedRows,
      sortingOrderIconName
    } = useSortable(columnsComputed, filteredRows, props, emit2);
    const { paginatedRows } = usePaginatedRows(sortedRows, props);
    const {
      ctrlSelectRow,
      shiftSelectRows,
      toggleBulkSelection,
      isRowSelected,
      severalRowsSelected,
      allRowsSelected,
      toggleRowSelection
    } = useSelectableRow(paginatedRows, props, emit2);
    const {
      CSSVariables,
      getCellCSSVariables,
      getClass: getClass2,
      getStyle: getStyle2
    } = useStylable(props);
    const { getRowBind, getCellBind } = useBinding(props);
    const animationName = useAnimationName(props, paginatedRows);
    const showNoDataHtml = computed(() => props.items.length === 0);
    const showNoDataFilteredHtml = computed(() => paginatedRows.value.length === 0);
    const onRowClickHandler = (name, event, row) => {
      emit2(name, {
        event,
        item: row.source,
        itemIndex: row.initialIndex,
        row
      });
      if (props.selectable && props.grid) {
        toggleRowSelection(row);
      }
    };
    const computedTableAttributes = computed(() => ({
      ...omit(attrs, ["class", "style"]),
      class: pick(props, ["striped", "selectable", "hoverable", "clickable"])
    }));
    const filteredVirtualScrollerProps = filterComponentProps(VaVirtualScrollerProps);
    const virtualScrollerPropsComputed = computed(() => ({
      ...filteredVirtualScrollerProps.value,
      items: paginatedRows.value,
      trackBy: props.virtualTrackBy,
      disabled: !props.virtualScroller,
      table: true
    }));
    const attrs = useAttrs();
    const computedAttributes = computed(() => ({
      class: [
        { "va-data-table--sticky": props.stickyHeader || props.stickyFooter },
        { "va-data-table--scroll": !!props.height },
        { "va-data-table--virtual-scroller": isVirtualScroll.value },
        { "va-data-table--grid": props.grid },
        attrs.class
      ],
      style: [attrs.style],
      ...virtualScrollerPropsComputed.value
    }));
    const filteredThProps = filterComponentProps(VaDataTableThRowProps);
    const thAttributesComputed = computed(() => ({
      ...filteredThProps.value,
      columns: columnsComputed.value,
      sortingOrderIconName: sortingOrderIconName.value,
      severalRowsSelected: severalRowsSelected.value,
      sortingOrderSync: sortingOrderSync.value,
      allRowsSelected: allRowsSelected.value,
      sortBySync: sortBySync.value
    }));
    const {
      scrollContainer,
      topTrigger,
      bottomTrigger,
      doRenderTopTrigger,
      doRenderBottomTrigger
    } = useTableScroll(props, emit2);
    const isVirtualScroll = computed(() => props.virtualScroller && !props.grid);
    const gridColumnsCount = computed(() => props.gridColumns || "var(--va-data-table-grid-tbody-columns)");
    const cellData = (cellData2, internalColumnData) => internalColumnData.displayFormatFn ? internalColumnData.displayFormatFn(cellData2.value) : cellData2.value;
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaVirtualScroller), mergeProps$1({ class: "va-data-table" }, computedAttributes.value, {
        ref_key: "scrollContainer",
        ref: scrollContainer,
        style: `--va-css-variables-selected-color: ${String(unref(CSSVariables).selectedColor)};--va-css-variables-hover-color: ${String(unref(CSSVariables).hoverColor)};--va-css-variables-table-height: ${String(unref(CSSVariables).tableHeight)};--va-css-variables-thead-bg: ${String(unref(CSSVariables).theadBg)};--va-css-variables-tfoot-bg: ${String(unref(CSSVariables).tfootBg)};--va-grid-columns-count: ${String(gridColumnsCount.value)}`
      }), {
        content: withCtx(({
          uniqueKey,
          renderBuffer,
          currentListOffset,
          listStyleComputed,
          containerStyleComputed
        }) => [
          createVNode(unref(VaInnerLoading), {
            "aria-live": "polite",
            style: normalizeStyle(containerStyleComputed),
            loading: __props.loading,
            color: __props.loadingColor
          }, {
            default: withCtx(() => [
              unref(doRenderTopTrigger) ? (openBlock(), createElementBlock("div", {
                key: 0,
                ref_key: "topTrigger",
                ref: topTrigger,
                class: "va-data-table__scroll-trigger"
              }, null, 512)) : createCommentVNode("", true),
              createBaseVNode("table", mergeProps$1({
                class: "va-data-table__table",
                style: listStyleComputed
              }, computedTableAttributes.value), [
                "colgroup" in _ctx.$slots ? (openBlock(), createElementBlock("colgroup", _hoisted_1$M, [
                  renderSlot(_ctx.$slots, "colgroup", normalizeProps$1(guardReactiveProps(unref(columnsComputed))))
                ])) : createCommentVNode("", true),
                createBaseVNode("thead", {
                  class: normalizeClass(["va-data-table__table-thead", { "va-data-table__table-thead--sticky": _ctx.$props.stickyHeader }]),
                  style: normalizeStyle({ top: isVirtualScroll.value && _ctx.$props.stickyHeader ? `-${currentListOffset}px` : void 0 })
                }, [
                  renderSlot(_ctx.$slots, "headerPrepend"),
                  renderSlot(_ctx.$slots, "header", {}, () => [
                    !__props.hideDefaultHeader ? (openBlock(), createBlock(unref(VaDataTableThRow), mergeProps$1({ key: 0 }, thAttributesComputed.value, {
                      onToggleBulkSelection: unref(toggleBulkSelection),
                      onToggleSorting: unref(toggleSorting)
                    }), createSlots$1({ _: 2 }, [
                      renderList(_ctx.$slots, (_, slot) => {
                        return {
                          name: slot,
                          fn: withCtx((scope) => [
                            renderSlot(_ctx.$slots, slot, normalizeProps$1(guardReactiveProps(scope)))
                          ])
                        };
                      })
                    ]), 1040, ["onToggleBulkSelection", "onToggleSorting"])) : createCommentVNode("", true)
                  ]),
                  renderSlot(_ctx.$slots, "headerAppend")
                ], 6),
                createBaseVNode("tbody", _hoisted_2$n, [
                  renderSlot(_ctx.$slots, "bodyPrepend"),
                  createVNode(TransitionGroup, {
                    name: isVirtualScroll.value ? "" : unref(animationName),
                    css: !_ctx.$props.virtualScroller,
                    appear: !_ctx.$props.virtualScroller
                  }, {
                    default: withCtx(() => [
                      showNoDataHtml.value ? (openBlock(), createElementBlock("tr", _hoisted_3$g, [
                        createBaseVNode("td", _hoisted_4$8, [
                          renderSlot(_ctx.$slots, "no-data", {}, () => [
                            createBaseVNode("div", { innerHTML: __props.noDataHtml }, null, 8, _hoisted_5$5)
                          ])
                        ])
                      ])) : showNoDataFilteredHtml.value ? (openBlock(), createElementBlock("tr", _hoisted_6$1, [
                        createBaseVNode("td", _hoisted_7$1, [
                          renderSlot(_ctx.$slots, "no-filtered-data", {}, () => [
                            renderSlot(_ctx.$slots, "no-data", {}, () => [
                              createBaseVNode("div", { innerHTML: __props.noDataFilteredHtml }, null, 8, _hoisted_8$1)
                            ])
                          ])
                        ])
                      ])) : createCommentVNode("", true),
                      (openBlock(true), createElementBlock(Fragment, null, renderList(renderBuffer, (row, index) => {
                        return openBlock(), createElementBlock(Fragment, {
                          key: `table-row_${uniqueKey(row, index)}`
                        }, [
                          createBaseVNode("tr", mergeProps$1({
                            class: ["va-data-table__table-tr", [{ selected: unref(isRowSelected)(row), "va-data-table__table-tr--expanded": row.isExpandableRowVisible }]]
                          }, unref(getRowBind)(row), {
                            onClick: ($event) => onRowClickHandler("row:click", $event, row),
                            onDblclick: ($event) => onRowClickHandler("row:dblclick", $event, row),
                            onContextmenu: ($event) => onRowClickHandler("row:contextmenu", $event, row)
                          }), [
                            _ctx.selectable && !_ctx.$props.grid ? (openBlock(), createElementBlock("td", {
                              class: "va-data-table__table-td va-data-table__table-cell-select",
                              key: `selectable_${uniqueKey(row, index)}`,
                              onSelectstart: _cache[0] || (_cache[0] = withModifiers(() => {
                              }, ["prevent"]))
                            }, [
                              createVNode(unref(VaCheckbox), {
                                class: "va-data-table__table-cell-checkbox",
                                "model-value": unref(isRowSelected)(row),
                                color: _ctx.selectedColor,
                                "aria-label": unref(tp)(_ctx.$props.ariaSelectRowLabel, { index: row.initialIndex }),
                                onClick: [
                                  withModifiers(($event) => unref(shiftSelectRows)(row), ["shift", "exact", "stop"]),
                                  withModifiers(($event) => unref(ctrlSelectRow)(row), ["ctrl", "exact", "stop"]),
                                  withModifiers(($event) => unref(ctrlSelectRow)(row), ["exact", "stop"])
                                ]
                              }, null, 8, ["model-value", "color", "aria-label", "onClick"])
                            ], 32)) : createCommentVNode("", true),
                            (openBlock(true), createElementBlock(Fragment, null, renderList(row.cells, (cell, cellIndex) => {
                              return openBlock(), createElementBlock("td", mergeProps$1({
                                key: `table-cell_${cell.column.name + cell.rowIndex}`,
                                class: ["va-data-table__table-td", unref(getClass2)(cell.column.tdClass)],
                                style: [
                                  cell.column.width ? { minWidth: cell.column.width, maxWidth: cell.column.width } : {},
                                  unref(getCellCSSVariables)(cell),
                                  unref(getStyle2)(cell.column.tdStyle)
                                ]
                              }, unref(getCellBind)(cell, row)), [
                                `cell(${cell.column.name})` in _ctx.$slots ? renderSlot(_ctx.$slots, `cell(${cell.column.name})`, normalizeProps$1(mergeProps$1({ key: 0 }, { ...cell, row, isExpanded: row.isExpandableRowVisible }))) : renderSlot(_ctx.$slots, "cell", normalizeProps$1(mergeProps$1({ key: 1 }, { cell, row })), () => [
                                  _ctx.$props.grid ? (openBlock(), createElementBlock("span", _hoisted_10, toDisplayString(unref(columnsComputed)[cellIndex].label), 1)) : createCommentVNode("", true),
                                  createTextVNode(" " + toDisplayString(cellData(cell, unref(columnsComputed)[cellIndex])), 1)
                                ])
                              ], 16);
                            }), 128))
                          ], 16, _hoisted_9),
                          row.isExpandableRowVisible ? (openBlock(), createElementBlock("tr", _hoisted_11, [
                            (openBlock(), createElementBlock("td", {
                              class: "va-data-table__table-expanded-content",
                              colspan: "99999",
                              key: uniqueKey(row, index)
                            }, [
                              renderSlot(_ctx.$slots, "expandableRow", normalizeProps$1(guardReactiveProps(row)))
                            ]))
                          ])) : createCommentVNode("", true)
                        ], 64);
                      }), 128))
                    ]),
                    _: 2
                  }, 1032, ["name", "css", "appear"]),
                  renderSlot(_ctx.$slots, "bodyAppend")
                ], 512),
                ["footer", "footerPrepend", "footerAppend"].some((field) => _ctx.$slots[field]) || __props.footerClone && !_ctx.$props.grid ? (openBlock(), createElementBlock("tfoot", {
                  key: 1,
                  class: normalizeClass(["va-data-table__table-tfoot", { "va-data-table__table-tfoot--sticky": _ctx.$props.stickyFooter }]),
                  style: normalizeStyle({ bottom: isVirtualScroll.value && _ctx.$props.stickyFooter ? `${currentListOffset}px` : void 0 })
                }, [
                  renderSlot(_ctx.$slots, "footerPrepend"),
                  renderSlot(_ctx.$slots, "footer", {}, () => [
                    !__props.hideDefaultHeader ? (openBlock(), createBlock(unref(VaDataTableThRow), mergeProps$1({ key: 0 }, thAttributesComputed.value, {
                      "is-footer": "",
                      onToggleBulkSelection: unref(toggleBulkSelection),
                      onToggleSorting: unref(toggleSorting)
                    }), createSlots$1({ _: 2 }, [
                      renderList(_ctx.$slots, (_, slot) => {
                        return {
                          name: slot,
                          fn: withCtx((scope) => [
                            renderSlot(_ctx.$slots, slot, normalizeProps$1(guardReactiveProps(scope)))
                          ])
                        };
                      })
                    ]), 1040, ["onToggleBulkSelection", "onToggleSorting"])) : createCommentVNode("", true)
                  ]),
                  renderSlot(_ctx.$slots, "footerAppend")
                ], 6)) : createCommentVNode("", true)
              ], 16),
              unref(doRenderBottomTrigger) ? (openBlock(), createElementBlock("div", {
                key: 1,
                ref_key: "bottomTrigger",
                ref: bottomTrigger,
                class: "va-data-table__scroll-trigger"
              }, null, 512)) : createCommentVNode("", true)
            ]),
            _: 2
          }, 1032, ["style", "loading", "color"])
        ]),
        _: 3
      }, 16, ["style"]);
    };
  }
});
const VaDataTable = withConfigTransport$1(_sfc_main$1b);
const isRange$2 = (date) => {
  if (date === null) {
    return false;
  }
  return typeof date === "object" && ("start" in date || "end" in date);
};
const useRangeModelValueGuard = (modelValue, disabled) => {
  const bufferValue = ref(modelValue.value);
  const valueComputed = computed({
    get: () => bufferValue.value,
    set: (value) => {
      if (disabled.value) {
        modelValue.value = value;
      }
      if (!value) {
        modelValue.value = value;
        return;
      }
      if (isRange$2(value)) {
        if (value.end !== null) {
          modelValue.value = value;
        }
      } else {
        modelValue.value = value;
      }
      bufferValue.value = value;
    }
  });
  watch(modelValue, (newValue) => {
    bufferValue.value = newValue;
  });
  const reset = () => {
    if (bufferValue.value && isRange$2(bufferValue.value)) {
      bufferValue.value = modelValue.value;
    }
  };
  return {
    valueComputed,
    reset
  };
};
const isDate = (value) => Object.prototype.toString.call(value) === "[object Date]";
const defaultParseDateFunction$1 = (text) => new Date(Date.parse(text));
const isValidDate = (d) => isDate(d) && !isNaN(d.getTime());
const useDateParser = (props) => {
  const isMultipleDates = (text) => {
    const dates = text.split(props.delimiter);
    if (dates.length < 2) {
      return false;
    }
    return dates.every((date) => {
      const parsedDate = (props.parseDate || defaultParseDateFunction$1)(date);
      return isValidDate(parsedDate);
    });
  };
  const isRange2 = (text) => text.includes(props.rangeDelimiter);
  const isValid = ref(true);
  const parseDate = (text) => {
    const splitDate = text.split(".");
    const valueToParse = (splitDate == null ? void 0 : splitDate.length) === 3 ? splitDate.reverse().join("-") : text;
    const date = (props.parseDate || defaultParseDateFunction$1)(valueToParse);
    isValid.value = isValidDate(date);
    return date;
  };
  const parseDateInputValue = (text) => {
    isValid.value = true;
    if (props.parse) {
      return props.parse(text, isValid);
    }
    if (isMultipleDates(text)) {
      return text.split(props.delimiter).map(parseDate);
    }
    if (isRange2(text)) {
      const [start, end] = text.split(props.rangeDelimiter).map(parseDate);
      return { start, end };
    }
    return parseDate(text);
  };
  return {
    parseDateInputValue,
    isValid
  };
};
const isISO8601 = (date) => {
  const isoDate = Date.parse(date);
  return !isNaN(isoDate) && !date.includes(" ");
};
const isRFC1123GTM = (date) => {
  return date.endsWith("GMT");
};
const isRFC1123 = (date) => {
  const rfcDate = new Date(date);
  return !isNaN(rfcDate.getTime());
};
const formatDateToTheSameStandardFormat = (date, formattedString) => {
  if (isRFC1123GTM(formattedString)) {
    return date.toUTCString();
  }
  if (isISO8601(formattedString)) {
    return date.toISOString();
  }
  if (isRFC1123(formattedString)) {
    return date.toString();
  }
  return null;
};
const isRange$1 = (date) => {
  if (date === null) {
    return false;
  }
  return typeof date === "object" && ("start" in date || "end" in date);
};
const isMultiple = (date) => {
  if (date === null) {
    return false;
  }
  return Array.isArray(date);
};
const isSingleDate$1 = (date) => {
  if (date === null) {
    return false;
  }
  return typeof date === "string" || typeof date === "number" || date instanceof Date;
};
const useDateInputModelValue = (modelValue, mode, parseModelValue, formatModelValue, formatModelValueSingleDate) => {
  const syncFormat = (original, target) => {
    if (formatModelValueSingleDate) {
      return formatModelValueSingleDate(target);
    }
    if (typeof original === "string") {
      const standardFormat = formatDateToTheSameStandardFormat(target, original);
      if (standardFormat) {
        return standardFormat;
      }
      return formatModelValue(target);
    }
    if (typeof original === "number") {
      return target.getTime();
    }
    return target;
  };
  const normalizeSingleDate = (value) => {
    if (value instanceof Date) {
      return value;
    }
    return new Date(value);
  };
  const dateValue = computed(() => {
    if (modelValue.value === null || modelValue.value === void 0) {
      return null;
    }
    if (typeof modelValue.value === "string") {
      return parseModelValue(modelValue.value);
    }
    if (typeof modelValue.value === "number") {
      return new Date(modelValue.value);
    }
    return modelValue.value;
  });
  const normalized = computed({
    get: () => {
      if (dateValue.value === null || dateValue.value === void 0) {
        return null;
      }
      if (isMultiple(dateValue.value)) {
        return dateValue.value.map(normalizeSingleDate);
      }
      if (isRange$1(dateValue.value)) {
        const { start, end } = dateValue.value;
        return {
          start: start ? normalizeSingleDate(start) : null,
          end: end ? normalizeSingleDate(end) : null
        };
      }
      return normalizeSingleDate(dateValue.value);
    },
    set(newValue) {
      var _a2, _b;
      if (newValue === null || newValue === void 0) {
        modelValue.value = newValue;
        return;
      }
      if (isMultiple(newValue) && (isMultiple(modelValue.value) || isNil(modelValue.value))) {
        const originalValue = modelValue.value;
        modelValue.value = newValue.map((v, index) => syncFormat((originalValue == null ? void 0 : originalValue[index]) || (originalValue == null ? void 0 : originalValue[0]), v));
        return;
      }
      if (isRange$1(newValue) && (isRange$1(modelValue.value) || isNil(modelValue.value))) {
        const { start, end } = newValue;
        modelValue.value = {
          start: start ? syncFormat((_a2 = modelValue.value) == null ? void 0 : _a2.start, start) : null,
          // Sync end date only if start date is specified
          end: end ? syncFormat((_b = modelValue.value) == null ? void 0 : _b.start, end) : null
        };
        return;
      }
      if (isSingleDate$1(newValue) && (isSingleDate$1(modelValue.value) || isNil(modelValue.value))) {
        modelValue.value = syncFormat(modelValue.value, newValue);
        return;
      }
      throw new Error("Input date is not the same as date from props");
    }
  });
  const text = computed({
    get: () => {
      if (normalized.value === null || normalized.value === void 0) {
        return "";
      }
      return formatModelValue(normalized.value);
    },
    set: (value) => {
      modelValue.value = parseModelValue(value);
    }
  });
  return {
    text,
    normalized
  };
};
const isDatesDayEqual = (date1, date2) => (date1 == null ? void 0 : date1.toDateString()) === (date2 == null ? void 0 : date2.toDateString());
const isDatesYearEqual = (date1, date2) => {
  return (date1 == null ? void 0 : date1.getFullYear()) === (date2 == null ? void 0 : date2.getFullYear());
};
const isDatesMonthEqual = (date1, date2) => {
  return isDatesYearEqual(date1, date2) && (date1 == null ? void 0 : date1.getMonth()) === (date2 == null ? void 0 : date2.getMonth());
};
const createYearDate = (year) => {
  const date = /* @__PURE__ */ new Date();
  date.setFullYear(year);
  return date;
};
const isRange = (value) => {
  if (value === null) {
    return false;
  }
  return typeof value === "object" && ("start" in value || "end" in value);
};
const isSingleDate = (value) => isDate(value);
const isDates = (value) => Array.isArray(value);
const JANUARY_MONTH_INDEX = 0;
const DECEMBER_MONTH_INDEX = 11;
const addMonth = (view) => {
  if (view.month === DECEMBER_MONTH_INDEX) {
    return { ...view, year: view.year + 1, month: JANUARY_MONTH_INDEX };
  } else {
    return { ...view, month: view.month + 1 };
  }
};
const subMonth = (view) => {
  if (view.month === JANUARY_MONTH_INDEX) {
    return { ...view, year: view.year - 1, month: DECEMBER_MONTH_INDEX };
  } else {
    return { ...view, month: view.month - 1 };
  }
};
const getDefaultDate = (modelValue) => {
  if (isDate(modelValue)) {
    return modelValue;
  }
  if (isDate(modelValue == null ? void 0 : modelValue.start)) {
    return modelValue.start;
  }
  if (Array.isArray(modelValue) && isDate(modelValue[0])) {
    return modelValue[0];
  }
  return /* @__PURE__ */ new Date();
};
const useView = (props, emit2, defaultOverride) => {
  const defaultDate = getDefaultDate(props.modelValue);
  const defaultView = {
    type: "day",
    year: defaultDate.getFullYear(),
    month: defaultDate.getMonth(),
    ...defaultOverride
  };
  const statefulView = ref(defaultView);
  const syncView = computed({
    get() {
      return { ...statefulView.value, ...props.view };
    },
    set(view) {
      statefulView.value = view;
      emit2("update:view", view);
    }
  });
  const next = () => {
    if (syncView.value.type === "day") {
      syncView.value = addMonth(syncView.value);
    } else if (syncView.value.type === "month") {
      syncView.value = { ...syncView.value, year: syncView.value.year + 1 };
    }
  };
  const prev = () => {
    if (syncView.value.type === "day") {
      syncView.value = subMonth(syncView.value);
    } else if (syncView.value.type === "month") {
      syncView.value = { ...syncView.value, year: syncView.value.year - 1 };
    }
  };
  return {
    syncView,
    next,
    prev
  };
};
const _hoisted_1$L = ["onKeypress"];
const _sfc_main$1a = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaDatePickerCell"
  },
  __name: "VaDatePickerCell",
  props: {
    otherMonth: { type: Boolean, default: false },
    today: { type: Boolean, default: false },
    inRange: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    selected: { type: Boolean, default: false },
    weekend: { type: Boolean, default: false },
    hidden: { type: Boolean, default: false },
    focused: { type: Boolean, default: false },
    highlightWeekend: { type: Boolean, default: false },
    highlightToday: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    color: { type: String, default: "primary" }
  },
  emits: ["click"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const onClick = () => {
      if (!props.disabled) {
        emit2("click");
      }
    };
    const { getColor } = useColors();
    const bg = computed(() => getColor(props.color));
    const { textColorComputed } = useTextColor(bg);
    return (_ctx, _cache) => {
      return __props.hidden ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: "va-date-picker-cell va-date-picker-cell_clear",
        style: normalizeStyle(`--va-bg: ${String(bg.value)};--va-text-color-computed: ${String(unref(textColorComputed))}`)
      }, null, 4)) : (openBlock(), createElementBlock("div", {
        key: 1,
        class: normalizeClass(["va-date-picker-cell", {
          "va-date-picker-cell_other-month": __props.otherMonth,
          "va-date-picker-cell_today": __props.highlightToday && __props.today,
          "va-date-picker-cell_in-range": __props.inRange,
          "va-date-picker-cell_disabled": __props.disabled,
          "va-date-picker-cell_highlighted-weekend": __props.highlightWeekend && __props.weekend,
          "va-date-picker-cell_selected": __props.selected,
          "va-date-picker-cell_focused": __props.focused,
          "va-date-picker-cell_readonly": __props.readonly
        }]),
        onClick,
        onKeypress: withKeys(withModifiers(onClick, ["prevent", "stop"]), ["space", "enter"]),
        style: normalizeStyle(`--va-bg: ${String(bg.value)};--va-text-color-computed: ${String(unref(textColorComputed))}`)
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 46, _hoisted_1$L));
    };
  }
});
function isUndefined(t) {
  return t === void 0;
}
const useGridKeyboardNavigation = ({
  rowSize,
  start,
  end,
  onSelected,
  onFocusIndex
}) => {
  const focusedCellIndex = ref(-1);
  let previouslyClicked2 = false;
  const onMousedown = () => {
    previouslyClicked2 = true;
  };
  const onFocus = () => {
    if (previouslyClicked2) {
      return;
    }
    previouslyClicked2 = false;
    const index = onFocusIndex === void 0 ? unref(start) || 0 : unref(onFocusIndex);
    focusedCellIndex.value = index;
  };
  const onBlur = () => {
    previouslyClicked2 = false;
    focusedCellIndex.value = -1;
  };
  const onKeydown = (e) => {
    if (["ArrowRight", "ArrowLeft", "ArrowDown", "ArrowUp", "Enter", "Space"].includes(e.key)) {
      e.preventDefault();
      e.stopPropagation();
    }
    if (e.key === "Enter" || e.key === "Space") {
      if (onSelected === void 0) {
        return;
      }
      onSelected(focusedCellIndex.value);
      return;
    }
    if (e.key === "ArrowRight") {
      focusedCellIndex.value += 1;
    }
    if (e.key === "ArrowLeft") {
      focusedCellIndex.value -= 1;
    }
    if (e.key === "ArrowDown") {
      focusedCellIndex.value += rowSize;
    }
    if (e.key === "ArrowUp") {
      focusedCellIndex.value -= rowSize;
    }
    if (!isUndefined(start) && focusedCellIndex.value < unref(start)) {
      focusedCellIndex.value = unref(start);
    }
    if (!isUndefined(end) && focusedCellIndex.value > unref(end) - 1) {
      focusedCellIndex.value = unref(end) - 1;
    }
  };
  const containerAttributes = {
    onFocus,
    onKeydown,
    onBlur,
    onMousedown,
    tabindex: 0
  };
  return {
    focusedCellIndex,
    containerAttributes
  };
};
const modeInitialValue = (date, mode) => {
  if (mode === "single") {
    return date;
  } else if (mode === "range") {
    return { start: date, end: null };
  } else if (mode === "multiple") {
    return [date];
  } else if (mode === "auto") {
    return date;
  }
  throw new Error("Unknown mode");
};
const throwIncorrectModelValueError = (modelValue, mode) => {
  throw Error(`Incorrect modelValue for mode ${mode}. Got ${JSON.stringify(modelValue)}`);
};
const modeFromModelValue = (modelValue) => {
  if (isSingleDate(modelValue)) {
    return "single";
  } else if (isRange(modelValue)) {
    return "range";
  } else if (isDates(modelValue)) {
    return "multiple";
  }
  return throwIncorrectModelValueError(modelValue, "auto");
};
const sortRange = (modelValue) => {
  if (modelValue.start && modelValue.end) {
    if (modelValue.start > modelValue.end) {
      return { start: modelValue.end, end: modelValue.start };
    }
  }
  return modelValue;
};
const useDatePickerModelValue = (props, emit2, dateEqual) => {
  const updateModelValue = (date) => {
    if (!props.modelValue) {
      emit2("update:modelValue", modeInitialValue(date, props.mode));
      return;
    }
    const mode = props.mode === "auto" ? modeFromModelValue(props.modelValue) : props.mode;
    if (mode === "single") {
      if (!isSingleDate(props.modelValue)) {
        return throwIncorrectModelValueError(props.modelValue, mode);
      }
      emit2("update:modelValue", date);
    } else if (mode === "range") {
      if (!isRange(props.modelValue)) {
        return throwIncorrectModelValueError(props.modelValue, mode);
      }
      if (props.modelValue.end && dateEqual(props.modelValue.end, date)) {
        return emit2("update:modelValue", { start: props.modelValue.start, end: null });
      }
      if (props.modelValue.start && dateEqual(props.modelValue.start, date)) {
        return emit2("update:modelValue", { start: null, end: props.modelValue.end });
      }
      if (props.modelValue.end === null) {
        return emit2("update:modelValue", sortRange({ start: props.modelValue.start, end: date }));
      }
      if (props.modelValue.start === null) {
        return emit2("update:modelValue", sortRange({ end: props.modelValue.end, start: date }));
      }
      emit2("update:modelValue", { start: date, end: null });
    } else if (mode === "multiple") {
      if (!isDates(props.modelValue)) {
        return throwIncorrectModelValueError(props.modelValue, mode);
      }
      const isDatesIncludesDate = !!props.modelValue.find((d) => dateEqual(d, date));
      if (isDatesIncludesDate) {
        emit2("update:modelValue", props.modelValue.filter((d) => !dateEqual(d, date)));
      } else {
        emit2("update:modelValue", [...props.modelValue, date].sort((a, b) => a.getTime() - b.getTime()));
      }
    }
  };
  return {
    updateModelValue
  };
};
const getDateEqualFunction = (type) => {
  return {
    month: isDatesMonthEqual,
    day: isDatesDayEqual,
    year: isDatesYearEqual
  }[type];
};
const useDatePicker = (type, dates, props, emit2) => {
  const datesEqual = getDateEqualFunction(type);
  const isAllowedDate = props.allowedDays || props.allowedMonths || props.allowedYears;
  const isDateDisabled = (date) => isAllowedDate === void 0 ? false : !isAllowedDate(date);
  const hoveredIndex = ref(-1);
  const hoveredValue = computed(() => dates.value[hoveredIndex.value]);
  const { updateModelValue } = useDatePickerModelValue(
    props,
    emit2,
    datesEqual
  );
  const onClick = (date) => {
    if (props.readonly || isDateDisabled(date)) {
      return;
    }
    updateModelValue(date);
    emit2(`click:${type}`, date);
  };
  const isToday = (date) => {
    const today = /* @__PURE__ */ new Date();
    return datesEqual(today, date);
  };
  const isSelected = (date) => {
    if (!props.modelValue) {
      return false;
    }
    if (isSingleDate(props.modelValue)) {
      return datesEqual(props.modelValue, date);
    } else if (isDates(props.modelValue)) {
      return !!props.modelValue.find((d) => datesEqual(d, date));
    } else if (isRange(props.modelValue)) {
      return datesEqual(props.modelValue.start, date) || datesEqual(props.modelValue.end, date);
    }
    return false;
  };
  const isInRange = (date) => {
    if (!props.modelValue) {
      return false;
    }
    if (!isRange(props.modelValue)) {
      return false;
    }
    if (props.modelValue.start && props.modelValue.end) {
      return props.modelValue.start < date && props.modelValue.end > date;
    }
    const selectedDate = props.modelValue.start || props.modelValue.end;
    if (selectedDate) {
      if (!hoveredValue.value) {
        return false;
      }
      return selectedDate < date ? hoveredValue.value >= date : hoveredValue.value <= date;
    }
    return false;
  };
  watch(hoveredValue, (date) => {
    emit2(`hover:${type}`, date);
  });
  return {
    hoveredIndex,
    hoveredValue,
    onClick,
    isToday,
    isSelected,
    isInRange
  };
};
const getMonthDaysCount = (year, month) => new Date(year, month + 1, 0).getDate();
const getMonthStartWeekday = (year, month) => new Date(year, month, 1).getDay();
const getNumbersArray = (length) => Array.from(Array(length).keys()).map((k) => k + 1);
const useVaDatePickerCalendar = (view, options) => {
  const CALENDAR_ROWS_COUNT = 6;
  const localizeWeekday = (weekdayNumber) => {
    var _a2;
    if (!options || !((_a2 = options.firstWeekday) == null ? void 0 : _a2.value)) {
      return weekdayNumber;
    }
    if (options.firstWeekday.value.toLowerCase() === "monday") {
      return weekdayNumber === 0 ? 6 : weekdayNumber - 1;
    }
    return weekdayNumber;
  };
  const currentMonthStartWeekday = computed(() => localizeWeekday(getMonthStartWeekday(view.value.year, view.value.month)));
  const getPreviousDates = () => {
    if (currentMonthStartWeekday.value === 0) {
      return [];
    }
    const prevMonthDaysCount = getMonthDaysCount(view.value.year, view.value.month - 1);
    const prevMonthDays = getNumbersArray(prevMonthDaysCount);
    return prevMonthDays.slice(-currentMonthStartWeekday.value).map((d) => new Date(view.value.year, view.value.month - 1, d));
  };
  const getCurrentDates = () => {
    const currentMonthDays = getNumbersArray(getMonthDaysCount(view.value.year, view.value.month));
    return currentMonthDays.map((d) => new Date(view.value.year, view.value.month, d));
  };
  const prevAndCurrentDays = computed(() => [...getPreviousDates(), ...getCurrentDates()]);
  const currentMonthEndIndex = computed(() => prevAndCurrentDays.value.length);
  const calendarDates = computed(() => {
    const days = prevAndCurrentDays.value;
    const daysRemaining = 7 * CALENDAR_ROWS_COUNT - days.length;
    const nextMonthDaysCount = getMonthDaysCount(view.value.year, view.value.month + 1);
    const nextMonthDays = getNumbersArray(nextMonthDaysCount);
    return [
      ...days,
      ...nextMonthDays.slice(0, daysRemaining).map((d) => new Date(view.value.year, view.value.month + 1, d))
    ];
  });
  return { calendarDates, currentMonthStartIndex: currentMonthStartWeekday, currentMonthEndIndex };
};
const _hoisted_1$K = ["onMouseenter"];
const _hoisted_2$m = { class: "va-date-picker-cell__day" };
const _sfc_main$19 = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaDayPicker"
  },
  __name: "VaDayPicker",
  props: {
    monthNames: { type: Array, required: true },
    weekdayNames: { type: Array, required: true },
    firstWeekday: { type: String, default: "Sunday" },
    hideWeekDays: { type: Boolean, default: false },
    view: { type: Object, default: () => ({ type: "day" }) },
    modelValue: { type: [Date, Array, Object] },
    mode: { type: String, default: "auto" },
    showOtherMonths: { type: Boolean, default: false },
    allowedDays: { type: Function },
    weekends: { type: Function },
    highlightWeekend: { type: Boolean, default: false },
    highlightToday: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    color: { type: String, default: "primary" }
  },
  emits: ["update:modelValue", "hover:day", "click:day"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const { firstWeekday, weekdayNames, view } = toRefs(props);
    const { calendarDates, currentMonthStartIndex, currentMonthEndIndex } = useVaDatePickerCalendar(view, { firstWeekday });
    const weekdayNamesComputed = computed(() => {
      return firstWeekday.value.toLowerCase() === "sunday" ? weekdayNames.value : [...weekdayNames.value.slice(1), weekdayNames.value[0]];
    });
    const {
      hoveredIndex,
      onClick,
      isToday,
      isSelected,
      isInRange
    } = useDatePicker("day", calendarDates, props, emit2);
    const gridStartIndex = computed(() => props.showOtherMonths ? 0 : currentMonthStartIndex.value);
    const gridEndIndex = computed(() => props.showOtherMonths ? calendarDates.value.length : currentMonthEndIndex.value);
    const {
      focusedCellIndex,
      containerAttributes
    } = useGridKeyboardNavigation({
      rowSize: 7,
      start: gridStartIndex,
      end: gridEndIndex,
      onSelected: (selectedValue) => onClick(calendarDates.value[selectedValue])
    });
    watch(focusedCellIndex, (index) => {
      hoveredIndex.value = index;
    });
    watch(hoveredIndex, (index) => {
      focusedCellIndex.value = index;
    });
    const isOtherMonth = (date) => props.view.month !== date.getMonth();
    const isDateDisabled = (date) => props.allowedDays === void 0 ? false : !props.allowedDays(date);
    const isDateWeekend = (date) => {
      if (props.weekends === void 0) {
        return date.getDay() === 6 || date.getDay() === 0;
      }
      return props.weekends(date);
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", mergeProps$1({ class: "va-day-picker" }, unref(containerAttributes)), [
        !__props.hideWeekDays ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(weekdayNamesComputed.value, (weekday) => {
          return openBlock(), createElementBlock("div", {
            key: weekday,
            class: "va-day-picker__weekday"
          }, [
            renderSlot(_ctx.$slots, "weekday", {}, () => [
              createTextVNode(toDisplayString(weekday), 1)
            ])
          ]);
        }), 128)) : createCommentVNode("", true),
        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(calendarDates), (date, index) => {
          return openBlock(), createElementBlock("div", {
            class: "va-day-picker__calendar__day-wrapper",
            key: index,
            onMouseenter: ($event) => hoveredIndex.value = index,
            onMouseleave: _cache[0] || (_cache[0] = ($event) => hoveredIndex.value = -1)
          }, [
            createVNode(_sfc_main$1a, {
              hidden: isOtherMonth(date) && !__props.showOtherMonths,
              today: unref(isToday)(date),
              selected: unref(isSelected)(date),
              "in-range": unref(isInRange)(date),
              "other-month": isOtherMonth(date),
              weekend: isDateWeekend(date),
              disabled: isDateDisabled(date),
              focused: unref(hoveredIndex) === index,
              "highlight-today": __props.highlightToday,
              "highlight-weekend": __props.highlightWeekend,
              readonly: _ctx.$props.readonly,
              color: __props.color,
              onClick: ($event) => {
                unref(onClick)(date);
                focusedCellIndex.value = index;
              }
            }, {
              default: withCtx(() => [
                createBaseVNode("span", _hoisted_2$m, [
                  renderSlot(_ctx.$slots, "day", normalizeProps$1(guardReactiveProps({ date })), () => [
                    createTextVNode(toDisplayString(date.getDate()), 1)
                  ])
                ])
              ]),
              _: 2
            }, 1032, ["hidden", "today", "selected", "in-range", "other-month", "weekend", "disabled", "focused", "highlight-today", "highlight-weekend", "readonly", "color", "onClick"])
          ], 40, _hoisted_1$K);
        }), 128))
      ], 16);
    };
  }
});
const _hoisted_1$J = {
  key: 0,
  class: "va-date-picker-header va-date-picker__header"
};
const _hoisted_2$l = { class: "va-date-picker__header__text" };
const _hoisted_3$f = { class: "va-date-picker__header__month" };
const _sfc_main$18 = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaDatePickerHeader"
  },
  __name: "VaDatePickerHeader",
  props: {
    monthNames: { type: Array, required: true },
    view: { type: Object },
    color: { type: String },
    disabled: { type: Boolean, default: false },
    ariaNextPeriodLabel: useTranslationProp("$t:nextPeriod"),
    ariaPreviousPeriodLabel: useTranslationProp("$t:previousPeriod"),
    ariaSwitchViewLabel: useTranslationProp("$t:switchView")
  },
  emits: ["update:view"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const { syncView, prev, next } = useView(props, emit2);
    const switchView = () => {
      if (syncView.value.type === "day") {
        syncView.value = { ...syncView.value, type: "month" };
      } else if (syncView.value.type === "month") {
        syncView.value = { ...syncView.value, type: "year" };
      }
    };
    const changeView = (view) => {
      syncView.value = view;
    };
    const currentColor = useElementTextColor(useElementBackground(useCurrentElement()));
    const { tp } = useTranslation();
    return (_ctx, _cache) => {
      return unref(syncView).type !== "year" ? (openBlock(), createElementBlock("div", _hoisted_1$J, [
        renderSlot(_ctx.$slots, "buttonPrev", normalizeProps$1(guardReactiveProps({ onClick: unref(prev) })), () => [
          createVNode(unref(VaButton), {
            "va-child": "prevButton",
            disabled: _ctx.$props.disabled,
            icon: "va-arrow-left",
            preset: "plain",
            size: "small",
            color: __props.color,
            textColor: unref(currentColor),
            "aria-label": unref(tp)(_ctx.$props.ariaPreviousPeriodLabel),
            round: "",
            onClick: unref(prev)
          }, null, 8, ["disabled", "color", "textColor", "aria-label", "onClick"])
        ]),
        createBaseVNode("div", _hoisted_2$l, [
          renderSlot(_ctx.$slots, "header", normalizeProps$1(guardReactiveProps({ year: unref(syncView).year, month: unref(syncView).month, monthNames: __props.monthNames, view: unref(syncView), changeView, switchView })), () => [
            createVNode(unref(VaButton), {
              "va-child": "middleButton",
              disabled: _ctx.$props.disabled,
              preset: "plain",
              size: "small",
              color: __props.color,
              textColor: unref(currentColor),
              "aria-label": unref(tp)(_ctx.$props.ariaSwitchViewLabel),
              onClick: switchView
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "year", normalizeProps$1(guardReactiveProps({ year: unref(syncView).year })), () => [
                  createTextVNode(toDisplayString(unref(syncView).year), 1)
                ]),
                unref(syncView).type === "day" ? renderSlot(_ctx.$slots, "month", normalizeProps$1(mergeProps$1({ key: 0 }, { month: unref(syncView).month })), () => [
                  createBaseVNode("span", _hoisted_3$f, toDisplayString(__props.monthNames[unref(syncView).month]), 1)
                ]) : createCommentVNode("", true)
              ]),
              _: 3
            }, 8, ["disabled", "color", "textColor", "aria-label"])
          ])
        ]),
        renderSlot(_ctx.$slots, "buttonNext", normalizeProps$1(guardReactiveProps({ onClick: unref(next) })), () => [
          createVNode(unref(VaButton), {
            "va-child": "nextButton",
            disabled: _ctx.$props.disabled,
            icon: "va-arrow-right",
            preset: "plain",
            size: "small",
            color: __props.color,
            textColor: unref(currentColor),
            "aria-label": unref(tp)(_ctx.$props.ariaNextPeriodLabel),
            onClick: unref(next),
            round: ""
          }, null, 8, ["disabled", "color", "textColor", "aria-label", "onClick"])
        ])
      ])) : createCommentVNode("", true);
    };
  }
});
const _hoisted_1$I = ["onMouseenter"];
const _sfc_main$17 = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaMonthPicker"
  },
  __name: "VaMonthPicker",
  props: {
    modelValue: { type: [Date, Array, Object] },
    monthNames: { type: Array, required: true },
    view: { type: Object, default: () => ({ type: "month" }) },
    allowedMonths: { type: Function, default: void 0 },
    highlightToday: { type: Boolean, default: true },
    mode: { type: String, default: "auto" },
    readonly: { type: Boolean, default: false },
    color: { type: String, default: "primary" }
  },
  emits: ["update:modelValue", "hover:month", "click:month"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const { view } = toRefs(props);
    const months = computed(() => Array.from(Array(12).keys()).map((month) => new Date(view.value.year, month)));
    const {
      hoveredIndex,
      onClick,
      isToday,
      isSelected,
      isInRange
    } = useDatePicker("month", months, props, emit2);
    const isDisabled = (date) => props.allowedMonths === void 0 ? false : !props.allowedMonths(date);
    const {
      focusedCellIndex,
      containerAttributes
    } = useGridKeyboardNavigation({
      rowSize: 3,
      start: 0,
      end: months.value.length,
      onSelected: (selectedIndex) => onClick(months.value[selectedIndex])
    });
    watch(focusedCellIndex, (index) => {
      hoveredIndex.value = index;
    });
    watch(hoveredIndex, (index) => {
      focusedCellIndex.value = index;
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", mergeProps$1({ class: "va-month-picker" }, unref(containerAttributes)), [
        (openBlock(true), createElementBlock(Fragment, null, renderList(months.value, (month, monthIndex) => {
          return openBlock(), createElementBlock("div", {
            key: monthIndex,
            class: "va-month-picker__month-wrapper",
            onMouseenter: ($event) => hoveredIndex.value = monthIndex,
            onMouseleave: _cache[0] || (_cache[0] = ($event) => hoveredIndex.value = -1)
          }, [
            createVNode(_sfc_main$1a, {
              "in-range": !!unref(isInRange)(month),
              selected: !!unref(isSelected)(month),
              disabled: !!isDisabled(month),
              today: !!unref(isToday)(month),
              focused: unref(hoveredIndex) === monthIndex,
              "highlight-today": __props.highlightToday,
              readonly: _ctx.$props.readonly,
              color: __props.color,
              onClick: ($event) => {
                unref(onClick)(month);
                focusedCellIndex.value = monthIndex;
              }
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "month", normalizeProps$1(guardReactiveProps({ monthIndex, month: __props.monthNames[monthIndex] })), () => [
                  createTextVNode(toDisplayString(__props.monthNames[monthIndex]), 1)
                ])
              ]),
              _: 2
            }, 1032, ["in-range", "selected", "disabled", "today", "focused", "highlight-today", "readonly", "color", "onClick"])
          ], 40, _hoisted_1$I);
        }), 128))
      ], 16);
    };
  }
});
const _sfc_main$16 = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaYearPicker"
  },
  __name: "VaYearPicker",
  props: {
    modelValue: { type: [Date, Array, Object] },
    allowedYears: { type: Function, default: void 0 },
    highlightToday: { type: Boolean, default: true },
    startYear: { type: [Number, String], default: 1970 },
    mode: { type: String, default: "auto" },
    view: { type: Object, default: () => ({ type: "year" }) },
    endYear: { type: [Number, String], default: () => (/* @__PURE__ */ new Date()).getFullYear() + 50 },
    readonly: { type: Boolean, default: false },
    color: { type: String, default: "primary" }
  },
  emits: ["update:modelValue", "hover:year", "click:year"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const rootNode = shallowRef();
    const { view } = toRefs(props);
    const generateYearsArray = (start, end) => {
      const yearsCount = end - start + 1;
      return Array.from(Array(yearsCount).keys()).map((i) => createYearDate(start + i));
    };
    const startYearComputed = useNumericProp("startYear");
    const endYearComputed = useNumericProp("endYear");
    const years = computed(() => generateYearsArray(startYearComputed.value, endYearComputed.value));
    const scrollIntoYearIndex = (index) => {
      if (!rootNode.value) {
        return;
      }
      const scrollHeight = rootNode.value.scrollHeight;
      const rootNodeHeight = rootNode.value.offsetHeight;
      const currentYearOffset = scrollHeight / years.value.length * index;
      const cellSize = scrollHeight / years.value.length;
      const relativeScrollPosition = currentYearOffset - rootNode.value.scrollTop;
      if (relativeScrollPosition < 0) {
        rootNode.value.scrollTo({ top: currentYearOffset });
      } else if (relativeScrollPosition > rootNodeHeight) {
        rootNode.value.scrollTo({ top: currentYearOffset - rootNodeHeight + cellSize });
      }
    };
    const scrollIntoYearIndexCenter = (index) => {
      if (!rootNode.value) {
        return;
      }
      const scrollHeight = rootNode.value.scrollHeight;
      const rootNodeHeight = rootNode.value.offsetHeight;
      const currentYearOffset = scrollHeight / years.value.length * index;
      rootNode.value.scrollTo({ top: currentYearOffset - rootNodeHeight / 2 });
    };
    onMounted(() => {
      const currentYearIndex = years.value.findIndex((date) => date.getFullYear() === view.value.year);
      scrollIntoYearIndexCenter(currentYearIndex);
    });
    const {
      hoveredIndex,
      onClick,
      isToday,
      isSelected,
      isInRange
    } = useDatePicker("year", years, props, emit2);
    const isYearDisabled = (year) => props.allowedYears === void 0 ? false : !props.allowedYears(year);
    const {
      focusedCellIndex,
      containerAttributes
    } = useGridKeyboardNavigation({
      rowSize: 1,
      start: 0,
      end: years.value.length,
      onFocusIndex: computed(() => years.value.findIndex((date) => date.getFullYear() === view.value.year)),
      onSelected: (selectedIndex) => onClick(years.value[selectedIndex])
    });
    watch(focusedCellIndex, (index) => index !== -1 && scrollIntoYearIndex(index));
    watch(focusedCellIndex, (index) => {
      hoveredIndex.value = index;
    });
    watch(hoveredIndex, (index) => {
      focusedCellIndex.value = index;
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", mergeProps$1({
        ref_key: "rootNode",
        ref: rootNode,
        class: "va-year-picker"
      }, unref(containerAttributes), {
        onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers(() => {
        }, ["prevent"]), ["space"]))
      }), [
        (openBlock(true), createElementBlock(Fragment, null, renderList(years.value, (year, index) => {
          return openBlock(), createBlock(_sfc_main$1a, {
            key: year.toString(),
            "in-range": unref(isInRange)(year),
            selected: unref(isSelected)(year),
            disabled: isYearDisabled(year),
            today: unref(isToday)(year),
            focused: unref(focusedCellIndex) === index,
            "highlight-today": __props.highlightToday,
            readonly: _ctx.$props.readonly,
            color: __props.color,
            onClick: ($event) => {
              unref(onClick)(year);
              focusedCellIndex.value = index;
            },
            onMouseenter: ($event) => hoveredIndex.value = index,
            onMouseleave: _cache[0] || (_cache[0] = ($event) => hoveredIndex.value = -1)
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(year.getFullYear()), 1)
            ]),
            _: 2
          }, 1032, ["in-range", "selected", "disabled", "today", "focused", "highlight-today", "readonly", "color", "onClick", "onMouseenter"]);
        }), 128))
      ], 16);
    };
  }
});
const _hoisted_1$H = { class: "va-date-picker__picker-wrapper" };
const DEFAULT_MONTH_NAMES = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
const DEFAULT_WEEKDAY_NAMES = ["SU", "MO", "TU", "WE", "TH", "FR", "SA"];
const _sfc_main$15 = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaDatePicker"
  },
  __name: "VaDatePicker",
  props: {
    ...defineChildProps({
      prevButton: VaButton,
      nextButton: VaButton,
      middleButton: VaButton
    }),
    ...useStatefulProps,
    ...useComponentPresetProp,
    ...extractComponentProps(_sfc_main$18),
    ...extractComponentProps(_sfc_main$19),
    ...extractComponentProps(_sfc_main$17),
    ...extractComponentProps(_sfc_main$16),
    modelValue: { type: [Date, Array, Object] },
    monthNames: { type: Array, default: DEFAULT_MONTH_NAMES },
    weekdayNames: { type: Array, default: DEFAULT_WEEKDAY_NAMES },
    view: { type: Object },
    type: { type: String, default: "day" },
    readonly: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    // Colors
    color: { type: String, default: void 0 },
    weekendsColor: { type: String, default: void 0 }
  },
  emits: [
    ...useStatefulEmits,
    ...extractComponentEmits(_sfc_main$18),
    ...extractComponentEmits(_sfc_main$16),
    ...extractComponentEmits(_sfc_main$19),
    ...extractComponentEmits(_sfc_main$17)
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    useChildComponents(props);
    const emit2 = __emit;
    const currentPicker = ref();
    const { valueComputed } = useStateful(props, emit2);
    const { syncView } = useView(props, emit2, { type: props.type });
    const classComputed = computed(() => ({
      "va-date-picker_without-week-days": props.hideWeekDays,
      "va-date-picker_disabled": props.disabled
    }));
    const onDayModelValueUpdate = (modelValue) => {
      if (props.readonly) {
        return;
      }
      if (props.type === "day") {
        valueComputed.value = modelValue;
      }
    };
    const onMonthClick = (date) => {
      emit2("click:month", date);
      const year = date.getFullYear();
      const month = date.getMonth();
      if (props.type !== "month") {
        syncView.value = { type: "day", year, month };
      }
    };
    const onMonthModelValueUpdate = (modelValue) => {
      if (props.type === "month") {
        valueComputed.value = modelValue;
      }
    };
    const onYearClick = (date) => {
      emit2("click:year", date);
      const year = date.getFullYear();
      if (props.type !== "year") {
        syncView.value = { type: "month", year, month: syncView.value.month };
      }
    };
    const onYearModelValueUpdate = (modelValue) => {
      if (props.type === "year") {
        valueComputed.value = modelValue;
      }
    };
    const { colorsToCSSVariable } = useColors();
    const styleComputed = computed(() => ({
      ...colorsToCSSVariable({
        color: props.color,
        "weekends-color": props.weekendsColor
      }, "va-date-picker")
    }));
    const focusCurrentPicker = () => {
      var _a2;
      return (_a2 = currentPicker.value) == null ? void 0 : _a2.$el.focus();
    };
    watch(syncView, (newValue, prevValue) => {
      if (newValue.type === prevValue.type) {
        return;
      }
      nextTick(focusCurrentPicker);
    });
    const isPickerReadonly = (pickerName) => {
      return props.readonly && props.type === pickerName;
    };
    const dayPickerProps = filterComponentProps(extractComponentProps(_sfc_main$19));
    const headerProps = filterComponentProps(extractComponentProps(_sfc_main$18));
    const monthPickerProps = filterComponentProps(extractComponentProps(_sfc_main$17));
    const yearPickerProps = filterComponentProps(extractComponentProps(_sfc_main$16));
    __expose({
      focus: focusCurrentPicker,
      focusCurrentPicker
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["va-date-picker", classComputed.value]),
        style: normalizeStyle(styleComputed.value)
      }, [
        createVNode(_sfc_main$18, mergeProps$1(unref(headerProps), {
          view: unref(syncView),
          "onUpdate:view": _cache[0] || (_cache[0] = ($event) => isRef(syncView) ? syncView.value = $event : null)
        }), createSlots$1({ _: 2 }, [
          renderList(_ctx.$slots, (_, name) => {
            return {
              name,
              fn: withCtx((bind) => [
                renderSlot(_ctx.$slots, name, normalizeProps$1(guardReactiveProps(bind)))
              ])
            };
          })
        ]), 1040, ["view"]),
        createBaseVNode("div", _hoisted_1$H, [
          unref(syncView).type === "day" ? (openBlock(), createBlock(_sfc_main$19, mergeProps$1({
            key: 0,
            ref_key: "currentPicker",
            ref: currentPicker
          }, unref(dayPickerProps), {
            "model-value": unref(valueComputed),
            view: unref(syncView),
            readonly: _ctx.$props.disabled || isPickerReadonly("day"),
            "onUpdate:modelValue": onDayModelValueUpdate,
            "onHover:day": _cache[1] || (_cache[1] = (value) => _ctx.$emit("hover:day", value)),
            "onClick:day": _cache[2] || (_cache[2] = (value) => _ctx.$emit("click:day", value))
          }), createSlots$1({ _: 2 }, [
            renderList(_ctx.$slots, (_, name) => {
              return {
                name,
                fn: withCtx((bind) => [
                  renderSlot(_ctx.$slots, name, normalizeProps$1(guardReactiveProps(bind)))
                ])
              };
            })
          ]), 1040, ["model-value", "view", "readonly"])) : createCommentVNode("", true),
          unref(syncView).type === "month" ? (openBlock(), createBlock(_sfc_main$17, mergeProps$1({
            key: 1,
            ref_key: "currentPicker",
            ref: currentPicker
          }, unref(monthPickerProps), {
            view: unref(syncView),
            "model-value": unref(valueComputed),
            readonly: _ctx.$props.disabled || isPickerReadonly("month"),
            "onUpdate:modelValue": onMonthModelValueUpdate,
            "onHover:month": _cache[3] || (_cache[3] = (value) => _ctx.$emit("hover:month", value)),
            "onClick:month": onMonthClick
          }), createSlots$1({ _: 2 }, [
            renderList(_ctx.$slots, (_, name) => {
              return {
                name,
                fn: withCtx((bind) => [
                  renderSlot(_ctx.$slots, name, normalizeProps$1(guardReactiveProps(bind)))
                ])
              };
            })
          ]), 1040, ["view", "model-value", "readonly"])) : createCommentVNode("", true),
          unref(syncView).type === "year" ? (openBlock(), createBlock(_sfc_main$16, mergeProps$1({
            key: 2,
            ref_key: "currentPicker",
            ref: currentPicker
          }, unref(yearPickerProps), {
            view: unref(syncView),
            "model-value": unref(valueComputed),
            readonly: _ctx.$props.disabled || isPickerReadonly("year"),
            "onHover:year": _cache[4] || (_cache[4] = (value) => _ctx.$emit("hover:year", value)),
            "onUpdate:modelValue": onYearModelValueUpdate,
            "onClick:year": onYearClick
          }), createSlots$1({ _: 2 }, [
            renderList(_ctx.$slots, (_, name) => {
              return {
                name,
                fn: withCtx((bind) => [
                  renderSlot(_ctx.$slots, name, normalizeProps$1(guardReactiveProps(bind)))
                ])
              };
            })
          ]), 1040, ["view", "model-value", "readonly"])) : createCommentVNode("", true)
        ])
      ], 6);
    };
  }
});
const VaDropdownProps$2 = extractComponentProps(
  VaDropdown,
  ["innerAnchorSelector", "stateful", "keyboardNavigation", "modelValue"]
);
const useDropdownableProps = {
  ...VaDropdownProps$2,
  modelValue: {},
  /**
   * Close dropdown on value updated.
   * @default null - behavior controlled by component
   */
  closeOnChange: { type: Boolean, default: null },
  isOpen: { type: Boolean, default: void 0 }
};
const useDropdownableEmits = ["update:isOpen"];
const useDropdownable = function(props, emit2, options = {}) {
  const [isOpenSync] = useSyncProp("isOpen", props, emit2, false);
  const doWatch2 = computed(() => props.closeOnChange !== null ? props.closeOnChange : unref(options.defaultCloseOnValueUpdate || false));
  watch(() => props.modelValue, () => {
    if (doWatch2.value) {
      isOpenSync.value = false;
    }
  });
  return {
    dropdownProps: filterComponentProps(VaDropdownProps$2),
    isOpenSync
  };
};
const VaInputWrapperPropsDeclaration = extractComponentProps(VaInputWrapper, ["focused", "maxLength", "counterValue"]);
const VaDatePickerPropsDeclaration = extractComponentProps(_sfc_main$15);
const _sfc_main$14 = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaDateInput"
  },
  __name: "VaDateInput",
  props: {
    ...useDropdownableProps,
    ...useClearableProps,
    ...VaInputWrapperPropsDeclaration,
    ...VaDatePickerPropsDeclaration,
    ...useValidationProps,
    ...useComponentPresetProp,
    clearValue: { type: void 0, default: void 0 },
    modelValue: { type: [Date, Array, Object, String, Number] },
    resetOnClose: { type: Boolean, default: true },
    closeOnContentClick: { type: Boolean, default: false },
    offset: { ...useDropdownableProps.offset, default: () => [2, 0] },
    format: { type: Function },
    formatDate: { type: Function, default: (d) => d.toLocaleDateString() },
    /** Force model value to string instead of date */
    formatValue: { type: Function },
    parse: { type: Function },
    parseDate: { type: Function },
    delimiter: { type: String, default: ", " },
    rangeDelimiter: { type: String, default: " ~ " },
    manualInput: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    leftIcon: { type: Boolean, default: false },
    icon: { type: String, default: "va-calendar" },
    ariaToggleDropdownLabel: useTranslationProp("$t:toggleDropdown"),
    ariaResetLabel: useTranslationProp("$t:resetDate"),
    ariaSelectedDateLabel: useTranslationProp("$t:selectedDate")
  },
  emits: [
    ...useFocusEmits,
    ...extractComponentEmits(_sfc_main$15),
    ...useClearableEmits,
    ...useValidationEmits,
    ...useStatefulEmits,
    ...useDropdownableEmits,
    "update:text"
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const input = shallowRef();
    const datePicker = ref();
    const { resetOnClose } = toRefs(props);
    const { trapFocusIn, freeFocus } = useTrapFocus();
    const trapFocus = () => {
      const el = unwrapEl(datePicker.value);
      if (!el) {
        freeFocus();
        return;
      }
      trapFocusIn(el);
    };
    watch([datePicker], () => {
      trapFocus();
    });
    const { valueComputed: statefulValue } = useStateful(props, emit2);
    const { isOpenSync, dropdownProps } = useDropdownable(props, emit2, {
      defaultCloseOnValueUpdate: computed(() => {
        if (Array.isArray(valueComputed.value)) {
          return false;
        }
        if (isRange(valueComputed.value) && valueComputed.value.end === null) {
          return false;
        }
        return true;
      })
    });
    const isRangeModelValueGuardDisabled = computed(() => !resetOnClose.value);
    const {
      valueComputed,
      reset: resetInvalidRange
    } = useRangeModelValueGuard(statefulValue, isRangeModelValueGuardDisabled);
    watch(isOpenSync, (isOpened) => {
      if (!isOpened && !isRangeModelValueGuardDisabled.value) {
        resetInvalidRange();
      }
    });
    const { isFocused: isInputFocused, focus, blur, onFocus: focusListener, onBlur: blurListener } = useFocus(input);
    const isPickerFocused = useFocusDeep(datePicker);
    const dateOrNothing = (date) => date ? props.formatDate(date) : "...";
    const { parseDateInputValue, isValid } = useDateParser(props);
    watch(valueComputed, () => {
      isValid.value = true;
    });
    const modelValueToString = (value) => {
      if (props.format) {
        return props.format(valueComputed.value);
      }
      if (isDates(value)) {
        return value.map((d) => props.formatDate(d)).join(props.delimiter);
      }
      if (isSingleDate(value)) {
        return props.formatDate(value);
      }
      if (isRange(value)) {
        return dateOrNothing(value.start) + props.rangeDelimiter + dateOrNothing(value.end);
      }
      if (value === null || value === void 0) {
        return "";
      }
      return "";
    };
    const {
      text,
      normalized: valueWithoutText
    } = useDateInputModelValue(valueComputed, toRef(props, "mode"), parseDateInputValue, modelValueToString, props.formatValue);
    const valueText = computed(() => {
      if (!isValid.value) {
        return "";
      }
      if (!valueComputed.value) {
        if (!props.clearValue) {
          return "";
        }
        return modelValueToString(props.clearValue);
      }
      return text.value;
    });
    const onInputTextChanged = ({ target }) => {
      if (props.disabled) {
        return;
      }
      const inputValue = target.value;
      if (isValid.value) {
        valueComputed.value = inputValue === "" ? props.clearValue : parseDateInputValue(inputValue);
      }
    };
    const reset = () => withoutValidation(() => {
      statefulValue.value = props.clearValue;
      emit2("clear");
      resetValidation();
    });
    const hideAndFocus = () => {
      isOpenSync.value = false;
      focus();
    };
    const focusDatePicker = () => {
      nextTick(() => {
        var _a2;
        return (_a2 = datePicker.value) == null ? void 0 : _a2.focusCurrentPicker();
      });
    };
    const focusInputOrPicker = () => {
      isOpenSync.value ? focusDatePicker() : focus();
    };
    const checkProhibitedDropdownOpening = (e) => {
      if (isOpenSync.value) {
        return false;
      }
      if (props.disabled || props.readonly) {
        return true;
      }
      if (e === void 0) {
        return false;
      }
      return props.manualInput && (e == null ? void 0 : e.code) !== "Space";
    };
    const toggleDropdown = (event) => {
      if (checkProhibitedDropdownOpening(event instanceof KeyboardEvent ? event : void 0)) {
        return;
      }
      isOpenSync.value = !isOpenSync.value;
      nextTick(focusInputOrPicker);
    };
    const showDropdown = () => {
      if (props.disabled || props.readonly) {
        return;
      }
      isOpenSync.value = true;
      nextTick(focusDatePicker);
    };
    const {
      isDirty: isDirty2,
      isTouched,
      computedError,
      computedErrorMessages,
      listeners,
      validationAriaAttributes,
      validate,
      withoutValidation,
      resetValidation
    } = useValidation(props, emit2, { reset, focus, value: valueComputed });
    watch(isOpenSync, (isOpen) => {
      if (!isOpen) {
        isTouched.value = true;
      }
    });
    const hasError = computed(() => !isValid.value && valueComputed.value !== props.clearValue || computedError.value);
    const slots = useSlots();
    const filterSlots = computed(() => {
      const slotsWithIcons = [
        props.leftIcon && "prependInner",
        (!props.leftIcon || props.clearable) && "icon"
      ];
      return Object.keys(slots).filter((slot) => !slotsWithIcons.includes(slot));
    });
    const {
      canBeCleared,
      clearIconProps,
      onFocus,
      onBlur
    } = useClearable(props, valueComputed);
    const cursorStyleComputed = computed(() => {
      if (props.disabled) {
        return {};
      }
      if (props.manualInput) {
        return { cursor: "text" };
      }
      return { cursor: "pointer" };
    });
    const iconTabindexComputed = computed(() => {
      if (!props.manualInput) {
        return -1;
      }
      return props.disabled || props.readonly ? -1 : 0;
    });
    const iconProps = computed(() => ({
      role: iconTabindexComputed.value === 0 ? "button" : "none",
      ariaHidden: iconTabindexComputed.value === -1,
      name: props.icon,
      color: "secondary",
      tabindex: iconTabindexComputed.value
    }));
    const filteredWrapperProps = filterComponentProps(VaInputWrapperPropsDeclaration);
    const computedInputWrapperProps = computed(() => ({
      ...filteredWrapperProps.value,
      focused: isInputFocused.value || isPickerFocused.value,
      error: hasError.value,
      errorMessages: computedErrorMessages.value,
      readonly: props.readonly || !props.manualInput
    }));
    const computedInputListeners = computed(() => ({
      focus: () => {
        if (props.disabled) {
          return;
        }
        focusListener();
        if (props.readonly) {
          return;
        }
        onFocus();
      },
      blur: () => {
        if (props.disabled) {
          return;
        }
        blurListener();
        if (props.readonly) {
          return;
        }
        onBlur();
        listeners.onBlur();
      }
    }));
    const { tp } = useTranslation();
    const attrs = useAttrs();
    const inputAttributesComputed = computed(() => ({
      readonly: props.readonly || !props.manualInput,
      disabled: props.disabled,
      tabindex: props.disabled ? -1 : 0,
      placeholder: props.placeholder,
      value: valueText.value,
      ariaLabel: props.label || tp(props.ariaSelectedDateLabel),
      ariaRequired: props.requiredMark,
      ariaDisabled: props.disabled,
      ariaReadOnly: props.readonly,
      ...validationAriaAttributes.value,
      ...omit(attrs, ["class", "style"])
    }));
    const dropdownPropsComputed = computed(() => ({
      ...dropdownProps.value,
      stateful: false,
      innerAnchorSelector: ".va-input-wrapper__field",
      trigger: ["click", "right-click", "enter", "space"]
    }));
    const inputWrapperProps = computedInputWrapperProps;
    const inputListeners = computedInputListeners;
    const datePickerProps = filterComponentProps(VaDatePickerPropsDeclaration);
    __expose({
      valueText,
      valueWithoutText,
      valueDate: valueWithoutText,
      focus,
      blur,
      reset,
      validate,
      showDropdown,
      hideAndFocus,
      toggleDropdown,
      focusDatePicker,
      isDirty: isDirty2,
      isTouched
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaDropdown), mergeProps$1({
        modelValue: unref(isOpenSync),
        "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => isRef(isOpenSync) ? isOpenSync.value = $event : null),
        class: ["va-date-input", _ctx.$attrs.class],
        style: _ctx.$attrs.style
      }, dropdownPropsComputed.value, {
        onOpen: focusDatePicker,
        role: "none"
      }), {
        anchor: withCtx(() => [
          renderSlot(_ctx.$slots, "input", normalizeProps$1(guardReactiveProps({ valueText: valueText.value, inputAttributes: inputAttributesComputed.value, inputWrapperProps: unref(inputWrapperProps), inputListeners: unref(inputListeners) })), () => [
            createVNode(unref(VaInputWrapper), mergeProps$1({
              class: "va-date-input__anchor",
              style: cursorStyleComputed.value
            }, unref(inputWrapperProps), toHandlers(unref(inputListeners)), {
              "model-value": valueText.value,
              onChange: onInputTextChanged
            }), createSlots$1({
              icon: withCtx(() => [
                unref(canBeCleared) ? (openBlock(), createBlock(unref(VaIcon), mergeProps$1({
                  key: 0,
                  "aria-label": unref(tp)(_ctx.$props.ariaResetLabel)
                }, { ...iconProps.value, ...unref(clearIconProps) }, {
                  onClick: withModifiers(reset, ["stop"]),
                  onKeydown: [
                    withKeys(withModifiers(reset, ["stop"]), ["enter"]),
                    withKeys(withModifiers(reset, ["stop"]), ["space"])
                  ]
                }), null, 16, ["aria-label", "onKeydown"])) : createCommentVNode("", true),
                !_ctx.$props.leftIcon && _ctx.$props.icon ? (openBlock(), createBlock(unref(VaIcon), mergeProps$1({
                  key: 1,
                  "aria-label": unref(tp)(_ctx.$props.ariaToggleDropdownLabel)
                }, iconProps.value), null, 16, ["aria-label"])) : createCommentVNode("", true)
              ]),
              _: 2
            }, [
              renderList(filterSlots.value, (name) => {
                return {
                  name,
                  fn: withCtx((slotScope) => [
                    renderSlot(_ctx.$slots, name, normalizeProps$1(guardReactiveProps(slotScope)))
                  ])
                };
              }),
              _ctx.$slots.prependInner || _ctx.$props.leftIcon ? {
                name: "prependInner",
                fn: withCtx((slotScope) => [
                  renderSlot(_ctx.$slots, "prependInner", normalizeProps$1(guardReactiveProps(slotScope))),
                  _ctx.$props.leftIcon ? (openBlock(), createBlock(unref(VaIcon), mergeProps$1({
                    key: 0,
                    "aria-label": unref(tp)(_ctx.$props.ariaToggleDropdownLabel)
                  }, iconProps.value), null, 16, ["aria-label"])) : createCommentVNode("", true)
                ]),
                key: "0"
              } : void 0
            ]), 1040, ["style", "model-value"])
          ])
        ]),
        default: withCtx(() => [
          createVNode(unref(VaDropdownContent), {
            class: "va-date-input__dropdown-content",
            onKeydown: _cache[8] || (_cache[8] = withKeys(($event) => unref(focus)(), ["esc"])),
            role: "dialog"
          }, {
            default: withCtx(() => [
              createVNode(_sfc_main$15, mergeProps$1({
                ref_key: "datePicker",
                ref: datePicker
              }, unref(datePickerProps), {
                modelValue: unref(valueWithoutText),
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(valueWithoutText) ? valueWithoutText.value = $event : null),
                "onClick:day": _cache[1] || (_cache[1] = ($event) => _ctx.$emit("click:day", $event)),
                "onClick:month": _cache[2] || (_cache[2] = ($event) => _ctx.$emit("click:month", $event)),
                "onClick:year": _cache[3] || (_cache[3] = ($event) => _ctx.$emit("click:year", $event)),
                "onHover:day": _cache[4] || (_cache[4] = ($event) => _ctx.$emit("hover:day", $event)),
                "onHover:month": _cache[5] || (_cache[5] = ($event) => _ctx.$emit("hover:month", $event)),
                "onHover:year": _cache[6] || (_cache[6] = ($event) => _ctx.$emit("hover:year", $event)),
                "onUpdate:view": _cache[7] || (_cache[7] = ($event) => {
                  _ctx.$nextTick(() => trapFocus());
                  _ctx.$emit("update:view", $event);
                })
              }), createSlots$1({ _: 2 }, [
                renderList(_ctx.$slots, (_, name) => {
                  return {
                    name,
                    fn: withCtx((bind) => [
                      renderSlot(_ctx.$slots, name, normalizeProps$1(guardReactiveProps(bind)))
                    ])
                  };
                })
              ]), 1040, ["modelValue"])
            ]),
            _: 3
          })
        ]),
        _: 3
      }, 16, ["modelValue", "class", "style"]);
    };
  }
});
const VaDateInput = withConfigTransport$1(_sfc_main$14);
const VaDatePicker = withConfigTransport$1(_sfc_main$15);
const _hoisted_1$G = ["aria-orientation"];
const _hoisted_2$k = {
  key: 0,
  class: "va-divider__text"
};
const prefixClass = "va-divider";
const _sfc_main$13 = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaDivider"
  },
  __name: "VaDivider",
  props: {
    ...useComponentPresetProp,
    vertical: { type: Boolean, default: false },
    dashed: { type: Boolean, default: false },
    inset: { type: Boolean, default: false },
    orientation: {
      type: String,
      default: "center",
      validator: (value) => ["left", "right", "center"].includes(value)
    },
    color: { type: String, default: "backgroundBorder" }
  },
  setup(__props) {
    const props = __props;
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const slots = useSlots();
    const hasSlot = computed(() => !!slots.default);
    const classComputed = computed(() => ({
      [`${prefixClass}--vertical`]: props.vertical,
      [`${prefixClass}--inset`]: props.inset,
      [`${prefixClass}--${props.orientation}`]: props.orientation && !props.vertical,
      [`${prefixClass}--dashed`]: props.dashed
    }));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        role: "separator",
        class: normalizeClass(["va-divider", classComputed.value]),
        "aria-orientation": __props.vertical ? "vertical" : "horizontal",
        "aria-hidden": true,
        style: normalizeStyle(`--va-color-computed: ${String(colorComputed.value)}`)
      }, [
        hasSlot.value && !__props.vertical ? (openBlock(), createElementBlock("div", _hoisted_2$k, [
          renderSlot(_ctx.$slots, "default")
        ])) : createCommentVNode("", true)
      ], 14, _hoisted_1$G);
    };
  }
});
const VaDivider = withConfigTransport$1(_sfc_main$13);
const VaFileUploadKey = Symbol("VaFileUpload");
const _sfc_main$12 = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaList"
  },
  __name: "VaList",
  props: {
    ...useComponentPresetProp,
    fit: { type: Boolean, default: false }
  },
  setup(__props) {
    const props = __props;
    const computedClass = computed(() => ({ "va-list--fit": props.fit }));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["va-list", computedClass.value]),
        role: "list"
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 2);
    };
  }
});
const _sfc_main$11 = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaListItem"
  },
  __name: "VaListItem",
  props: {
    ...useRouterLinkProps,
    ...useComponentPresetProp,
    tag: { type: String, default: "div" },
    disabled: { type: Boolean, default: false }
  },
  emits: ["focus", "click"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const tabIndexComputed = computed(() => props.disabled ? -1 : 0);
    const computedClass = useBem("va-list-item", () => ({
      ...pick(props, ["disabled"])
    }));
    const {
      tagComputed,
      hrefComputed
    } = useRouterLink(props);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(unref(tagComputed)), {
        class: normalizeClass(["va-list-item", unref(computedClass)]),
        role: "listitem",
        href: unref(hrefComputed),
        target: _ctx.target,
        to: _ctx.to,
        replace: _ctx.replace,
        exact: _ctx.exact,
        "active-class": _ctx.activeClass,
        "exact-active-class": _ctx.exactActiveClass,
        tabindex: tabIndexComputed.value
      }, {
        default: withCtx(() => [
          createBaseVNode("div", {
            class: "va-list-item__inner",
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click")),
            onFocus: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("focus"))
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 32)
        ]),
        _: 3
      }, 8, ["href", "target", "to", "replace", "exact", "active-class", "exact-active-class", "class", "tabindex"]);
    };
  }
});
const _sfc_main$10 = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaListLabel"
  },
  __name: "VaListLabel",
  props: {
    ...useComponentPresetProp,
    color: { type: String, default: "primary" }
  },
  setup(__props) {
    const props = __props;
    const { getColor } = useColors();
    const computedStyle = computed(() => ({
      color: getColor(props.color)
    }));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "va-list-label",
        style: normalizeStyle(computedStyle.value)
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 4);
    };
  }
});
const _sfc_main$$ = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaListItemLabel"
  },
  __name: "VaListItemLabel",
  props: {
    ...useComponentPresetProp,
    caption: { type: Boolean, default: false },
    lines: { type: [Number, String], default: 1 }
  },
  setup(__props) {
    const props = __props;
    const linesComputed = useNumericProp("lines");
    const computedClass = computed(() => ({ "va-list-item-label--caption": props.caption }));
    const computedStyle = computed(() => ({ "-webkit-line-clamp": linesComputed.value }));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["va-list-item-label", computedClass.value]),
        style: normalizeStyle(computedStyle.value)
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 6);
    };
  }
});
const _sfc_main$_ = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaListItemSection"
  },
  __name: "VaListItemSection",
  props: {
    ...useComponentPresetProp,
    icon: { type: Boolean, default: false },
    avatar: { type: Boolean, default: false }
  },
  setup(__props) {
    const props = __props;
    const computedClass = computed(() => ({
      "va-list-item-section--main": !props.icon && !props.avatar,
      "va-list-item-section--icon": props.icon,
      "va-list-item-section--avatar": props.avatar
    }));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["va-list-item-section", computedClass.value])
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 2);
    };
  }
});
const _sfc_main$Z = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaListSeparator"
  },
  __name: "VaListSeparator",
  props: {
    ...useComponentPresetProp,
    fit: { type: Boolean, default: false },
    spaced: { type: Boolean, default: false }
  },
  setup(__props) {
    const props = __props;
    const computedClass = computed(() => ({
      "va-list-separator--offset": !props.fit,
      "va-list-separator--spaced": props.spaced
    }));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        "aria-hidden": "true",
        class: normalizeClass(["va-list-separator", computedClass.value])
      }, null, 2);
    };
  }
});
const VaListItem = withConfigTransport$1(_sfc_main$11);
const VaListLabel = withConfigTransport$1(_sfc_main$10);
const VaListItemLabel = withConfigTransport$1(_sfc_main$$);
const VaListItemSection = withConfigTransport$1(_sfc_main$_);
const VaListSeparator = withConfigTransport$1(_sfc_main$Z);
const VaList = withConfigTransport$1(_sfc_main$12);
const _hoisted_1$F = {
  key: 0,
  class: "va-progress-bar__info"
};
const _sfc_main$Y = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaProgressBar"
  },
  __name: "VaProgressBar",
  props: {
    ...useComponentPresetProp,
    modelValue: { type: [Number, String], default: 0 },
    indeterminate: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    size: {
      type: [Number, String],
      default: "medium"
    },
    buffer: { type: [Number, String], default: 100 },
    rounded: { type: Boolean, default: true },
    reverse: { type: Boolean, default: false },
    contentInside: { type: Boolean, default: false },
    showPercent: { type: Boolean, default: false },
    max: { type: [Number, String], default: 100 },
    ariaLabel: useTranslationProp("$t:progressState")
  },
  setup(__props) {
    const props = __props;
    const { getColor, getHoverColor: getHoverColor2 } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const { textColorComputed } = useTextColor(colorComputed);
    const isTextSize = computed(() => typeof props.size === "string" && ["small", "medium", "large"].includes(props.size));
    const getCSSHeight = () => {
      if (typeof props.size === "number") {
        return `${props.size}px`;
      }
      if (isTextSize.value) {
        return;
      }
      return props.size;
    };
    const { tp } = useTranslation();
    const progressBarValue = computed(() => 100 / Number(props.max) * Number(props.modelValue));
    const rootClass = computed(() => ({
      "va-progress-bar--square": !props.rounded,
      [`va-progress-bar--${props.size}`]: isTextSize.value
    }));
    const rooStyle = computed(() => ({
      "--va-progress-bar-color": colorComputed.value,
      "--va-progress-bar-background-color": getHoverColor2(colorComputed.value)
    }));
    const wrapperStyle = computed(() => ({
      height: getCSSHeight()
    }));
    const bufferStyle = computed(() => ({
      width: `${props.indeterminate ? 100 : clamp$1(Number(props.buffer), 0, 100)}%`,
      color: textColorComputed.value,
      [props.reverse ? "right" : "left"]: 0
    }));
    const progressStyle = computed(() => ({
      marginLeft: props.reverse ? "auto" : void 0,
      width: `${clamp$1(progressBarValue.value, 0, 100)}%`
    }));
    const intermediateStyle = computed(() => ({
      animationDirection: props.reverse ? "reverse" : "normal"
    }));
    const ariaAttributesComputed = computed(() => ({
      role: "progressbar",
      "aria-label": tp(props.ariaLabel),
      "aria-valuenow": !props.indeterminate ? props.modelValue : void 0
    }));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", mergeProps$1({
        class: ["va-progress-bar", rootClass.value],
        style: rooStyle.value
      }, ariaAttributesComputed.value), [
        !_ctx.$props.contentInside ? (openBlock(), createElementBlock("div", _hoisted_1$F, [
          renderSlot(_ctx.$slots, "default", normalizeProps$1(guardReactiveProps({ value: _ctx.$props.modelValue })), () => [
            _ctx.$props.showPercent ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createTextVNode(toDisplayString(_ctx.$props.modelValue) + "% ", 1)
            ], 64)) : createCommentVNode("", true)
          ])
        ])) : createCommentVNode("", true),
        createBaseVNode("div", {
          class: "va-progress-bar__wrapper",
          style: normalizeStyle(wrapperStyle.value)
        }, [
          createBaseVNode("div", {
            class: "va-progress-bar__buffer",
            style: normalizeStyle(bufferStyle.value)
          }, [
            _ctx.$props.contentInside ? renderSlot(_ctx.$slots, "default", normalizeProps$1(mergeProps$1({ key: 0 }, { value: _ctx.$props.modelValue })), () => [
              _ctx.$props.showPercent ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createTextVNode(toDisplayString(_ctx.$props.modelValue) + "% ", 1)
              ], 64)) : createCommentVNode("", true)
            ]) : createCommentVNode("", true)
          ], 4),
          __props.indeterminate ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createBaseVNode("div", {
              class: "va-progress-bar__progress--indeterminate-start",
              style: normalizeStyle(intermediateStyle.value)
            }, null, 4),
            createBaseVNode("div", {
              class: "va-progress-bar__progress--indeterminate-end",
              style: normalizeStyle(intermediateStyle.value)
            }, null, 4)
          ], 64)) : (openBlock(), createElementBlock("div", {
            key: 1,
            class: "va-progress-bar__progress",
            style: normalizeStyle(progressStyle.value)
          }, null, 4))
        ], 4)
      ], 16);
    };
  }
});
const VaProgressBar = withConfigTransport$1(_sfc_main$Y);
const useStrictInject = (injectionSymbol, errorMessage) => {
  const strictInjection = inject$1(injectionSymbol);
  if (!strictInjection) {
    throw new Error(errorMessage);
  }
  return strictInjection;
};
const _hoisted_1$E = { class: "va-file-upload-undo__text" };
const INJECTION_ERROR_MESSAGE$4 = "The VaFileUploadUndo component should be used in the context of VaFileUpload component";
const _sfc_main$X = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaFileUploadUndo"
  },
  __name: "VaFileUploadUndo",
  props: {
    vertical: { type: Boolean, default: false }
  },
  emits: ["recover"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const progress = ref(100);
    const {
      undoDuration,
      undoButtonText,
      deletedFileMessage
    } = useStrictInject(VaFileUploadKey, INJECTION_ERROR_MESSAGE$4);
    const computedClasses = useBem("va-file-upload-undo", () => ({
      vertical: props.vertical
    }));
    const undoDurationStyle = computed(() => `${undoDuration.value ?? 0}ms`);
    onMounted(() => {
      const timer = setTimeout(() => {
        progress.value = 0;
        clearTimeout(timer);
      }, 0);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode(unref(VaProgressBar), {
          "model-value": progress.value,
          rounded: false,
          class: "va-file-upload-undo-progress-bar",
          style: normalizeStyle(`--va-undo-duration-style: ${String(undoDurationStyle.value)}`)
        }, null, 8, ["model-value", "style"]),
        createBaseVNode("div", {
          class: normalizeClass(["va-file-upload-undo", unref(computedClasses)]),
          style: normalizeStyle(`--va-undo-duration-style: ${String(undoDurationStyle.value)}`)
        }, [
          createBaseVNode("span", _hoisted_1$E, toDisplayString(unref(deletedFileMessage)), 1),
          createVNode(unref(VaButton), {
            class: "va-file-upload-undo__button",
            "aria-label": unref(undoButtonText),
            size: "small",
            outline: "",
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("recover"))
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(unref(undoButtonText)), 1)
            ]),
            _: 1
          }, 8, ["aria-label"])
        ], 6)
      ], 64);
    };
  }
});
const VaFileUploadUndo = withConfigTransport$1(_sfc_main$X);
const _hoisted_1$D = { class: "va-file-upload-list-item__content" };
const _hoisted_2$j = {
  key: 0,
  class: "va-file-upload-list-item__name"
};
const _hoisted_3$e = { class: "va-file-upload-list-item__size" };
const INJECTION_ERROR_MESSAGE$3 = "The VaFileUploadListItem component should be used in the context of VaFileUpload component";
const _sfc_main$W = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaFileUploadListItem"
  },
  __name: "VaFileUploadListItem",
  props: {
    file: { type: Object, default: null },
    color: { type: String, default: "success" },
    ariaRemoveFileLabel: useTranslationProp("$t:removeFile")
  },
  emits: ["remove"],
  setup(__props, { emit: __emit }) {
    const { tp } = useTranslation();
    const emit2 = __emit;
    const {
      undo,
      disabled,
      undoDuration
    } = useStrictInject(VaFileUploadKey, INJECTION_ERROR_MESSAGE$3);
    const { onFocus, onBlur } = useFocus();
    const removed = ref(false);
    const removeFile = () => {
      if (undo.value) {
        removed.value = true;
        setTimeout(() => {
          if (removed.value) {
            emit2("remove");
            removed.value = false;
          }
        }, undoDuration.value ?? 0);
      } else {
        emit2("remove");
        removed.value = false;
      }
    };
    const recoverFile = () => {
      removed.value = false;
    };
    const computedClasses = useBem("va-file-upload-list-item", () => ({
      undo: removed.value
    }));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaListItem), {
        class: normalizeClass(["va-file-upload-list-item", unref(computedClasses)]),
        tabindex: "-1",
        disabled: unref(disabled),
        "aria-disabled": unref(disabled)
      }, {
        default: withCtx(() => [
          removed.value && unref(undo) ? (openBlock(), createBlock(unref(VaListItemSection), { key: 0 }, {
            default: withCtx(() => [
              createVNode(unref(VaFileUploadUndo), { onRecover: recoverFile })
            ]),
            _: 1
          })) : (openBlock(), createBlock(unref(VaListItemSection), { key: 1 }, {
            default: withCtx(() => [
              createBaseVNode("div", _hoisted_1$D, [
                __props.file && __props.file.name ? (openBlock(), createElementBlock("div", _hoisted_2$j, toDisplayString(__props.file && __props.file.name), 1)) : createCommentVNode("", true),
                createBaseVNode("div", _hoisted_3$e, toDisplayString(__props.file && __props.file.size), 1),
                !unref(disabled) ? (openBlock(), createBlock(unref(VaButton), {
                  key: 1,
                  flat: "",
                  color: "danger",
                  icon: "clear",
                  class: "va-file-upload-list-item__delete",
                  "aria-label": unref(tp)(_ctx.$props.ariaRemoveFileLabel),
                  onClick: withModifiers(removeFile, ["stop"]),
                  onKeydown: [
                    withKeys(withModifiers(removeFile, ["stop"]), ["enter"]),
                    withKeys(withModifiers(removeFile, ["stop"]), ["space"])
                  ],
                  onFocus: unref(onFocus),
                  onBlur: unref(onBlur)
                }, null, 8, ["aria-label", "onKeydown", "onFocus", "onBlur"])) : createCommentVNode("", true)
              ])
            ]),
            _: 1
          }))
        ]),
        _: 1
      }, 8, ["class", "disabled", "aria-disabled"]);
    };
  }
});
const VaFileUploadListItem = withConfigTransport$1(_sfc_main$W);
const _hoisted_1$C = ["src", "alt"];
const _hoisted_2$i = { class: "va-file-upload-gallery-item__overlay" };
const _hoisted_3$d = ["title"];
const INJECTION_ERROR_MESSAGE$2 = "The VaFileUploadGalleryItem component should be used in the context of VaFileUpload component";
const _sfc_main$V = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaFileUploadGalleryItem"
  },
  __name: "VaFileUploadGalleryItem",
  props: {
    file: { type: Object, default: null },
    color: { type: String, default: "success" },
    ariaRemoveFileLabel: useTranslationProp("$t:removeFile")
  },
  emits: ["remove"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const {
      undo,
      disabled,
      undoDuration
    } = useStrictInject(VaFileUploadKey, INJECTION_ERROR_MESSAGE$2);
    const { isFocused, onFocus, onBlur } = useFocus();
    const previewImage = ref("");
    const removed = ref(false);
    const overlayStylesComputed = computed(() => ({
      backgroundColor: colorToRgba(props.color, 0.7)
    }));
    const classesComputed = useBem("va-file-upload-gallery-item", () => ({
      notImage: !previewImage.value,
      focused: isFocused.value,
      undo: removed.value
    }));
    const removeImage = () => {
      if (undo.value) {
        removed.value = true;
        setTimeout(() => {
          if (!removed.value) {
            return;
          }
          emit2("remove");
          removed.value = false;
        }, undoDuration.value ?? 0);
      } else {
        emit2("remove");
        removed.value = false;
      }
    };
    const recoverImage = () => {
      removed.value = false;
    };
    const convertToImg = () => {
      if (!props.file.name || !props.file.image) {
        return;
      }
      if (props.file.image.url) {
        previewImage.value = props.file.image.url;
      } else if (props.file.image instanceof File) {
        const reader = new FileReader();
        reader.readAsDataURL(props.file.image);
        reader.onload = (e) => {
          var _a2, _b;
          if (((_a2 = e.target) == null ? void 0 : _a2.result).includes("image")) {
            previewImage.value = (_b = e.target) == null ? void 0 : _b.result;
          }
        };
      }
    };
    onMounted(convertToImg);
    watch(() => props.file, convertToImg);
    const { tp } = useTranslation();
    const { textColorComputed } = useTextColor(toRef(props, "color"));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaListItem), {
        class: normalizeClass(["va-file-upload-gallery-item", unref(classesComputed)]),
        tabindex: "-1",
        disabled: unref(disabled),
        "aria-disabled": unref(disabled),
        onFocus: unref(onFocus),
        onBlur: unref(onBlur)
      }, {
        default: withCtx(() => [
          removed.value && unref(undo) ? (openBlock(), createBlock(unref(VaListItemSection), { key: 0 }, {
            default: withCtx(() => [
              createVNode(unref(VaFileUploadUndo), {
                vertical: "",
                onRecover: recoverImage
              })
            ]),
            _: 1
          })) : (openBlock(), createBlock(unref(VaListItemSection), { key: 1 }, {
            default: withCtx(() => [
              previewImage.value ? (openBlock(), createElementBlock("img", {
                key: 0,
                src: previewImage.value,
                alt: __props.file.name || "",
                class: "va-file-upload-gallery-item__image"
              }, null, 8, _hoisted_1$C)) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_2$i, [
                createBaseVNode("div", {
                  class: "va-file-upload-gallery-item__overlay-background",
                  style: normalizeStyle(overlayStylesComputed.value)
                }, null, 4),
                __props.file && __props.file.name ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: "va-file-upload-gallery-item__name",
                  title: __props.file.name,
                  style: normalizeStyle({ color: unref(textColorComputed) })
                }, toDisplayString(__props.file.name), 13, _hoisted_3$d)) : createCommentVNode("", true),
                !unref(disabled) ? (openBlock(), createBlock(unref(VaButton), {
                  key: 1,
                  flat: "",
                  color: "danger",
                  icon: "va-delete",
                  class: "va-file-upload-gallery-item__delete",
                  "aria-label": unref(tp)(_ctx.$props.ariaRemoveFileLabel),
                  onClick: removeImage,
                  onFocus: unref(onFocus),
                  onBlur: unref(onBlur)
                }, null, 8, ["aria-label", "onFocus", "onBlur"])) : createCommentVNode("", true)
              ])
            ]),
            _: 1
          }))
        ]),
        _: 1
      }, 8, ["class", "disabled", "aria-disabled", "onFocus", "onBlur"]);
    };
  }
});
const VaFileUploadGalleryItem = withConfigTransport$1(_sfc_main$V);
const _hoisted_1$B = { class: "va-file-upload-single-item__name" };
const INJECTION_ERROR_MESSAGE$1 = "The VaFileUploadSingleItem component should be used in the context of VaFileUpload component";
const _sfc_main$U = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaFileUploadSingleItem"
  },
  __name: "VaFileUploadSingleItem",
  props: {
    file: { type: Object, default: null },
    ariaRemoveFileLabel: useTranslationProp("$t:removeFile")
  },
  emits: ["remove"],
  setup(__props, { emit: __emit }) {
    const { tp } = useTranslation();
    const { disabled } = useStrictInject(VaFileUploadKey, INJECTION_ERROR_MESSAGE$1);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaListItem), {
        disabled: unref(disabled),
        "aria-disabled": unref(disabled),
        class: "va-file-upload-single-item",
        tabindex: "-1"
      }, {
        default: withCtx(() => [
          createVNode(unref(VaListItemSection), { class: "va-file-upload-single-item__content" }, {
            default: withCtx(() => [
              createBaseVNode("div", _hoisted_1$B, toDisplayString(__props.file && __props.file.name), 1),
              !unref(disabled) ? (openBlock(), createBlock(unref(VaButton), {
                key: 0,
                class: "va-file-upload-single-item__button",
                "aria-label": unref(tp)(_ctx.$props.ariaRemoveFileLabel),
                size: "small",
                color: "danger",
                preset: "secondary",
                onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("remove"))
              }, {
                default: withCtx(() => [
                  createTextVNode(" Delete ")
                ]),
                _: 1
              }, 8, ["aria-label"])) : createCommentVNode("", true)
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["disabled", "aria-disabled"]);
    };
  }
});
const VaFileUploadSingleItem = withConfigTransport$1(_sfc_main$U);
const VaFileUploadGalleryItemProps = extractComponentProps(VaFileUploadGalleryItem);
const VaFileUploadListItemProps = extractComponentProps(VaFileUploadListItem);
const VaFileUploadSingleItemProps = extractComponentProps(VaFileUploadSingleItem);
const _sfc_main$T = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaFileUploadList"
  },
  __name: "VaFileUploadList",
  props: {
    type: { type: String, default: "" },
    files: { type: Array, default: null },
    ...VaFileUploadGalleryItemProps,
    ...VaFileUploadListItemProps,
    ...VaFileUploadSingleItemProps
  },
  emits: ["remove", "removeSingle"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const filesList = computed(() => props.files.map(convertFile));
    const convertFile = (file) => ({
      name: file.name || file.url || "",
      size: formatSize(file.size),
      date: formatDate(/* @__PURE__ */ new Date()),
      image: file
    });
    const formatSize = (bytes) => {
      if (bytes === 0) {
        return "0 Bytes";
      }
      if (!bytes) {
        return "";
      }
      const k = 1024;
      const sizes = ["Bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
    };
    const formatDate = (date = /* @__PURE__ */ new Date()) => {
      return date.toLocaleDateString("en-US", {
        hour: "2-digit",
        minute: "2-digit",
        month: "short",
        day: "numeric",
        year: "numeric"
      });
    };
    const galleryItemProps = filterComponentProps(VaFileUploadGalleryItemProps);
    const itemProps = filterComponentProps(VaFileUploadListItemProps);
    const singleItemProps = filterComponentProps(VaFileUploadSingleItemProps);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaList), {
        class: normalizeClass(["va-file-upload-list", `va-file-upload-list--${__props.type}`]),
        role: __props.type !== "single" ? "list" : void 0
      }, {
        default: withCtx(() => [
          __props.type === "list" ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(filesList.value, (file, index) => {
            return openBlock(), createBlock(unref(VaFileUploadListItem), mergeProps$1({
              key: file.name
            }, unref(itemProps), {
              file,
              role: "listitem",
              onRemove: ($event) => _ctx.$emit("remove", index)
            }), null, 16, ["file", "onRemove"]);
          }), 128)) : createCommentVNode("", true),
          __props.type === "gallery" ? (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(filesList.value, (file, index) => {
            return openBlock(), createBlock(unref(VaFileUploadGalleryItem), mergeProps$1(unref(galleryItemProps), {
              key: file.name,
              file,
              role: "listitem",
              onRemove: ($event) => _ctx.$emit("remove", index)
            }), null, 16, ["file", "onRemove"]);
          }), 128)) : createCommentVNode("", true),
          __props.type === "single" && filesList.value.length ? (openBlock(), createBlock(unref(VaFileUploadSingleItem), mergeProps$1({ key: 2 }, unref(singleItemProps), {
            file: filesList.value[filesList.value.length - 1],
            onRemove: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("removeSingle"))
          }), null, 16, ["file"])) : createCommentVNode("", true)
        ]),
        _: 1
      }, 8, ["role", "class"]);
    };
  }
});
const VaFileUploadList = withConfigTransport$1(_sfc_main$T);
const _hoisted_1$A = { class: "va-file-upload__field" };
const _hoisted_2$h = {
  key: 0,
  class: "va-file-upload__field__text"
};
const _hoisted_3$c = ["accept", "multiple", "disabled"];
const VaFileUploadListProps = extractComponentProps(VaFileUploadList);
const _sfc_main$S = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaFileUpload"
  },
  __name: "VaFileUpload",
  props: {
    ...useComponentPresetProp,
    ...VaFileUploadListProps,
    fileTypes: { type: String, default: "" },
    dropzone: { type: Boolean, default: false },
    hideFileList: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    disabled: { type: Boolean, default: false },
    undo: { type: Boolean, default: false },
    undoDuration: { type: [Number, String], default: 3e3 },
    undoButtonText: useTranslationProp("$t:undo"),
    dropZoneText: useTranslationProp("$t:dropzone"),
    uploadButtonText: useTranslationProp("$t:uploadFile"),
    deletedFileMessage: useTranslationProp("$t:fileDeleted"),
    fileIncorrectMessage: useTranslationProp("$t:fileTypeIncorrect"),
    modelValue: {
      type: [Object, Array],
      default: () => []
    },
    type: {
      type: String,
      default: "list",
      validator: (value) => ["list", "gallery", "single"].includes(value)
    }
  },
  emits: ["update:modelValue", "file-removed", "file-added"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const fileInputRef = shallowRef();
    const modal = ref(false);
    const dropzoneHighlight = ref(false);
    const { getColor, shiftHSLAColor: shiftHSLAColor2 } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const computedStyle = computed(() => ({
      backgroundColor: props.dropzone ? shiftHSLAColor2(colorComputed.value, { a: dropzoneHighlight.value ? -0.82 : -0.92 }) : "transparent"
    }));
    const computedClasses = useBem("va-file-upload", () => ({
      dropzone: props.dropzone,
      disabled: props.disabled
    }));
    const files = computed({
      get() {
        return Array.isArray(props.modelValue) ? props.modelValue : [props.modelValue];
      },
      set(files2) {
        if (props.type === "single") {
          emit2("update:modelValue", files2[0]);
        } else {
          emit2("update:modelValue", files2);
        }
      }
    });
    const filterInvalidFiles = (files2) => files2.filter((file) => {
      const fileName = file.name || file.url;
      if (!fileName) {
        return false;
      }
      if (file.url) {
        return true;
      }
      const MIMETypes = ["audio/*", "video/*", "image/*"];
      const isContainedMIMEType = MIMETypes.find((t) => props.fileTypes.includes(t));
      if (isContainedMIMEType) {
        return true;
      }
      const extension = fileName.substring(fileName.lastIndexOf(".") + 1).toLowerCase();
      const isCorrectExt = props.fileTypes.includes(extension);
      if (!isCorrectExt) {
        modal.value = true;
      }
      return isCorrectExt;
    });
    const uploadFile = (e) => {
      var _a2, _b;
      const f = ((_a2 = e.target) == null ? void 0 : _a2.files) || ((_b = e.dataTransfer) == null ? void 0 : _b.files);
      if (!f) {
        return;
      }
      const validatedFiles = props.fileTypes ? filterInvalidFiles(Array.from(f)) : f;
      files.value = props.type === "single" ? validatedFiles : [...files.value, ...validatedFiles];
      emit2("file-added", validatedFiles);
    };
    const changeFieldValue = (e) => {
      uploadFile(e);
      if (fileInputRef.value) {
        fileInputRef.value.value = "";
      }
    };
    const removeFile = (index) => {
      if (index in files.value) {
        const removedFile = files.value[index];
        files.value = files.value.filter((item, idx) => idx !== index);
        emit2("file-removed", removedFile);
      }
    };
    const removeSingleFile = () => {
      if (files.value.length > 0) {
        const removedFile = files.value[0];
        files.value = [];
        emit2("file-removed", removedFile);
      }
    };
    const callFileDialogue = () => {
      if (fileInputRef.value) {
        fileInputRef.value.click();
      }
    };
    onMounted(() => {
      if (Array.isArray(files.value)) {
        const filteredFiles = filterInvalidFiles(files.value);
        if (filteredFiles.length !== files.value.length) {
          files.value = filteredFiles;
        }
      }
    });
    const { tp } = useTranslation();
    provide(VaFileUploadKey, {
      undo: toRef(props, "undo"),
      disabled: toRef(props, "disabled"),
      undoDuration: useNumericProp("undoDuration"),
      undoButtonText: computed(() => tp(props.undoButtonText)),
      deletedFileMessage: computed(() => tp(props.deletedFileMessage))
    });
    const fileUploadListProps = filterComponentProps(VaFileUploadListProps);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["va-file-upload", unref(computedClasses)]),
        style: normalizeStyle(computedStyle.value)
      }, [
        renderSlot(_ctx.$slots, "default", {}, () => [
          createBaseVNode("div", _hoisted_1$A, [
            __props.dropzone ? (openBlock(), createElementBlock("div", _hoisted_2$h, toDisplayString(unref(tp)(__props.dropZoneText)), 1)) : createCommentVNode("", true),
            createVNode(unref(VaButton), {
              class: "va-file-upload__field__button",
              disabled: __props.disabled,
              "aria-disabled": __props.disabled,
              color: colorComputed.value,
              style: normalizeStyle({ "pointer-events": dropzoneHighlight.value ? "none" : void 0 }),
              onChange: changeFieldValue,
              onClick: callFileDialogue
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(tp)(__props.uploadButtonText)), 1)
              ]),
              _: 1
            }, 8, ["disabled", "aria-disabled", "color", "style"])
          ])
        ]),
        createBaseVNode("input", {
          ref_key: "fileInputRef",
          ref: fileInputRef,
          type: "file",
          class: "va-file-upload__field__input",
          tabindex: -1,
          "aria-hidden": "true",
          accept: __props.fileTypes,
          multiple: __props.type !== "single",
          disabled: __props.disabled,
          onChange: changeFieldValue,
          onDragenter: _cache[0] || (_cache[0] = ($event) => dropzoneHighlight.value = true),
          onDragleave: _cache[1] || (_cache[1] = ($event) => dropzoneHighlight.value = false)
        }, null, 40, _hoisted_3$c),
        files.value.length && !_ctx.$props.hideFileList ? (openBlock(), createBlock(unref(VaFileUploadList), mergeProps$1({ key: 0 }, unref(fileUploadListProps), {
          type: __props.type,
          files: files.value,
          color: colorComputed.value,
          onRemove: removeFile,
          onRemoveSingle: removeSingleFile
        }), null, 16, ["type", "files", "color"])) : createCommentVNode("", true),
        createVNode(unref(VaModal), {
          modelValue: modal.value,
          "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => modal.value = $event),
          "hide-default-actions": "",
          message: unref(tp)("$t:fileTypeIncorrect")
        }, null, 8, ["modelValue", "message"])
      ], 6);
    };
  }
});
const VaFileUpload = withConfigTransport$1(_sfc_main$S);
const createFormContext = (options) => {
  const fields = ref(/* @__PURE__ */ new Map());
  return {
    // Vue unwrap ref automatically, but types are not for some reason
    immediate: computed(() => options.immediate),
    fields: computed(() => [...fields.value.values()]),
    forceHideErrors: computed(() => options.hideErrors),
    forceHideErrorMessages: computed(() => options.hideErrorMessages),
    forceHideLoading: computed(() => options.hideLoading),
    forceDirty: ref(false),
    registerField: (uid2, field) => {
      fields.value.set(uid2, field);
    },
    unregisterField: (uid2) => {
      fields.value.delete(uid2);
    }
  };
};
const useFormParent = (options) => {
  const formContext = createFormContext(options);
  provide(FormServiceKey, formContext);
  const { fields, forceDirty } = formContext;
  const fieldNames = computed(() => fields.value.map((field) => unref(field.name)).filter(Boolean));
  const fieldsNamed = computed(() => fields.value.reduce((acc, field) => {
    if (unref(field.name)) {
      acc[unref(field.name)] = field;
    }
    return acc;
  }, {}));
  const formData = computed(() => fields.value.reduce((acc, field) => {
    if (unref(field.name)) {
      acc[unref(field.name)] = unref(field.value);
    }
    return acc;
  }, {}));
  const isValid = computed(() => fields.value.every((field) => unref(field.isValid)));
  const isLoading = computed(() => fields.value.some((field) => unref(field.isLoading)));
  const errorMessages = computed(() => fields.value.map((field) => unref(field.errorMessages)).flat());
  const errorMessagesNamed = computed(() => fields.value.reduce((acc, field) => {
    if (unref(field.name)) {
      acc[unref(field.name)] = unref(field.errorMessages);
    }
    return acc;
  }, {}));
  const isDirty2 = computed({
    get() {
      return fields.value.some((field) => unref(field.isDirty)) || forceDirty.value;
    },
    set(v) {
      forceDirty.value = v;
      fields.value.forEach((field) => {
        field.isDirty = v;
      });
    }
  });
  const isTouched = computed({
    get() {
      return fields.value.some((field) => field.isTouched);
    },
    set(v) {
      fields.value.forEach((field) => {
        field.isTouched = v;
      });
    }
  });
  const validate = () => {
    isDirty2.value = true;
    return fields.value.reduce((acc, field) => {
      return field.validate() && acc;
    }, true);
  };
  const validateAsync = () => {
    isDirty2.value = true;
    return Promise.all(fields.value.map((field) => field.validateAsync())).then((results) => {
      return results.every(Boolean);
    });
  };
  const reset = () => {
    isDirty2.value = false;
    fields.value.forEach((field) => field.reset());
  };
  const resetValidation = () => {
    isDirty2.value = false;
    fields.value.forEach((field) => field.resetValidation());
  };
  const focus = () => {
    var _a2;
    (_a2 = fields.value[0]) == null ? void 0 : _a2.focus();
  };
  const focusInvalidField = () => {
    const invalidField = fields.value.find((field) => !field.isValid);
    invalidField == null ? void 0 : invalidField.focus();
  };
  useFormChild({
    name: toRef(options, "name"),
    isValid,
    isLoading,
    isDirty: isDirty2,
    isTouched,
    validate,
    validateAsync,
    reset,
    resetValidation,
    focus,
    errorMessages
  });
  return {
    immediate: computed(() => options.immediate),
    isDirty: isDirty2,
    isTouched,
    formData,
    fields,
    fieldsNamed,
    fieldNames,
    isValid,
    isLoading,
    errorMessages,
    errorMessagesNamed,
    validate,
    validateAsync,
    reset,
    resetValidation,
    focus,
    focusInvalidField
  };
};
const statefulProps = { stateful: true };
const statefulConfig = {
  VaInput: statefulProps,
  VaSelect: statefulProps,
  VaCheckbox: statefulProps,
  VaRadio: statefulProps,
  VaDatePicker: statefulProps,
  VaTimePicker: statefulProps,
  VaColorPicker: statefulProps,
  VaSlider: statefulProps,
  VaSwitch: statefulProps,
  VaFileUpload: statefulProps,
  VaRating: statefulProps,
  VaDateInput: statefulProps,
  VaTimeInput: statefulProps
};
const _sfc_main$R = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaForm"
  },
  __name: "VaForm",
  props: {
    ...useComponentPresetProp,
    autofocus: { type: Boolean, default: false },
    immediate: { type: Boolean, default: false },
    tag: { type: String, default: "form" },
    trigger: { type: String, default: "blur" },
    modelValue: { type: Boolean, default: true },
    hideErrors: { type: Boolean, default: false },
    hideErrorMessages: { type: Boolean, default: false },
    hideLoading: { type: Boolean, default: false },
    stateful: { type: Boolean, default: false },
    name: { type: String, default: void 0 }
  },
  emits: ["update:modelValue"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const context = useFormParent(props);
    watch(context.isValid, (value) => {
      emit2("update:modelValue", value);
    });
    watch(() => props.autofocus, (value) => {
      if (value) {
        context.focus();
      }
    });
    onMounted(() => {
      if (props.autofocus) {
        context.focus();
      }
    });
    watch(context.fields, (newVal) => {
      if (newVal.length && props.immediate) {
        context.validate();
      }
    }, { immediate: true });
    useLocalConfigProvider(computed(() => {
      if (!props.stateful) {
        return {};
      }
      return statefulConfig;
    }));
    const {
      immediate: immediateComputed,
      isDirty: isDirty2,
      isTouched,
      formData,
      fields,
      fieldsNamed,
      fieldNames,
      isValid,
      isLoading,
      errorMessages,
      errorMessagesNamed,
      validate,
      validateAsync,
      reset,
      resetValidation,
      focus,
      focusInvalidField
    } = context;
    __expose({
      immediate: immediateComputed,
      isDirty: isDirty2,
      formData,
      fields,
      fieldsNamed,
      fieldNames,
      isValid,
      isTouched,
      isLoading,
      errorMessages,
      errorMessagesNamed,
      validate,
      validateAsync,
      reset,
      resetValidation,
      focus,
      focusInvalidField
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(__props.tag), mergeProps$1({
        class: "va-form",
        onSubmit: _cache[0] || (_cache[0] = (e) => _ctx.$attrs.action === void 0 && e.preventDefault())
      }, _ctx.$attrs), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default", normalizeProps$1(guardReactiveProps({
            isValid: unref(isValid),
            isDirty: unref(isDirty2),
            isTouched: unref(isTouched),
            isLoading: unref(isLoading),
            errorMessages: unref(errorMessages),
            errorMessagesNamed: unref(errorMessagesNamed),
            formData: unref(formData),
            fields: unref(fields),
            fieldsNamed: unref(fieldsNamed),
            fieldNames: unref(fieldNames),
            validate: unref(validate),
            validateAsync: unref(validateAsync),
            reset: unref(reset),
            resetValidation: unref(resetValidation),
            focus: unref(focus),
            focusInvalidField: unref(focusInvalidField)
          })))
        ]),
        _: 3
      }, 16);
    };
  }
});
const VaForm = withConfigTransport$1(_sfc_main$R);
const sleep = (ms = 0) => {
  return new Promise((resolve2) => setTimeout(resolve2, ms));
};
const useScroll = (props, element, handler) => {
  const addScrollListener = () => {
    var _a2;
    (_a2 = element.value) == null ? void 0 : _a2.addEventListener(
      "scroll",
      handler.value,
      { passive: true }
    );
  };
  const removeScrollListener = () => {
    var _a2;
    (_a2 = element.value) == null ? void 0 : _a2.removeEventListener(
      "scroll",
      handler.value
    );
  };
  onMounted(() => {
    if (!element.value) {
      return;
    }
    element.value.style.overflowY = "scroll";
    if (props.reverse) {
      element.value.scrollTop = element.value.scrollHeight;
    }
    addScrollListener();
  });
  onBeforeUnmount(removeScrollListener);
  return {
    addScrollListener,
    removeScrollListener
  };
};
const _hoisted_1$z = { class: "va-infinite-scroll__spinner__default" };
const _sfc_main$Q = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaInfiniteScroll"
  },
  __name: "VaInfiniteScroll",
  props: {
    ...useComponentPresetProp,
    load: { type: Function, required: true },
    offset: { type: [Number, String], default: 500 },
    reverse: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    scrollTarget: { type: [String, Object], default: null },
    debounce: { type: [Number, String], default: 100 },
    tag: { type: String, default: "div" }
  },
  emits: ["onload", "onerror"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const element = shallowRef();
    const spinnerSlotContainer = shallowRef();
    const fetching = ref(false);
    const error = ref(false);
    const forcedScrolling = ref(false);
    const debouncedLoad = ref();
    const notScrolledContentBeforeLoad = ref(0);
    const prevScrollTop = ref(0);
    const scrollTargetElement = computed(() => {
      var _a2;
      let target;
      if (typeof props.scrollTarget === "string") {
        target = document.querySelector(props.scrollTarget);
      } else {
        target = props.scrollTarget || ((_a2 = element.value) == null ? void 0 : _a2.parentElement);
      }
      return target || document.body;
    });
    const {
      addScrollListener,
      removeScrollListener
    } = useScroll(props, scrollTargetElement, debouncedLoad);
    const offsetComputed = useNumericProp("offset");
    const debounceComputed = useNumericProp("debounce");
    const { getColor } = useColors();
    const spinnerColor = computed(() => {
      return error.value ? getColor("danger") : getColor("primary");
    });
    const spinnerHeight = computed(() => {
      var _a2;
      return ((_a2 = spinnerSlotContainer.value) == null ? void 0 : _a2.offsetHeight) || 0;
    });
    const computedOffset = computed(() => {
      return offsetComputed.value + spinnerHeight.value;
    });
    const stop = () => {
      if (props.disabled) {
        return;
      }
      fetching.value = false;
      removeScrollListener();
    };
    const resume = () => {
      if (props.disabled) {
        return;
      }
      addScrollListener();
    };
    const onLoad = () => {
      const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value;
      notScrolledContentBeforeLoad.value = scrollHeight - scrollTop;
      const scrollDelta = scrollTop - prevScrollTop.value;
      prevScrollTop.value = scrollTop;
      if (props.disabled || error.value || fetching.value) {
        return;
      }
      if (forcedScrolling.value) {
        forcedScrolling.value = false;
        return;
      }
      const isReverseScrollDirection = props.reverse && scrollDelta > 0 || !props.reverse && scrollDelta < 0;
      if (isReverseScrollDirection) {
        return;
      }
      const offset2 = props.reverse ? scrollTop : scrollHeight - scrollTop - clientHeight;
      if (offset2 > computedOffset.value) {
        return;
      }
      fetching.value = true;
      props.load().then(finishLoading).catch(onError);
    };
    const forceSetScrollTopToTarget = (value) => {
      forcedScrolling.value = true;
      scrollTargetElement.value.scrollTop = value;
    };
    const updateTargetElementScrollTop = () => {
      const { scrollTop, scrollHeight, clientHeight } = scrollTargetElement.value;
      if (props.reverse) {
        const isScrolledUp = scrollHeight - scrollTop < notScrolledContentBeforeLoad.value;
        const isSpinnerHidden = scrollTop >= spinnerHeight.value;
        if (isScrolledUp && isSpinnerHidden) {
          return;
        }
        scrollHeight - notScrolledContentBeforeLoad.value > spinnerHeight.value ? forceSetScrollTopToTarget(scrollHeight - notScrolledContentBeforeLoad.value) : forceSetScrollTopToTarget(spinnerHeight.value);
      }
      if (!props.reverse) {
        const isSpinnerHidden = scrollHeight - scrollTop - clientHeight >= spinnerHeight.value;
        !isSpinnerHidden && forceSetScrollTopToTarget(scrollHeight - clientHeight - spinnerHeight.value);
      }
    };
    const finishLoading = () => {
      updateTargetElementScrollTop();
      fetching.value = false;
      emit2("onload");
    };
    const stopErrorDisplay = () => {
      updateTargetElementScrollTop();
      forcedScrolling.value = false;
      error.value = false;
      fetching.value = false;
      emit2("onerror");
    };
    const onError = () => {
      stop();
      error.value = true;
      sleep(1200).then(stopErrorDisplay).then(resume);
    };
    watch(() => debounceComputed.value, (value) => {
      debouncedLoad.value = debounce(onLoad, value);
    }, { immediate: true });
    watch(() => props.disabled, (value) => {
      value ? stop() : resume();
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(_ctx.$props.tag), {
        ref_key: "element",
        ref: element,
        role: "feed",
        class: normalizeClass(["va-infinite-scroll", { "va-infinite-scroll--reversed": _ctx.$props.reverse }]),
        "aria-busy": fetching.value
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default"),
          createBaseVNode("div", {
            ref_key: "spinnerSlotContainer",
            ref: spinnerSlotContainer,
            class: normalizeClass(["va-infinite-scroll__spinner", { "va-infinite-scroll__spinner--invisible": !fetching.value }])
          }, [
            !_ctx.$props.disabled ? renderSlot(_ctx.$slots, "loading", { key: 0 }, () => [
              createBaseVNode("div", _hoisted_1$z, [
                createVNode(unref(VaProgressCircle), {
                  size: "small",
                  thickness: 0.15,
                  color: spinnerColor.value,
                  indeterminate: ""
                }, null, 8, ["color"])
              ])
            ]) : createCommentVNode("", true)
          ], 2)
        ]),
        _: 3
      }, 8, ["class", "aria-busy"]);
    };
  }
});
const VaInfiniteScroll = withConfigTransport$1(_sfc_main$Q);
const areaIndexes = {
  top: [0, 1, 2],
  left: [0, 3, 6],
  right: [2, 5, 8],
  bottom: [6, 7, 8]
};
const areaElements = ["left", "right", "top", "bottom"];
const useGridTemplateArea = (props) => {
  const sort = () => {
    return [...areaElements].sort((a, b) => {
      return (props[a].order ?? 0) - (props[b].order ?? 0);
    });
  };
  const applyTemplate = (template, areaIndexes2, areaName) => {
    areaIndexes2.forEach((index) => {
      template[index] = areaName;
    });
  };
  return computed(() => {
    const sorted = sort();
    const template = [
      ".",
      ".",
      ".",
      ".",
      ".",
      ".",
      ".",
      ".",
      "."
    ].map(() => "content");
    sorted.forEach((areaName) => {
      applyTemplate(template, areaIndexes[areaName], areaName);
    });
    return [
      '"' + template.slice(0, 3).join(" ") + '"',
      '"' + template.slice(3, 6).join(" ") + '"',
      '"' + template.slice(6, 9).join(" ") + '"'
    ].join(" ");
  });
};
const useLayoutProps = {
  top: {
    type: Object,
    default: () => ({ order: 2 })
  },
  right: {
    type: Object,
    default: () => ({ order: 1 })
  },
  left: {
    type: Object,
    default: () => ({ order: 1 })
  },
  bottom: {
    type: Object,
    default: () => ({ order: 2 })
  }
};
const VaLayoutKey = "VaLayout";
const useLayout = (props) => {
  const items2 = ref({
    top: null,
    right: null,
    bottom: null,
    left: null
  });
  const paddings = computed(() => {
    const { top, right, bottom, left } = items2.value;
    const { top: topConfig, right: rightConfig, bottom: bottomConfig, left: leftConfig } = props;
    return {
      top: top && !topConfig.absolute ? top.sizes.height : 0,
      right: right && !rightConfig.absolute ? right.sizes.width : 0,
      bottom: bottom && !bottomConfig.absolute ? bottom.sizes.height : 0,
      left: left && !leftConfig.absolute ? left.sizes.width : 0
    };
  });
  const orders = computed(() => ({
    top: props.top.order || 0,
    right: props.right.order || 0,
    bottom: props.bottom.order || 0,
    left: props.left.order || 0
  }));
  provide(VaLayoutKey, {
    items: items2,
    paddings,
    orders
  });
  return {
    paddings,
    orders,
    items: items2
  };
};
const useFixedLayoutChild = (area, sizes) => {
  const layout = inject$1(VaLayoutKey, null);
  if (!layout) {
    throw new Error("VaLayoutChild must be used inside VaLayout");
  }
  watchEffect(() => {
    if (sizes.value) {
      layout.items.value[area] = {
        sizes: sizes.value
      };
    } else {
      layout.items.value[area] = null;
    }
  });
  onBeforeUnmount(() => {
    layout.items.value[area] = null;
  });
  return {
    paddings: computed(() => {
      return Object.keys(layout.paddings.value).reduce((acc, key) => {
        if (layout.orders.value[key] > layout.orders.value[area]) {
          acc[key] = layout.paddings.value[key];
        }
        return acc;
      }, {});
    })
  };
};
const _sfc_main$P = {};
const _hoisted_1$y = { class: "va-layout__absolute-area-wrapper" };
function _sfc_render$1(_ctx, _cache) {
  return openBlock(), createElementBlock("div", _hoisted_1$y, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
const VaLayoutAbsoluteWrapper = /* @__PURE__ */ _export_sfc(_sfc_main$P, [["render", _sfc_render$1]]);
const _sfc_main$O = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaLayoutSizeKeeper"
  },
  __name: "VaResizeObserver",
  emits: {
    resize: (size2) => true
  },
  setup(__props, { emit: __emit }) {
    const emit2 = __emit;
    const el = ref();
    let observer = null;
    watch(el, (newEl) => {
      if (observer) {
        observer.disconnect();
      }
      observer = new ResizeObserver(([el2]) => {
        emit2("resize", el2.contentRect);
      });
      observer.observe(newEl);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "va-resize-observer",
        ref_key: "el",
        ref: el
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 512);
    };
  }
});
const _sfc_main$N = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaLayoutFixedWrapper"
  },
  __name: "VaLayoutFixedWrapper",
  props: {
    area: { type: String, required: true }
  },
  setup(__props) {
    const props = __props;
    const size2 = ref(null);
    const direction = computed(() => {
      if (props.area === "top" || props.area === "bottom") {
        return "vertical";
      } else {
        return "horizontal";
      }
    });
    const getPxOrZero = (value) => {
      if (!value) {
        return "0px";
      }
      return value + "px";
    };
    const styles = computed(() => {
      if (direction.value === "vertical") {
        return { width: `calc(100% - ${getPxOrZero(paddings.value.left)} - ${getPxOrZero(paddings.value.right)})`, [props.area]: 0 };
      } else {
        return { height: `calc(100% - ${getPxOrZero(paddings.value.top)} - ${getPxOrZero(paddings.value.bottom)})`, [props.area]: 0 };
      }
    });
    const { paddings } = useFixedLayoutChild(props.area, size2);
    computed(() => {
      return Object.keys(paddings.value).reduce((acc, key) => {
        if (key === props.area) {
          return acc;
        }
        return {
          ...acc,
          [key]: `${paddings.value[key]}px`
        };
      }, {});
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "va-layout-fixed-wrapper",
        style: normalizeStyle([[{
          height: size2.value && direction.value === "vertical" ? size2.value.height + "px" : "auto",
          width: size2.value && direction.value === "horizontal" ? size2.value.width + "px" : "auto"
        }], `--va-styles-width: ${String(styles.value.width)};--va-styles-height: ${String(styles.value.height)}`])
      }, [
        createVNode(_sfc_main$O, {
          class: normalizeClass(["va-layout-fixed-wrapper__content", `va-layout-fixed-wrapper__content--${__props.area}`]),
          style: normalizeStyle(!size2.value ? { position: "relative" } : {}),
          onResize: _cache[0] || (_cache[0] = ($event) => size2.value = $event)
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 8, ["class", "style"])
      ], 4);
    };
  }
});
const _sfc_main$M = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaLayoutArea"
  },
  __name: "VaLayoutArea",
  props: {
    area: { type: String, required: true },
    config: { type: Object, required: true }
  },
  emits: ["overlay-click"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const absolute = computed(() => props.config.absolute || false);
    const fixed = computed(() => props.config.fixed || false);
    const overlay = computed(() => props.config.overlay || false);
    const zIndex = computed(() => (props.config.order || 0) + 1);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        absolute.value ? (openBlock(), createBlock(VaLayoutAbsoluteWrapper, {
          key: 0,
          style: normalizeStyle(`--va-props-area: ${String(_ctx.$props.area)};--va-z-index: ${String(zIndex.value)};--va-z-index-1: ${String(zIndex.value - 1)}`)
        }, {
          default: withCtx(() => [
            createBaseVNode("div", {
              class: normalizeClass(`va-layout-area va-layout__area va-layout__area--${__props.area}`)
            }, [
              fixed.value ? (openBlock(), createBlock(_sfc_main$N, {
                key: 0,
                area: __props.area
              }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default")
                ]),
                _: 3
              }, 8, ["area"])) : renderSlot(_ctx.$slots, "default", { key: 1 })
            ], 2)
          ]),
          _: 3
        }, 8, ["style"])) : (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(`va-layout-area va-layout__area va-layout__area--${__props.area}`),
          style: normalizeStyle(`--va-props-area: ${String(_ctx.$props.area)};--va-z-index: ${String(zIndex.value)};--va-z-index-1: ${String(zIndex.value - 1)}`)
        }, [
          fixed.value ? (openBlock(), createBlock(_sfc_main$N, {
            key: 0,
            area: __props.area
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["area"])) : renderSlot(_ctx.$slots, "default", { key: 1 })
        ], 6)),
        createVNode(Transition, {
          style: normalizeStyle(`--va-props-area: ${String(_ctx.$props.area)};--va-z-index: ${String(zIndex.value)};--va-z-index-1: ${String(zIndex.value - 1)}`)
        }, {
          default: withCtx(() => [
            overlay.value ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(["va-layout-area__overlay", { "va-layout-area__overlay--fixed": fixed.value }]),
              onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("overlay-click"))
            }, null, 2)) : createCommentVNode("", true)
          ]),
          _: 1
        }, 8, ["style"])
      ], 64);
    };
  }
});
const _hoisted_1$x = { class: "va-layout__area va-layout__area--content" };
const areaNames = [
  "top",
  "left",
  "right",
  "bottom"
];
const _sfc_main$L = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaLayout"
  },
  __name: "VaLayout",
  props: {
    ...useLayoutProps,
    allowBodyScrollOnOverlay: { type: Boolean, default: false }
  },
  emits: [
    "top-overlay-click",
    "left-overlay-click",
    "right-overlay-click",
    "bottom-overlay-click"
  ],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const { paddings } = useLayout(props);
    const doDisableScroll = computed(() => {
      return !props.allowBodyScrollOnOverlay && areaNames.some((area) => {
        var _a2;
        return (_a2 = props[area]) == null ? void 0 : _a2.overlay;
      });
    });
    const document2 = useDocument();
    watchEffect(() => {
      var _a2;
      const overflowParent = (_a2 = document2.value) == null ? void 0 : _a2.body;
      if (!overflowParent) {
        return;
      }
      if (doDisableScroll.value) {
        overflowParent.style.overflow = "hidden";
      } else {
        overflowParent.style.overflow = "";
      }
    });
    const templateArea = useGridTemplateArea(props);
    const slots = useSlots();
    const verticalTemplate = computed(() => {
      return [
        slots.top ? "min-content" : "0fr",
        "1fr",
        slots.bottom ? "min-content" : "0fr"
      ].filter(Boolean).join(" ");
    });
    const horizontalTemplate = computed(() => {
      return [
        slots.left ? "min-content" : "0fr",
        "1fr",
        slots.right ? "min-content" : "0fr"
      ].filter(Boolean).join(" ");
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "va-layout",
        style: normalizeStyle(`--va-horizontal-template: ${String(horizontalTemplate.value)};--va-vertical-template: ${String(verticalTemplate.value)};--va-template-area: ${String(unref(templateArea))};--va-paddings-top-px: ${String(unref(paddings).top + "px")};--va-paddings-bottom-px: ${String(unref(paddings).bottom + "px")};--va-paddings-left-px: ${String(unref(paddings).left + "px")};--va-paddings-right-px: ${String(unref(paddings).right + "px")}`)
      }, [
        (openBlock(), createElementBlock(Fragment, null, renderList(areaNames, (area) => {
          return createVNode(_sfc_main$M, {
            key: area,
            area,
            config: _ctx.$props[area] || {},
            onOverlayClick: ($event) => _ctx.$emit(`${area}-overlay-click`)
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, area)
            ]),
            _: 2
          }, 1032, ["area", "config", "onOverlayClick"]);
        }), 64)),
        createBaseVNode("div", _hoisted_1$x, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            renderSlot(_ctx.$slots, "content")
          ])
        ])
      ], 4);
    };
  }
});
const VaLayout = withConfigTransport(_sfc_main$L);
const _hoisted_1$w = { class: "va-navbar__left" };
const _hoisted_2$g = { class: "va-navbar__center" };
const _hoisted_3$b = { class: "va-navbar__right" };
const _sfc_main$K = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaNavbar"
  },
  __name: "VaNavbar",
  props: {
    ...useFixedBarProps,
    ...useComponentPresetProp,
    color: { type: String, default: "background-secondary" },
    textColor: { type: String },
    shape: { type: Boolean, default: false },
    shadowed: { type: Boolean, default: false },
    bordered: { type: Boolean, default: false }
  },
  setup(__props) {
    const props = __props;
    const { scrollRoot, isScrolledDown } = setupScroll(props.fixed);
    const { fixedBarStyleComputed } = useFixedBar(props, isScrolledDown);
    const { getColor, shiftHSLAColor: shiftHSLAColor2 } = useColors();
    const color = computed(() => getColor(props.color));
    const { textColorComputed } = useTextColor(color);
    const shapeStyleComputed = computed(() => ({
      borderTopColor: shiftHSLAColor2(color.value, { h: -1, s: -11, l: 10 })
    }));
    const computedStyle = computed(() => ({
      ...fixedBarStyleComputed.value,
      backgroundColor: color.value,
      color: textColorComputed.value,
      fill: textColorComputed.value
    }));
    const bemClasses = useBem("va-navbar", () => ({
      shadowed: props.shadowed,
      bordered: props.bordered
    }));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("header", {
        ref_key: "scrollRoot",
        ref: scrollRoot,
        class: normalizeClass(["va-navbar", unref(bemClasses)]),
        style: normalizeStyle(computedStyle.value)
      }, [
        renderSlot(_ctx.$slots, "default", {}, () => [
          createBaseVNode("div", _hoisted_1$w, [
            renderSlot(_ctx.$slots, "left")
          ]),
          createBaseVNode("div", _hoisted_2$g, [
            renderSlot(_ctx.$slots, "center")
          ]),
          createBaseVNode("div", _hoisted_3$b, [
            renderSlot(_ctx.$slots, "right")
          ])
        ]),
        __props.shape ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "va-navbar__background-shape",
          style: normalizeStyle(shapeStyleComputed.value)
        }, null, 4)) : createCommentVNode("", true)
      ], 6);
    };
  }
});
const _sfc_main$J = /* @__PURE__ */ defineComponent({
  name: "VaNavbarItem",
  props: {}
  // TODO: In web components build props are required (it's a vue bug)
});
const _hoisted_1$v = { class: "va-navbar__item" };
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$v, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
const _VaNavbarItem = /* @__PURE__ */ _export_sfc(_sfc_main$J, [["render", _sfc_render]]);
const VaNavbar = withConfigTransport$1(_sfc_main$K);
const VaNavbarItem = withConfigTransport$1(_VaNavbarItem);
const _hoisted_1$u = ["role"];
const _hoisted_2$f = ["value", "checked", "aria-checked", "onChange"];
const _hoisted_3$a = /* @__PURE__ */ createBaseVNode("span", {
  "aria-hidden": "true",
  class: "va-radio__icon"
}, [
  /* @__PURE__ */ createBaseVNode("span", { class: "va-radio__icon__background" }),
  /* @__PURE__ */ createBaseVNode("span", { class: "va-radio__icon__dot" })
], -1);
const _sfc_main$I = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaRadio"
  },
  __name: "VaRadio",
  props: {
    ...useSelectableProps$1,
    ...useComponentPresetProp,
    ...useSelectableListProps,
    modelValue: {
      type: [Boolean, Array, String, Object, Number],
      default: null
    },
    options: {
      type: Array,
      default: () => []
    },
    name: { type: String, default: "" },
    label: { type: String, default: void 0 },
    leftLabel: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    option: {
      type: [Object, String, Number],
      default: void 0
    },
    vertical: { type: Boolean, default: false }
  },
  emits: useSelectableEmits,
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const { getColor } = useColors();
    const elements = {
      container: shallowRef(),
      input: shallowRef(),
      label: shallowRef()
    };
    const {
      computedError,
      computedErrorMessages,
      onBlur,
      onFocus
    } = useSelectable(props, emit2, elements);
    const { getText: originalGetText, getDisabled: originalGetDisabled, getValue: getValue2 } = useSelectableList(props);
    const getText = (option) => {
      if (props.options.length > 0) {
        return originalGetText(option);
      }
      return props.label ?? originalGetText(option);
    };
    const getDisabled = (option) => originalGetDisabled(option) || props.disabled;
    const isNoOption = computed(() => props.options.length === 0 && !props.option);
    const isChecked = (option) => {
      if (isNoOption.value) {
        return props.modelValue;
      }
      return props.modelValue === getValue2(option);
    };
    const computedOptions = computed(() => {
      if (isNoOption.value) {
        return [{}];
      }
      if (props.option) {
        return [props.option];
      } else {
        return props.options;
      }
    });
    const radioClass = (option) => ({
      "va-radio--left-label": props.leftLabel,
      "va-radio--selected": isChecked(option),
      "va-radio--readonly": props.readonly,
      "va-radio--disabled": props.disabled,
      "va-radio--indeterminate": props.indeterminate,
      "va-radio--error": computedError.value,
      "va-radio--single-option": isNoOption.value
    });
    const selectOption = (option, event) => {
      var _a2;
      if (isNoOption.value) {
        emit2("update:modelValue", ((_a2 = event == null ? void 0 : event.target) == null ? void 0 : _a2.checked) || false);
        return;
      }
      emit2("update:modelValue", option);
    };
    const labelStyle = computed(() => {
      return {
        color: computedError.value ? getColor("danger") : ""
      };
    });
    computed(() => {
      const style = {
        background: getColor(props.color),
        borderColor: getColor(props.color)
      };
      if (computedError.value) {
        style.borderColor = getColor("danger");
      }
      return style;
    });
    const iconBackgroundComputedStyles = computed(() => ({
      backgroundColor: getColor(props.color)
    }));
    const iconDotComputedStyles = computed(() => {
      return {
        borderColor: computedError.value ? getColor("danger") : getColor(props.color),
        backgroundColor: getColor(props.color)
      };
    });
    const iconComputedStyles = computed(() => {
      return { borderColor: computedError.value ? getColor("danger") : getColor(props.color) };
    });
    const componentId = useComponentUuid();
    const computedName = computed(() => props.name || componentId);
    const inputAttributesComputed = (option) => {
      const disabled = getDisabled(option);
      return {
        name: computedName.value,
        disabled,
        readonly: props.readonly,
        tabindex: disabled ? -1 : 0
      };
    };
    const flexDirection = computed(() => props.vertical ? "column" : "row");
    const roleComputed = computed(() => {
      var _a2;
      return ((_a2 = props.options) == null ? void 0 : _a2.length) > 0 ? "radiogroup" : "";
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$1X), {
        disabled: _ctx.disabled,
        success: _ctx.success,
        messages: _ctx.messages,
        error: unref(computedError),
        "error-messages": unref(computedErrorMessages),
        "error-count": _ctx.errorCount,
        onBlur: unref(onBlur),
        style: normalizeStyle(`--va-flex-direction: ${String(flexDirection.value)};--va-label-style-color: ${String(labelStyle.value.color)};--va-icon-computed-styles-border-color: ${String(iconComputedStyles.value.borderColor)};--va-icon-dot-computed-styles-border-color: ${String(iconDotComputedStyles.value.borderColor)};--va-icon-dot-computed-styles-background-color: ${String(iconDotComputedStyles.value.backgroundColor)};--va-icon-background-computed-styles-background-color: ${String(iconBackgroundComputedStyles.value.backgroundColor)}`)
      }, {
        default: withCtx(({ ariaAttributes }) => [
          createBaseVNode("div", mergeProps$1({
            ref: "container",
            class: "va-radio",
            role: roleComputed.value
          }, ariaAttributes), [
            (openBlock(true), createElementBlock(Fragment, null, renderList(computedOptions.value, (option, index) => {
              return openBlock(), createElementBlock("label", {
                key: index,
                class: normalizeClass([radioClass(option), "va-radio__square"])
              }, [
                createBaseVNode("input", mergeProps$1({
                  ref_for: true,
                  ref: "input",
                  class: "va-radio__input",
                  type: "radio",
                  role: "radio",
                  value: isChecked(option),
                  checked: isChecked(option),
                  "aria-checked": isChecked(option)
                }, { ...inputAttributesComputed(option), ...ariaAttributes }, {
                  onChange: ($event) => selectOption(unref(getValue2)(option), $event),
                  onFocus: _cache[0] || (_cache[0] = //@ts-ignore
                  (...args) => unref(onFocus) && unref(onFocus)(...args)),
                  onBlur: _cache[1] || (_cache[1] = //@ts-ignore
                  (...args) => unref(onBlur) && unref(onBlur)(...args))
                }), null, 16, _hoisted_2$f),
                renderSlot(_ctx.$slots, "icon", normalizeProps$1(guardReactiveProps({
                  value: isChecked(option),
                  text: getText(option),
                  disabled: getDisabled(option),
                  index
                })), () => [
                  _hoisted_3$a
                ]),
                getText(option) || _ctx.$slots.default ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  ref_for: true,
                  ref: "label",
                  class: "va-radio__text"
                }, [
                  renderSlot(_ctx.$slots, "default", normalizeProps$1(guardReactiveProps({
                    value: isChecked(option),
                    text: getText(option),
                    disabled: getDisabled(option),
                    index
                  })), () => [
                    createTextVNode(toDisplayString(getText(option)), 1)
                  ])
                ], 512)) : createCommentVNode("", true)
              ], 2);
            }), 128))
          ], 16, _hoisted_1$u)
        ]),
        _: 3
      }, 8, ["disabled", "success", "messages", "error", "error-messages", "error-count", "onBlur", "style"]);
    };
  }
});
const VaRadio = withConfigTransport$1(_sfc_main$I);
const _hoisted_1$t = { class: "va-switch__inner" };
const _hoisted_2$e = { class: "va-switch__checker-wrapper" };
const _hoisted_3$9 = { class: "va-switch__checker" };
const _hoisted_4$7 = { class: "va-switch__checker-circle" };
const _hoisted_5$4 = ["id"];
const _sfc_main$H = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaSwitch"
  },
  __name: "VaSwitch",
  props: {
    ...useSelectableProps$1,
    ...useComponentPresetProp,
    id: { type: String, default: "" },
    name: { type: String, default: "" },
    modelValue: {
      type: [Number, Boolean, Array, String, Object],
      default: false
    },
    trueLabel: { type: String, default: null },
    falseLabel: { type: String, default: null },
    trueInnerLabel: { type: String, default: null },
    falseInnerLabel: { type: String, default: null },
    ariaLabel: useTranslationProp("$t:switch"),
    color: { type: String, default: "primary" },
    offColor: { type: String, default: "background-element" },
    size: {
      type: String,
      default: "medium",
      validator: (value) => ["medium", "small", "large"].includes(value)
    }
  },
  emits: [
    ...useSelectableEmits,
    "focus",
    "blur",
    "update:modelValue"
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const elements = {
      container: shallowRef(),
      input: shallowRef(),
      label: shallowRef()
    };
    const { getColor } = useColors();
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const {
      isChecked,
      computedError,
      isIndeterminate,
      computedErrorMessages,
      validationAriaAttributes,
      toggleSelection,
      onBlur,
      onFocus,
      reset,
      focus,
      isDirty: isDirty2,
      isTouched,
      isLoading,
      isError
    } = useSelectable(props, emit2, elements);
    const computedBackground = computed(() => getColor(isChecked.value ? props.color : props.offColor));
    const { textColorComputed } = useTextColor(computedBackground);
    const computedInnerLabel = computed(() => {
      if (props.trueInnerLabel && isChecked.value) {
        return props.trueInnerLabel;
      }
      if (props.falseInnerLabel && !isChecked.value) {
        return props.falseInnerLabel;
      }
      return "";
    });
    const computedLabel = computed(() => {
      if (props.trueLabel && isChecked.value) {
        return props.trueLabel;
      }
      if (props.falseLabel && !isChecked.value) {
        return props.falseLabel;
      }
      return props.label;
    });
    const computedClass = useBem("va-switch", () => ({
      ...pick(props, ["readonly", "disabled", "leftLabel"]),
      checked: isChecked.value,
      indeterminate: isIndeterminate.value,
      small: props.size === "small",
      large: props.size === "large",
      error: computedError.value,
      keyboardFocus: hasKeyboardFocus.value
    }));
    const styleComputed = computed(() => ({
      lineHeight: computedErrorMessages.value.length ? 1 : 0
    }));
    const progressCircleSize = computed(() => {
      const size2 = { small: "15px", medium: "20px", large: "25px" };
      return size2[props.size];
    });
    const trackStyle = computed(() => ({
      borderColor: computedError.value ? getColor("danger") : "",
      backgroundColor: computedBackground.value
    }));
    const labelStyle = computed(() => ({
      color: computedError.value ? getColor("danger") : ""
    }));
    const trackLabelStyle = computed(() => ({
      color: textColorComputed.value,
      "text-align": isChecked.value ? "left" : "right"
    }));
    const slots = useSlots();
    const componentId = useComponentUuid();
    const ariaLabelIdComputed = computed(() => `aria-label-id-${componentId}`);
    const inputAttributesComputed = computed(() => ({
      id: props.id || void 0,
      name: props.name || void 0,
      disabled: props.disabled,
      readonly: props.readonly,
      "aria-disabled": props.disabled,
      "aria-readonly": props.readonly,
      "aria-checked": !!props.modelValue,
      "aria-label": !slots.default ? props.ariaLabel : void 0,
      "aria-labelledby": computedLabel.value || slots.default ? ariaLabelIdComputed.value : void 0,
      tabindex: props.disabled ? -1 : 0,
      checked: isChecked.value,
      ...validationAriaAttributes.value
    }));
    const onEnterKeyPress = () => {
      var _a2;
      (_a2 = elements.input.value) == null ? void 0 : _a2.click();
    };
    const input = elements.input;
    __expose({
      focus,
      reset,
      isDirty: isDirty2,
      isTouched,
      isLoading,
      isError
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$1X), {
        class: normalizeClass(["va-switch", unref(computedClass)]),
        style: normalizeStyle(styleComputed.value),
        disabled: _ctx.$props.disabled,
        success: _ctx.$props.success,
        messages: _ctx.$props.messages,
        error: unref(computedError),
        "error-messages": unref(computedErrorMessages),
        "error-count": _ctx.$props.errorCount
      }, {
        default: withCtx(() => [
          createBaseVNode("div", {
            ref: "container",
            class: "va-switch__container",
            tabindex: "-1",
            onBlur: _cache[5] || (_cache[5] = //@ts-ignore
            (...args) => unref(onBlur) && unref(onBlur)(...args)),
            onClick: _cache[6] || (_cache[6] = //@ts-ignore
            (...args) => unref(toggleSelection) && unref(toggleSelection)(...args))
          }, [
            createBaseVNode("div", _hoisted_1$t, [
              createBaseVNode("input", mergeProps$1({
                ref_key: "input",
                ref: input,
                type: "checkbox",
                class: "va-switch__input",
                role: "switch"
              }, inputAttributesComputed.value, toHandlers(unref(keyboardFocusListeners), true), {
                onFocus: _cache[0] || (_cache[0] = //@ts-ignore
                (...args) => unref(onFocus) && unref(onFocus)(...args)),
                onBlur: _cache[1] || (_cache[1] = //@ts-ignore
                (...args) => unref(onBlur) && unref(onBlur)(...args)),
                onKeypress: withKeys(onEnterKeyPress, ["enter"])
              }), null, 16),
              createBaseVNode("div", {
                class: "va-switch__track",
                "aria-hidden": "true",
                style: normalizeStyle(trackStyle.value)
              }, [
                computedInnerLabel.value || _ctx.$slots.innerLabel ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: "va-switch__track-label",
                  style: normalizeStyle(trackLabelStyle.value)
                }, [
                  renderSlot(_ctx.$slots, "innerLabel", {}, () => [
                    createTextVNode(toDisplayString(computedInnerLabel.value), 1)
                  ])
                ], 4)) : createCommentVNode("", true),
                createBaseVNode("div", _hoisted_2$e, [
                  createBaseVNode("div", _hoisted_3$9, [
                    renderSlot(_ctx.$slots, "checker", normalizeProps$1(guardReactiveProps({ value: unref(isChecked) })), () => [
                      createBaseVNode("div", _hoisted_4$7, [
                        _ctx.$props.loading ? (openBlock(), createBlock(unref(VaProgressCircle), {
                          key: 0,
                          indeterminate: "",
                          size: progressCircleSize.value,
                          color: trackStyle.value.backgroundColor
                        }, null, 8, ["size", "color"])) : createCommentVNode("", true)
                      ])
                    ])
                  ])
                ])
              ], 4)
            ]),
            computedLabel.value || _ctx.$slots.default ? (openBlock(), createElementBlock("div", {
              key: 0,
              ref: "label",
              class: "va-switch__label",
              style: normalizeStyle(labelStyle.value),
              id: ariaLabelIdComputed.value,
              onBlur: _cache[2] || (_cache[2] = //@ts-ignore
              (...args) => unref(onBlur) && unref(onBlur)(...args)),
              onClick: _cache[3] || (_cache[3] = //@ts-ignore
              (...args) => unref(toggleSelection) && unref(toggleSelection)(...args)),
              onKeydown: _cache[4] || (_cache[4] = withKeys(withModifiers(
                //@ts-ignore
                (...args) => unref(toggleSelection) && unref(toggleSelection)(...args),
                ["stop"]
              ), ["enter"]))
            }, [
              renderSlot(_ctx.$slots, "default", {}, () => [
                createTextVNode(toDisplayString(computedLabel.value), 1)
              ])
            ], 44, _hoisted_5$4)) : createCommentVNode("", true)
          ], 544)
        ]),
        _: 3
      }, 8, ["class", "style", "disabled", "success", "messages", "error", "error-messages", "error-count"]);
    };
  }
});
const VaSwitch = withConfigTransport$1(_sfc_main$H);
const useArrayRefs = () => {
  const itemRefs = shallowRef([]);
  const setItemRef = (el) => {
    if (!el) {
      return;
    }
    itemRefs.value.push(el);
  };
  const setItemRefByIndex = (index) => (el) => {
    if (!el) {
      return;
    }
    itemRefs.value[index] = el;
  };
  onBeforeUpdate(() => {
    itemRefs.value = [];
  });
  return {
    itemRefs,
    setItemRef,
    setItemRefByIndex
  };
};
const _hoisted_1$s = { class: "va-option-list__list" };
const _sfc_main$G = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaOptionList"
  },
  __name: "VaOptionList",
  props: {
    ...useComponentPresetProp,
    ...useSelectableListProps,
    ...useValidationProps,
    ...useStatefulProps,
    type: {
      type: String,
      default: "checkbox",
      validator: (type) => ["radio", "checkbox", "switch"].includes(type)
    },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    defaultValue: { type: [String, Number, Boolean, Object, Array] },
    name: { type: String, default: "" },
    color: { type: String, default: "primary" },
    leftLabel: { type: Boolean, default: false },
    modelValue: { type: [String, Number, Boolean, Object, Array] }
  },
  emits: [...useStatefulEmits, ...useValidationEmits, "clear"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const { valueComputed } = useStateful(props, emit2, "modelValue", { defaultValue: props.defaultValue });
    const { getValue: getValue2, getText, getTrackBy, getDisabled } = useSelectableList(props);
    const { itemRefs, setItemRef } = useArrayRefs();
    const isRadio = computed(() => props.type === "radio");
    const selectedValue = computed({
      get() {
        const value = isRadio.value ? null : [];
        return valueComputed.value || value;
      },
      set(value) {
        if (props.readonly) {
          return;
        }
        if (isRadio.value && !Array.isArray(value)) {
          valueComputed.value = value ? getValue2(value) : value;
        } else {
          valueComputed.value = Array.isArray(value) ? value.map(getValue2) : [value ? getValue2(value) : value];
        }
      }
    });
    const isDisabled = (option) => props.disabled || getDisabled(option);
    const reset = () => withoutValidation(() => {
      valueComputed.value = null;
      emit2("clear");
      resetValidation();
    });
    const focus = () => {
      const firstActiveEl = Array.isArray(itemRefs.value) && itemRefs.value.find((el) => !el.disabled);
      if (firstActiveEl && typeof firstActiveEl.focus === "function") {
        firstActiveEl.focus();
      }
    };
    const {
      computedError,
      computedErrorMessages,
      withoutValidation,
      resetValidation
    } = useValidation(props, emit2, { reset, focus, value: valueComputed });
    const computedProps = computed(() => pick(props, ["name", "color", "readonly", "leftLabel"]));
    onMounted(() => {
      if (isDev && props.type !== "radio" && !Array.isArray(props.modelValue)) {
        console.warn(`Prop 'modelValue = ${props.modelValue}' has not a proper type!
 For component property 'type = ${props.type}' it must be of type 'array'.`);
      }
    });
    __expose({
      focus,
      reset
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$1X), {
        error: unref(computedError),
        "error-messages": unref(computedErrorMessages),
        "error-count": _ctx.$props.errorCount
      }, {
        default: withCtx(() => [
          createBaseVNode("ul", _hoisted_1$s, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.options, (option) => {
              return openBlock(), createElementBlock("li", {
                key: unref(getTrackBy)(option)
              }, [
                renderSlot(_ctx.$slots, "default", normalizeProps$1(guardReactiveProps({ option, selectedValue: selectedValue.value, isDisabled, getText: unref(getText), getValue: unref(getValue2) })), () => [
                  _ctx.$props.type === "radio" ? (openBlock(), createBlock(unref(VaRadio), mergeProps$1({
                    key: 0,
                    ref_for: true,
                    ref: unref(setItemRef),
                    modelValue: selectedValue.value,
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => selectedValue.value = $event),
                    label: unref(getText)(option),
                    disabled: isDisabled(option),
                    option: unref(getValue2)(option)
                  }, computedProps.value), null, 16, ["modelValue", "label", "disabled", "option"])) : _ctx.$props.type === "checkbox" ? (openBlock(), createBlock(unref(VaCheckbox), mergeProps$1({
                    key: 1,
                    ref_for: true,
                    ref: unref(setItemRef),
                    modelValue: selectedValue.value,
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => selectedValue.value = $event),
                    label: unref(getText)(option),
                    disabled: isDisabled(option),
                    "array-value": unref(getValue2)(option)
                  }, computedProps.value), null, 16, ["modelValue", "label", "disabled", "array-value"])) : (openBlock(), createBlock(unref(VaSwitch), mergeProps$1({
                    key: 2,
                    ref_for: true,
                    ref: unref(setItemRef),
                    modelValue: selectedValue.value,
                    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => selectedValue.value = $event),
                    label: unref(getText)(option),
                    disabled: isDisabled(option),
                    "array-value": unref(getValue2)(option)
                  }, computedProps.value), null, 16, ["modelValue", "label", "disabled", "array-value"]))
                ])
              ]);
            }), 128))
          ])
        ]),
        _: 3
      }, 8, ["error", "error-messages", "error-count"]);
    };
  }
});
const VaOptionList = withConfigTransport$1(_sfc_main$G);
const setPaginationRange = (currentPage = 1, visiblePages, pages, includeBoundary = false) => {
  let start = 0;
  if (pages === 0) {
    pages = 1;
  }
  if (visiblePages > pages) {
    visiblePages = pages;
  }
  if (visiblePages === 0) {
    start = 1;
    visiblePages = pages > 10 ? 10 : pages;
  } else {
    const paginationMiddlePage = visiblePages / 2;
    if (currentPage - paginationMiddlePage <= 0 || currentPage > pages) {
      start = 1;
    } else {
      start = currentPage + paginationMiddlePage > pages ? pages - visiblePages + 1 : Math.ceil(currentPage - paginationMiddlePage);
    }
  }
  const range = [];
  for (let i = 0; i < visiblePages; i++) {
    range.push(start + i);
  }
  if (includeBoundary && visiblePages < 7) {
    pages >= 7 && warn(
      "[va-pagination] To work in a proper way, the `boundaryNumbers` prop needs at least 7 visible pages to be set via the `visiblePages` prop (first, last, 2 boundaries, current, previous, next)."
    );
  } else if (includeBoundary) {
    start !== 1 && range.splice(0, 2, 1, "...");
    range[range.length - 1] !== pages && range.splice(-2, 2, "...", pages);
  }
  return range;
};
const _hoisted_1$r = ["aria-label", "onKeydown"];
const _hoisted_2$d = ["aria-label"];
const _sfc_main$F = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaPagination"
  },
  __name: "VaPagination",
  props: {
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: Number, default: 1 },
    visiblePages: { type: [Number, String], default: 0 },
    pages: { type: [Number, String], default: 0 },
    disabled: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    size: {
      type: String,
      default: "medium",
      validator: (v) => ["small", "medium", "large"].includes(v)
    },
    boundaryLinks: { type: Boolean, default: true },
    boundaryNumbers: { type: Boolean, default: false },
    directionLinks: { type: Boolean, default: true },
    input: { type: Boolean, default: false },
    hideOnSinglePage: { type: Boolean, default: false },
    total: { type: [Number, String], default: null },
    pageSize: { type: [Number, String], default: null },
    boundaryIconLeft: { type: String, default: "va-arrow-first" },
    boundaryIconRight: { type: String, default: "va-arrow-last" },
    directionIconLeft: { type: String, default: "va-arrow-left" },
    directionIconRight: { type: String, default: "va-arrow-right" },
    gapped: { type: Boolean, default: false },
    borderColor: { type: String, default: "" },
    rounded: { type: Boolean, default: false },
    /** @deprecated Use activeButtonProps="{ color: 'myColor' }" */
    activePageColor: { type: String, default: "" },
    activeButtonProps: { type: Object, default: () => ({}) },
    buttonProps: { type: Object, default: () => ({}) },
    buttonsPreset: { type: String, default: "primary" },
    ariaLabel: useTranslationProp("$t:pagination"),
    ariaGoToTheFirstPageLabel: useTranslationProp("$t:goToTheFirstPage"),
    ariaGoToPreviousPageLabel: useTranslationProp("$t:goToPreviousPage"),
    ariaGoToSpecificPageLabel: useTranslationProp("$t:goToSpecificPage"),
    ariaGoToSpecificPageInputLabel: useTranslationProp("$t:goToSpecificPageInput"),
    ariaGoToNextPageLabel: useTranslationProp("$t:goNextPage"),
    ariaGoToLastPageLabel: useTranslationProp("$t:goLastPage")
  },
  emits: [...useStatefulEmits],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const htmlInput = shallowRef();
    const inputValue = ref("");
    const usesTotal = computed(() => !!((totalComputed.value || totalComputed.value === 0) && pageSizeComputed.value));
    const { valueComputed } = useStateful(props, emit2);
    const currentValue = computed({
      get: () => usesTotal.value ? Math.ceil(valueComputed.value / pageSizeComputed.value) || 1 : valueComputed.value,
      set: (value) => {
        valueComputed.value = value;
      }
    });
    const visiblePagesComputed = useNumericProp("visiblePages");
    const pagesComputed = useNumericProp("pages");
    const totalComputed = useNumericProp("total");
    const pageSizeComputed = useNumericProp("pageSize");
    const paginationRange = computed(() => {
      const { boundaryNumbers } = props;
      const value = currentValue.value || 1;
      const totalPages = usesTotal.value ? Math.ceil(totalComputed.value / pageSizeComputed.value) : pagesComputed.value;
      return setPaginationRange(value, visiblePagesComputed.value, totalPages, boundaryNumbers);
    });
    const lastPage = computed(() => usesTotal.value ? Math.ceil(totalComputed.value / pageSizeComputed.value) || 1 : +pagesComputed.value);
    const isLastPageNotVisible = computed(() => !!visiblePagesComputed.value && lastPage.value > visiblePagesComputed.value || props.input);
    const showBoundaryLinks = computed(() => {
      const { boundaryLinks, boundaryNumbers } = props;
      return isLastPageNotVisible.value && boundaryLinks && !boundaryNumbers;
    });
    const showDirectionLinks = computed(() => isLastPageNotVisible.value && props.directionLinks);
    const showPagination = computed(() => lastPage.value > 1 || !props.hideOnSinglePage && lastPage.value <= 1);
    const focusInput = () => {
      inputValue.value = String(currentValue.value);
      nextTick(() => {
        var _a2;
        return (_a2 = htmlInput.value) == null ? void 0 : _a2.setSelectionRange(0, htmlInput.value.value.length);
      });
    };
    const { setItemRefByIndex, itemRefs } = useArrayRefs();
    const onUserInput = (pageNum) => {
      var _a2;
      if (pageNum === "..." || pageNum === currentValue.value) {
        return;
      }
      const limitedPageNum = clamp$1(pageNum, 1, lastPage.value);
      currentValue.value = usesTotal.value ? (limitedPageNum - 1) * pageSizeComputed.value + 1 : limitedPageNum;
      (_a2 = itemRefs.value[pageNum - 1]) == null ? void 0 : _a2.focus();
    };
    const resetInput = () => {
      var _a2;
      inputValue.value = "";
      (_a2 = htmlInput.value) == null ? void 0 : _a2.blur();
    };
    const changeValue = () => {
      if (+inputValue.value === currentValue.value) {
        resetInput();
      }
      if (!inputValue.value.length) {
        return;
      }
      let pageNum = Number.parseInt(inputValue.value);
      switch (true) {
        case pageNum < 1:
          pageNum = 1;
          break;
        case pageNum > lastPage.value:
          pageNum = lastPage.value;
          break;
        case isNaN(pageNum):
          pageNum = currentValue.value;
          break;
      }
      onUserInput(pageNum);
      resetInput();
    };
    const { getColor, colorToRgba: colorToRgba2 } = useColors();
    const inputBorderColorComputed = computed(() => {
      const { color, buttonsPreset } = toRefs(props);
      if (!color.value) {
        return "transparent";
      }
      switch (buttonsPreset.value) {
        case "default":
          return getColor(color.value);
        case void 0:
        case "primary":
          return colorToRgba2(getColor(color.value), 0.1);
        default:
          return "transparent";
      }
    });
    const inputStyleComputed = computed(() => ({
      cursor: "default",
      color: getColor(props.color),
      opacity: props.disabled ? 0.4 : 1,
      borderColor: inputBorderColorComputed.value
    }));
    watch([usesTotal, () => pagesComputed.value], () => {
      if (isDev && usesTotal.value && pagesComputed.value) {
        throw new Error("Please, use either `total` and `page-size` props, or `pages`.");
      }
    });
    const inputAttributesComputed = computed(() => ({
      disabled: props.disabled,
      placeholder: `${currentValue.value}/${lastPage.value}`
    }));
    const buttonPropsComputed = computed(() => ({
      size: props.size,
      preset: props.buttonsPreset,
      color: props.color,
      borderColor: props.borderColor,
      round: props.rounded,
      ...props.buttonProps
    }));
    const currentPageButtonProps = computed(() => ({
      preset: props.buttonsPreset === "default" ? "primary" : "default",
      color: props.activePageColor || props.color,
      ...props.activeButtonProps
    }));
    const getPageButtonProps = (n) => {
      if (!isNaN(+n) && n === currentValue.value) {
        return Object.assign({}, buttonPropsComputed.value, currentPageButtonProps.value);
      }
      return buttonPropsComputed.value;
    };
    const isStandAloneInput = computed(() => props.input && !props.boundaryLinks && !props.directionLinks);
    const inputClassComputed = useBem("va-pagination__input", () => ({
      sm: props.size === "small" && isStandAloneInput.value,
      md: props.size === "medium" && isStandAloneInput.value,
      lg: props.size === "large" && isStandAloneInput.value,
      auto: !isStandAloneInput.value
    }));
    const classComputed = useBem("va-pagination", () => ({
      ...pick(props, ["gapped", "rounded", "disabled"]),
      bordered: !!props.borderColor
    }));
    const goNextPage = () => onUserInput(currentValue.value + 1);
    const goPrevPage = () => onUserInput(currentValue.value - 1);
    const { tp } = useTranslation();
    __expose({
      goNextPage,
      goPrevPage
    });
    return (_ctx, _cache) => {
      return showPagination.value ? (openBlock(), createElementBlock("nav", {
        key: 0,
        class: normalizeClass(["va-pagination", unref(classComputed)]),
        "aria-label": unref(tp)(_ctx.$props.ariaLabel),
        onKeydown: [
          withKeys(withModifiers(goPrevPage, ["stop"]), ["left"]),
          withKeys(withModifiers(goNextPage, ["stop"]), ["right"]),
          withKeys(withModifiers(goPrevPage, ["stop"]), ["up"]),
          withKeys(withModifiers(goNextPage, ["stop"]), ["down"])
        ]
      }, [
        showBoundaryLinks.value ? renderSlot(_ctx.$slots, "firstPageLink", normalizeProps$1(mergeProps$1({ key: 0 }, { onClick: () => onUserInput(1), disabled: _ctx.$props.disabled || currentValue.value === 1 })), () => [
          showBoundaryLinks.value ? (openBlock(), createBlock(unref(VaButton), mergeProps$1({
            key: 0,
            "aria-label": unref(tp)(_ctx.$props.ariaGoToTheFirstPageLabel),
            disabled: _ctx.$props.disabled || currentValue.value === 1,
            icon: _ctx.$props.boundaryIconLeft
          }, buttonPropsComputed.value, {
            onClick: _cache[0] || (_cache[0] = ($event) => onUserInput(1))
          }), null, 16, ["aria-label", "disabled", "icon"])) : createCommentVNode("", true)
        ]) : createCommentVNode("", true),
        showDirectionLinks.value ? renderSlot(_ctx.$slots, "prevPageLink", normalizeProps$1(mergeProps$1({ key: 1 }, { onClick: goPrevPage, disabled: _ctx.$props.disabled || currentValue.value === 1 })), () => [
          showDirectionLinks.value ? (openBlock(), createBlock(unref(VaButton), mergeProps$1({
            key: 0,
            "aria-label": unref(tp)(_ctx.$props.ariaGoToPreviousPageLabel),
            disabled: _ctx.$props.disabled || currentValue.value === 1,
            icon: _ctx.$props.directionIconLeft
          }, buttonPropsComputed.value, { onClick: goPrevPage }), null, 16, ["aria-label", "disabled", "icon"])) : createCommentVNode("", true)
        ]) : createCommentVNode("", true),
        !_ctx.$props.input ? renderSlot(_ctx.$slots, "default", { key: 2 }, () => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(paginationRange.value, (n, i) => {
            return openBlock(), createBlock(unref(VaButton), mergeProps$1({
              key: i,
              ref_for: true,
              ref: unref(setItemRefByIndex)(i),
              class: { "va-button--ellipsis": n === "...", "va-button--current": n === currentValue.value },
              "aria-label": unref(tp)(_ctx.$props.ariaGoToSpecificPageLabel, { page: n }),
              "aria-current": n === currentValue.value,
              disabled: _ctx.$props.disabled || n === "..."
            }, getPageButtonProps(n), {
              onClick: ($event) => onUserInput(n)
            }), {
              default: withCtx(() => [
                createTextVNode(toDisplayString(n), 1)
              ]),
              _: 2
            }, 1040, ["class", "aria-label", "aria-current", "disabled", "onClick"]);
          }), 128))
        ]) : withDirectives((openBlock(), createElementBlock("input", mergeProps$1({
          key: 3,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => inputValue.value = $event),
          ref_key: "htmlInput",
          ref: htmlInput,
          class: ["va-pagination__input va-button", unref(inputClassComputed)],
          "aria-label": unref(tp)(_ctx.$props.ariaGoToSpecificPageInputLabel),
          style: inputStyleComputed.value
        }, inputAttributesComputed.value, {
          onKeydown: withKeys(changeValue, ["enter"]),
          onFocus: focusInput,
          onBlur: changeValue
        }), null, 16, _hoisted_2$d)), [
          [vModelDynamic, inputValue.value]
        ]),
        showDirectionLinks.value ? renderSlot(_ctx.$slots, "nextPageLink", normalizeProps$1(mergeProps$1({ key: 4 }, { onClick: goNextPage, disabled: _ctx.$props.disabled || currentValue.value === lastPage.value })), () => [
          showDirectionLinks.value ? (openBlock(), createBlock(unref(VaButton), mergeProps$1({
            key: 0,
            "aria-label": unref(tp)(_ctx.$props.ariaGoToNextPageLabel),
            disabled: _ctx.$props.disabled || currentValue.value === lastPage.value,
            icon: _ctx.$props.directionIconRight
          }, buttonPropsComputed.value, { onClick: goNextPage }), null, 16, ["aria-label", "disabled", "icon"])) : createCommentVNode("", true)
        ]) : createCommentVNode("", true),
        showBoundaryLinks.value ? renderSlot(_ctx.$slots, "lastPageLink", normalizeProps$1(mergeProps$1({ key: 5 }, { onClick: () => onUserInput(lastPage.value), disabled: _ctx.$props.disabled || currentValue.value === lastPage.value })), () => [
          showBoundaryLinks.value ? (openBlock(), createBlock(unref(VaButton), mergeProps$1({
            key: 0,
            "aria-label": unref(tp)(_ctx.$props.ariaGoToLastPageLabel),
            disabled: _ctx.$props.disabled || currentValue.value === lastPage.value,
            icon: _ctx.$props.boundaryIconRight
          }, buttonPropsComputed.value, {
            onClick: _cache[2] || (_cache[2] = ($event) => onUserInput(lastPage.value))
          }), null, 16, ["aria-label", "disabled", "icon"])) : createCommentVNode("", true)
        ]) : createCommentVNode("", true)
      ], 42, _hoisted_1$r)) : createCommentVNode("", true);
    };
  }
});
const VaPagination = withConfigTransport$1(_sfc_main$F);
const useScrollParent = () => {
  const window2 = useWindow();
  const fakeWindow = new Proxy(window2.value || {}, {
    get: (target, key, rec) => {
      var _a2, _b;
      if (key === "scrollTop") {
        return (_a2 = window2.value) == null ? void 0 : _a2.scrollY;
      }
      if (key === "scrollLeft") {
        return (_b = window2.value) == null ? void 0 : _b.scrollX;
      }
      const value = Reflect.get(target, key, rec);
      if (typeof value === "function") {
        return value.bind(target);
      }
      return value;
    }
  });
  const getScrollableParent = (element) => {
    if (!element) {
      return fakeWindow;
    }
    if (element.scrollHeight > element.clientHeight) {
      return element;
    }
    return getScrollableParent(element.parentElement);
  };
  return { getScrollableParent };
};
const _hoisted_1$q = { class: "va-parallax__image-container" };
const _hoisted_2$c = ["src", "alt"];
const _hoisted_3$8 = { class: "va-parallax__item-container" };
const _sfc_main$E = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaParallax"
  },
  __name: "VaParallax",
  props: {
    ...useComponentPresetProp,
    target: { type: [Object, String] },
    src: { type: String, default: "", required: true },
    alt: { type: String, default: "parallax" },
    height: { type: [Number, String], default: 400 },
    reversed: { type: Boolean, default: false },
    speed: {
      type: [Number, String],
      default: 0.5,
      validator: (value) => {
        const num = Number(value);
        return num >= 0 && num <= 1;
      }
    }
  },
  setup(__props) {
    const props = __props;
    const rootElement = shallowRef();
    const img = shallowRef();
    const elOffsetTop = ref(0);
    const parallax = ref(0);
    const parallaxDist = ref(0);
    const percentScrolled = ref(0);
    const scrollTop = ref(0);
    const windowHeight = ref(0);
    const windowBottom = ref(0);
    const isLoaded = ref(false);
    const computedWrapperStyles = computed(() => ({ height: heightComputed.value + "px" }));
    const computedImgStyles = computed(() => ({
      display: "block",
      transform: `translate(-50%, ${parallax.value}px)`,
      opacity: isLoaded.value ? 1 : 0,
      top: props.reversed ? 0 : "auto"
    }));
    const { getScrollableParent } = useScrollParent();
    const targetElement = computed(() => {
      var _a2;
      if (!props.target) {
        return getScrollableParent((_a2 = rootElement.value) == null ? void 0 : _a2.parentElement);
      }
      if (props.target instanceof HTMLElement) {
        return props.target;
      }
      const element = document.querySelector(props.target);
      if (element) {
        return element;
      }
      warn("VaParallax target prop got wrong selector. Target is null");
      return null;
    });
    const imgHeight = computed(() => {
      var _a2;
      return ((_a2 = img.value) == null ? void 0 : _a2.naturalHeight) || 0;
    });
    const heightComputed = useNumericProp("height");
    const speedComputed = useNumericProp("speed");
    const calcDimensions = () => {
      var _a2, _b;
      const offset2 = ((_a2 = rootElement.value) == null ? void 0 : _a2.getBoundingClientRect()) || { top: 0 };
      scrollTop.value = ((_b = targetElement.value) == null ? void 0 : _b.scrollTop) || 0;
      parallaxDist.value = imgHeight.value - heightComputed.value;
      elOffsetTop.value = offset2.top + scrollTop.value;
      windowHeight.value = window.innerHeight;
      windowBottom.value = scrollTop.value + windowHeight.value;
    };
    const translate = () => {
      calcDimensions();
      percentScrolled.value = (windowBottom.value - elOffsetTop.value) / (heightComputed.value + windowHeight.value);
      parallax.value = Math.round(parallaxDist.value * percentScrolled.value) * speedComputed.value;
      if (props.reversed) {
        parallax.value = -parallax.value;
      }
    };
    const addEventListeners = () => {
      var _a2, _b;
      (_a2 = targetElement.value) == null ? void 0 : _a2.addEventListener("scroll", translate);
      (_b = targetElement.value) == null ? void 0 : _b.addEventListener("resize", translate);
    };
    const removeEventListeners = () => {
      var _a2, _b;
      (_a2 = targetElement.value) == null ? void 0 : _a2.removeEventListener("scroll", translate);
      (_b = targetElement.value) == null ? void 0 : _b.removeEventListener("resize", translate);
    };
    const initImage = () => {
      var _a2, _b;
      if ((_a2 = img.value) == null ? void 0 : _a2.complete) {
        translate();
        addEventListeners();
      } else {
        (_b = img.value) == null ? void 0 : _b.addEventListener("load", () => {
          translate();
          addEventListeners();
        }, false);
      }
      isLoaded.value = true;
    };
    onMounted(initImage);
    onBeforeUnmount(removeEventListeners);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "rootElement",
        ref: rootElement,
        class: "va-parallax",
        style: normalizeStyle(computedWrapperStyles.value)
      }, [
        createBaseVNode("div", _hoisted_1$q, [
          createBaseVNode("img", {
            ref_key: "img",
            ref: img,
            class: "va-parallax__image",
            src: _ctx.$props.src,
            alt: _ctx.$props.alt,
            style: normalizeStyle(computedImgStyles.value)
          }, null, 12, _hoisted_2$c)
        ]),
        createBaseVNode("div", _hoisted_3$8, [
          renderSlot(_ctx.$slots, "default")
        ])
      ], 4);
    };
  }
});
const VaParallax = withConfigTransport$1(_sfc_main$E);
const _hoisted_1$p = {
  key: 0,
  "aria-hidden": "true",
  class: "va-popover__icon"
};
const _hoisted_2$b = { key: 1 };
const _hoisted_3$7 = {
  key: 0,
  class: "va-popover__title"
};
const _hoisted_4$6 = {
  key: 1,
  class: "va-popover__body"
};
const VaDropdownProps$1 = extractComponentProps(VaDropdown, ["closeOnClickOutside"]);
const _sfc_main$D = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaPopover"
  },
  __name: "VaPopover",
  props: {
    ...VaDropdownProps$1,
    ...useComponentPresetProp,
    trigger: { ...VaDropdownProps$1.trigger, default: ["hover", "enter", "space", "arrow-down", "arrow-up"] },
    color: { type: String, default: "#1b1a1f" },
    // TODO: Make sure add this color to pallete
    textColor: { type: String },
    icon: { type: String, default: "" },
    title: { type: String, default: "" },
    message: { type: String, default: "" },
    autoHide: { type: Boolean, default: true },
    offset: { type: [Array, Number], default: 4 },
    contentClass: { type: String, default: "" }
  },
  setup(__props) {
    const props = __props;
    const VaDropdownPropValues = filterComponentProps(VaDropdownProps$1);
    const { getColor, getBoxShadowColor: getBoxShadowColor2 } = useColors();
    const slots = useSlots();
    const { textColorComputed } = useTextColor(computed(() => getColor(props.color)));
    const showIconComputed = computed(() => props.icon || slots.icon);
    const showTitleComputed = computed(() => props.title || slots.title);
    const showBodyComputed = computed(() => props.message || slots.body);
    const showPopoverContentComputed = computed(
      () => showTitleComputed.value || showBodyComputed.value
    );
    const computedPopoverStyle = computed(() => ({
      boxShadow: `var(--va-popover-content-box-shadow) ${getBoxShadowColor2(getColor(props.color))}`,
      backgroundColor: getColor(props.color),
      color: textColorComputed.value
    }));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaDropdown), mergeProps$1(unref(VaDropdownPropValues), {
        "model-value": _ctx.modelValue,
        "close-on-click-outside": __props.autoHide,
        offset: _ctx.$props.offset,
        "content-class": _ctx.$props.contentClass,
        class: "va-popover"
      }), {
        default: withCtx(() => [
          createBaseVNode("div", {
            style: normalizeStyle(computedPopoverStyle.value),
            class: "va-popover__content",
            role: "tooltip"
          }, [
            showIconComputed.value ? (openBlock(), createElementBlock("div", _hoisted_1$p, [
              renderSlot(_ctx.$slots, "icon", {}, () => [
                createVNode(unref(VaIcon), {
                  name: _ctx.$props.icon,
                  color: unref(textColorComputed)
                }, null, 8, ["name", "color"])
              ])
            ])) : createCommentVNode("", true),
            showPopoverContentComputed.value ? (openBlock(), createElementBlock("div", _hoisted_2$b, [
              showTitleComputed.value ? (openBlock(), createElementBlock("div", _hoisted_3$7, [
                renderSlot(_ctx.$slots, "title", {}, () => [
                  createTextVNode(toDisplayString(_ctx.$props.title), 1)
                ])
              ])) : createCommentVNode("", true),
              showBodyComputed.value ? (openBlock(), createElementBlock("div", _hoisted_4$6, [
                renderSlot(_ctx.$slots, "body", {}, () => [
                  createTextVNode(toDisplayString(_ctx.$props.message), 1)
                ])
              ])) : createCommentVNode("", true)
            ])) : createCommentVNode("", true)
          ], 4)
        ]),
        anchor: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["model-value", "close-on-click-outside", "offset", "content-class"]);
    };
  }
});
const VaPopover = withConfigTransport$1(_sfc_main$D);
var RatingValue = /* @__PURE__ */ ((RatingValue2) => {
  RatingValue2[RatingValue2["EMPTY"] = 0] = "EMPTY";
  RatingValue2[RatingValue2["HALF"] = 0.5] = "HALF";
  RatingValue2[RatingValue2["FULL"] = 1] = "FULL";
  return RatingValue2;
})(RatingValue || {});
const getContext = () => {
  const instance = getCurrentInstance();
  if (!instance) {
    throw new Error("useRating hooks must be used on top of setup function");
  }
  return {
    props: instance.props,
    emit: instance.emit
  };
};
const useRatingProps = {
  ...useStatefulProps,
  modelValue: { type: Number, default: 0 },
  clearable: { type: Boolean, default: false },
  hover: { type: Boolean, default: false }
};
const useRating = (props) => {
  const { emit: emit2 } = getContext();
  const { isHovered, onMouseEnter, onMouseLeave } = useHover();
  const { valueComputed: modelValue } = useStateful(props, emit2);
  const hoveredValue = ref(0);
  const visibleValue = computed(() => !props.disabled && !props.readonly && props.hover && isHovered.value ? hoveredValue.value : modelValue.value);
  const onItemValueUpdate = (itemIndex, newValue) => {
    const newModelValue = itemIndex + newValue;
    if (props.clearable) {
      if (modelValue.value === newModelValue) {
        modelValue.value = 0;
        return;
      }
    }
    modelValue.value = newModelValue;
  };
  const onItemHoveredValueUpdate = (itemIndex, newValue) => {
    if (!props.hover) {
      return;
    }
    hoveredValue.value = itemIndex + newValue;
  };
  const getItemValue = (itemIndex) => {
    const itemValue = visibleValue.value - itemIndex;
    return clamp$1(itemValue, RatingValue.EMPTY, RatingValue.FULL);
  };
  return {
    visibleValue,
    modelValue,
    hoveredValue,
    isHovered,
    onMouseEnter,
    onMouseLeave,
    onItemValueUpdate,
    onItemHoveredValueUpdate,
    getItemValue
  };
};
const useVaRatingColorsProps = {
  unselectedColor: { type: String },
  color: { type: String, default: "primary" },
  modelValue: { type: Number }
};
const useVaRatingColors = (props) => {
  const { getColor, getFocusColor: getFocusColor2, getTextColor } = useColors();
  const computedColor = computed(() => getColor(props.color));
  const backgroundColor = computed(() => {
    if (props.unselectedColor) {
      return getColor(props.unselectedColor);
    }
    return getFocusColor2(getColor(props.color));
  });
  const backgroundComputed = computed(() => {
    if (props.modelValue === RatingValue.HALF) {
      return `linear-gradient(90deg, ${computedColor.value} 50%, ${backgroundColor.value} 50%`;
    }
    if (props.modelValue === RatingValue.EMPTY) {
      return backgroundColor.value;
    }
    return computedColor.value;
  });
  const textColorComputed = computed(() => {
    if (props.modelValue === RatingValue.FULL) {
      return getColor(getTextColor(computedColor.value));
    }
    return getColor(getTextColor(backgroundColor.value));
  });
  return {
    computedColor,
    backgroundComputed,
    textColorComputed
  };
};
const _hoisted_1$o = ["tabindex", "onKeydown"];
const _sfc_main$C = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaRatingItem"
  },
  __name: "VaRatingItem",
  props: {
    modelValue: { type: Number, default: 0 },
    icon: { type: String, default: "star" },
    halfIcon: { type: String, default: "star_half" },
    emptyIcon: { type: String, default: "star_outline" },
    halves: { type: Boolean, default: false },
    hover: { type: Boolean, default: false },
    tabindex: { type: [String, Number], default: 0 },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    size: { type: [String, Number], default: "medium" },
    unselectedColor: { type: String },
    color: { type: String, default: "primary" }
  },
  emits: ["update:modelValue", "click", "hover"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const rootEl = shallowRef();
    const [modelValue] = useSyncProp("modelValue", props, emit2, RatingValue.EMPTY);
    const hoveredValue = ref(null);
    const visibleValue = computed(() => {
      if (props.hover && !props.disabled && !props.readonly) {
        return hoveredValue.value || modelValue.value;
      }
      return modelValue.value;
    });
    const { getColor } = useColors();
    const computedColor = computed(() => getColor(
      props.unselectedColor && visibleValue.value === RatingValue.EMPTY ? props.unselectedColor : props.color
    ));
    const onMouseMove = (ev) => {
      if (!rootEl.value) {
        return;
      }
      const { offsetX } = ev;
      const iconWidth = rootEl.value.clientWidth;
      if (props.halves) {
        hoveredValue.value = offsetX / iconWidth <= RatingValue.HALF ? RatingValue.HALF : RatingValue.FULL;
      } else {
        hoveredValue.value = RatingValue.FULL;
      }
    };
    const onMouseLeave = () => {
      hoveredValue.value = null;
    };
    const onClick = () => {
      modelValue.value = hoveredValue.value || RatingValue.FULL;
      emit2("click", hoveredValue.value || RatingValue.FULL);
    };
    watch(hoveredValue, () => emit2("hover", hoveredValue.value || RatingValue.EMPTY));
    const computedIconName = computed(() => {
      if (props.halves && visibleValue.value === RatingValue.HALF) {
        return props.halfIcon;
      }
      if (visibleValue.value === RatingValue.EMPTY) {
        return props.emptyIcon;
      }
      return props.icon;
    });
    const tabIndexComputed = computed(() => props.disabled ? -1 : props.tabindex);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "rootEl",
        ref: rootEl,
        role: "button",
        class: "va-rating-item",
        tabindex: tabIndexComputed.value,
        onKeydown: [
          withKeys(onClick, ["enter"]),
          withKeys(withModifiers(onClick, ["prevent"]), ["space"])
        ],
        onMousemove: onMouseMove,
        onMouseleave: onMouseLeave,
        onClick
      }, [
        renderSlot(_ctx.$slots, "default", normalizeProps$1(guardReactiveProps({ value: visibleValue.value, onClick })), () => [
          createVNode(unref(VaIcon), {
            class: "va-rating-item__wrapper",
            tabindex: "-1",
            tag: "button",
            name: computedIconName.value,
            size: _ctx.$props.size,
            color: computedColor.value
          }, null, 8, ["name", "size", "color"])
        ])
      ], 40, _hoisted_1$o);
    };
  }
});
const _sfc_main$B = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaRatingItemNumberButton"
  },
  __name: "VaRatingItemNumberButton",
  props: {
    ...useVaRatingColorsProps,
    ...useSizeProps,
    itemNumber: { type: Number, required: true },
    modelValue: { type: Number, required: true }
  },
  setup(__props) {
    const props = __props;
    const {
      textColorComputed,
      backgroundComputed
    } = useVaRatingColors(props);
    const {
      sizeComputed,
      fontSizeComputed
    } = useSize(props, "VaRating");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("button", {
        class: "va-rating__number-item",
        tabindex: "-1",
        "aria-hidden": "true",
        style: normalizeStyle({
          background: unref(backgroundComputed),
          color: unref(textColorComputed),
          width: unref(sizeComputed),
          height: unref(sizeComputed),
          fontSize: unref(fontSizeComputed),
          borderRadius: `${parseInt(unref(fontSizeComputed)) * 0.125}rem`
        })
      }, toDisplayString(__props.itemNumber), 5);
    };
  }
});
const _hoisted_1$n = ["aria-label"];
const VaRatingItemPropsDeclarations = extractComponentProps(_sfc_main$C, ["modelValue", "itemNumber"]);
const VaRatingItemNumberButtonPropsDeclarations = extractComponentProps(_sfc_main$B, ["modelValue", "itemNumber"]);
const _sfc_main$A = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaRating"
  },
  __name: "VaRating",
  props: {
    ...VaRatingItemNumberButtonPropsDeclarations,
    ...useRatingProps,
    ...useVaRatingColorsProps,
    ...useFormFieldProps,
    ...VaRatingItemPropsDeclarations,
    ...useComponentPresetProp,
    modelValue: { type: Number, default: 0 },
    numbers: { type: Boolean, default: false },
    halves: { type: Boolean, default: false },
    max: { type: [Number, String], default: 5 },
    texts: { type: Array, default: () => [] },
    ariaLabel: useTranslationProp("$t:currentRating"),
    ariaItemLabel: useTranslationProp("$t:voteRating")
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const { computedClasses: rootClass } = useFormField("va-rating", props);
    const {
      visibleValue,
      onMouseEnter,
      onMouseLeave,
      onItemValueUpdate,
      onItemHoveredValueUpdate,
      getItemValue
    } = useRating(props);
    const isInteractionsEnabled = computed(() => !props.disabled && !props.readonly);
    const onArrowKeyPress = (direction) => {
      const max2 = Number(props.max);
      const step = props.halves ? RatingValue.HALF : RatingValue.FULL;
      const nextStep = visibleValue.value + step * direction;
      const min2 = props.clearable ? 0 : step;
      if (nextStep >= min2 && nextStep <= max2) {
        onItemValueUpdate(visibleValue.value, step * direction);
      } else if (nextStep < min2) {
        onItemValueUpdate(min2, 0);
      } else {
        onItemValueUpdate(max2, direction === -1 ? step * direction : 0);
      }
    };
    const { tp } = useTranslation();
    const {
      computedColor
    } = useVaRatingColors(props);
    const tabIndexComputed = computed(() => isInteractionsEnabled.value ? 0 : void 0);
    const VaRatingItemProps = filterComponentProps(VaRatingItemPropsDeclarations);
    const VaRatingItemNumberButtonProps = filterComponentProps(VaRatingItemNumberButtonPropsDeclarations);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["va-rating", unref(rootClass)]),
        "aria-label": unref(tp)(_ctx.$props.ariaLabel, { max: _ctx.$props.max, value: _ctx.$props.modelValue })
      }, [
        createBaseVNode("div", {
          class: "va-rating__item-wrapper",
          onKeyup: [
            _cache[0] || (_cache[0] = withKeys(($event) => onArrowKeyPress(-1), ["left"])),
            _cache[1] || (_cache[1] = withKeys(($event) => onArrowKeyPress(1), ["right"]))
          ],
          onMouseenter: _cache[2] || (_cache[2] = //@ts-ignore
          (...args) => unref(onMouseEnter) && unref(onMouseEnter)(...args)),
          onMouseleave: _cache[3] || (_cache[3] = //@ts-ignore
          (...args) => unref(onMouseLeave) && unref(onMouseLeave)(...args))
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(Number(_ctx.$props.max), (itemNumber) => {
            return openBlock(), createBlock(_sfc_main$C, mergeProps$1({
              key: itemNumber,
              class: "va-rating__item"
            }, unref(VaRatingItemProps), {
              "aria-label": unref(tp)(_ctx.$props.ariaItemLabel, { max: _ctx.$props.max, value: itemNumber }),
              "model-value": unref(getItemValue)(itemNumber - 1),
              tabindex: tabIndexComputed.value,
              disabled: _ctx.$props.disabled,
              readonly: _ctx.$props.readonly,
              onHover: ($event) => isInteractionsEnabled.value && unref(onItemHoveredValueUpdate)(itemNumber - 1, $event),
              "onUpdate:modelValue": ($event) => isInteractionsEnabled.value && unref(onItemValueUpdate)(itemNumber - 1, $event)
            }), {
              default: withCtx(({ value, onClick }) => [
                renderSlot(_ctx.$slots, "item", normalizeProps$1(guardReactiveProps({ value, onClick, index: itemNumber })), () => [
                  _ctx.$props.numbers ? (openBlock(), createBlock(_sfc_main$B, mergeProps$1({ key: 0 }, unref(VaRatingItemNumberButtonProps), {
                    "model-value": value,
                    "item-number": itemNumber
                  }), null, 16, ["model-value", "item-number"])) : createCommentVNode("", true)
                ])
              ]),
              _: 2
            }, 1040, ["aria-label", "model-value", "tabindex", "disabled", "readonly", "onHover", "onUpdate:modelValue"]);
          }), 128))
        ], 32),
        _ctx.$props.texts && _ctx.$props.texts.length === _ctx.$props.max ? (openBlock(), createElementBlock("span", {
          key: 0,
          class: "va-rating__text-wrapper",
          style: normalizeStyle({ color: unref(computedColor) })
        }, toDisplayString(_ctx.$props.texts[Math.round(unref(visibleValue)) - 1]), 5)) : createCommentVNode("", true)
      ], 10, _hoisted_1$n);
    };
  }
});
const VaRating = withConfigTransport$1(_sfc_main$A);
const getTopCoordinate = (element) => element.offsetTop;
const getBottomCoordinate = (element) => element.offsetTop + element.offsetHeight;
const getCenterCoordinate = (element) => element.offsetTop + element.offsetHeight / 2;
const getScrollTop = (element, scrollTarget, verticalAlignment) => {
  const viewHeight = scrollTarget.offsetHeight;
  const currentPosition = scrollTarget.scrollTop;
  const top = getTopCoordinate(element) - scrollTarget.offsetTop;
  const center = getCenterCoordinate(element) - scrollTarget.offsetTop;
  const bottom = getBottomCoordinate(element) - scrollTarget.offsetTop;
  if (verticalAlignment === "start") {
    return top;
  }
  if (verticalAlignment === "end") {
    return bottom - viewHeight;
  }
  if (verticalAlignment === "center") {
    return center - viewHeight / 2;
  }
  if (verticalAlignment === "any") {
    if (top - currentPosition < 0) {
      return top;
    }
    if (bottom - currentPosition > viewHeight) {
      return bottom - viewHeight;
    }
  }
};
const scrollToElement = (element, options = {
  scrollTarget: element.parentElement,
  verticalAlignment: "any",
  smooth: false
}) => {
  const scrollTarget = options.scrollTarget || element.parentElement;
  const top = getScrollTop(element, scrollTarget, options.verticalAlignment);
  if (top === void 0) {
    return;
  }
  scrollTarget.scroll({
    top,
    behavior: options.smooth ? "smooth" : "auto"
  });
};
const _hoisted_1$m = ["aria-selected"];
const _hoisted_2$a = {
  key: 1,
  class: "va-select-option__highlighted"
};
const _sfc_main$z = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaSelectOption"
  },
  __name: "VaSelectOption",
  props: {
    ...useColorProps,
    disabled: { type: Boolean, default: false },
    option: { type: [Number, String, Boolean, Object], default: () => ({}) },
    getText: { type: Function, required: true },
    getTrackBy: { type: Function, required: true },
    currentOption: { type: [String, Number, Boolean, Object], default: null },
    getSelectedState: { type: Function, required: true },
    search: { type: String, default: "" },
    highlightMatchedText: { type: Boolean, default: true },
    inputFocused: { type: Boolean, default: false },
    minSearchChars: { type: [Number, String], default: 0 }
  },
  setup(__props, { expose: __expose }) {
    const props = __props;
    const { getColor, getHoverColor: getHoverColor2 } = useColors();
    const minSearchCharsComputed = useNumericProp("minSearchChars");
    const optionIcon = computed(() => isObject$2(props.option) ? props.option.icon : void 0);
    const optionIconColor = computed(() => getColor(props.color));
    const optionText = computed(() => props.getText(props.option));
    const optionTextSplitted = computed(() => {
      const defaultSplit = { start: optionText.value, searchedSubString: "", end: "" };
      if (!optionText.value || !props.search || !props.highlightMatchedText || props.search.length < minSearchCharsComputed.value) {
        return defaultSplit;
      }
      const substringStartIndex = optionText.value.toLowerCase().indexOf(props.search.toLowerCase());
      if (substringStartIndex < 0) {
        return defaultSplit;
      }
      const start = optionText.value.slice(0, substringStartIndex);
      const searchedSubString = optionText.value.slice(substringStartIndex, substringStartIndex + props.search.length);
      const end = optionText.value.slice(substringStartIndex + props.search.length);
      return { start, searchedSubString, end };
    });
    const isSelected = computed(() => props.getSelectedState(props.option));
    const isFocused = computed(() => {
      if (typeof props.option === "string") {
        return props.option === props.currentOption;
      }
      return props.getTrackBy(props.currentOption) === props.getTrackBy(props.option);
    });
    const optionClass = useBem("va-select-option", () => ({
      selected: isSelected.value
    }));
    const optionStyle = computed(() => ({
      color: isSelected.value ? getColor(props.color) : "inherit",
      backgroundColor: isFocused.value ? getHoverColor2(getColor(props.color)) : "transparent",
      cursor: props.disabled ? "default" : void 0,
      opacity: props.disabled ? "var(--va-select-option-list-option-disabled-opacity)" : void 0
    }));
    __expose({
      isFocused,
      isSelected
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        role: "option",
        class: normalizeClass(["va-select-option", unref(optionClass)]),
        style: normalizeStyle(optionStyle.value),
        "aria-selected": isSelected.value
      }, [
        renderSlot(_ctx.$slots, "option-content", {}, () => [
          optionIcon.value ? (openBlock(), createBlock(unref(VaIcon), {
            key: 0,
            size: "small",
            class: "va-select-option__icon",
            name: optionIcon.value
          }, null, 8, ["name"])) : createCommentVNode("", true),
          createTextVNode(" " + toDisplayString(optionTextSplitted.value.start) + " ", 1),
          optionTextSplitted.value.searchedSubString ? (openBlock(), createElementBlock("span", _hoisted_2$a, toDisplayString(optionTextSplitted.value.searchedSubString), 1)) : createCommentVNode("", true),
          createTextVNode(" " + toDisplayString(optionTextSplitted.value.end), 1)
        ]),
        isSelected.value ? (openBlock(), createBlock(unref(VaIcon), {
          key: 0,
          class: "va-select-option__selected-icon",
          size: "small",
          name: "va-check",
          color: optionIconColor.value
        }, null, 8, ["color"])) : createCommentVNode("", true)
      ], 14, _hoisted_1$m);
    };
  }
});
const VaSelectOption = withConfigTransport$1(_sfc_main$z);
const useObjectRefs = () => {
  const itemRefs = shallowRef({});
  const setItemRef = (key) => (el) => {
    if (!el) {
      return;
    }
    itemRefs.value[key] = el;
    return String(key);
  };
  onBeforeUpdate(() => {
    itemRefs.value = {};
  });
  return { itemRefs, setItemRef };
};
const _hoisted_1$l = ["tabindex", "onKeydown", "aria-multiselectable"];
const _hoisted_2$9 = {
  key: 0,
  class: "va-select-option-list__group-name",
  role: "presentation"
};
const _hoisted_3$6 = {
  key: 0,
  class: "va-select-option-list--empty"
};
const _sfc_main$y = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaSelectOptionList"
  },
  __name: "VaSelectOptionList",
  props: {
    ...useColorProps,
    ...useComponentPresetProp,
    ...useSelectableListProps,
    ...useThrottleProps,
    noOptionsText: { type: String, default: "Items not found" },
    getSelectedState: { type: Function, required: true },
    multiple: { type: Boolean, default: false },
    search: { type: String, default: "" },
    tabindex: { type: [String, Number], default: 0 },
    hoveredOption: { type: [String, Number, Boolean, Object], default: null },
    virtualScroller: { type: Boolean, default: true },
    highlightMatchedText: { type: Boolean, default: true },
    minSearchChars: { type: [Number, String], default: 0 },
    autoSelectFirstOption: { type: Boolean, default: false },
    selectedTopShown: { type: Boolean, default: false },
    doShowAllOptions: { type: Boolean, default: false },
    searchFn: { type: Function, default: void 0 }
  },
  emits: [
    "select-option",
    "update:hoveredOption",
    "no-previous-option-to-hover",
    "scroll-bottom"
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const root = shallowRef();
    const focus = () => {
      var _a2;
      (_a2 = root.value) == null ? void 0 : _a2.focus({ preventScroll: true });
    };
    const rootHeight = computed(() => {
      var _a2;
      return ((_a2 = root.value) == null ? void 0 : _a2.clientHeight) ?? 200;
    });
    const handleScrollToBottom = () => emit2("scroll-bottom");
    const onScroll = (event) => {
      const target = event.target;
      if (!target) {
        return;
      }
      if (target.scrollTop + target.clientHeight === target.scrollHeight) {
        handleScrollToBottom();
      }
    };
    const lastInteractionSource = ref("");
    const currentOptionComputed = computed(() => props.hoveredOption ?? null);
    const updateCurrentOption = (option, source) => {
      emit2("update:hoveredOption", option);
      lastInteractionSource.value = source;
    };
    const { getText, getGroupBy, getTrackBy, getDisabled } = useSelectableList(props);
    const minSearchCharsComputed = useNumericProp("minSearchChars");
    const currentSelectedOptionText = computed(() => {
      var _a2;
      const getSelectedState = props.getSelectedState;
      const selected = (_a2 = props.options) == null ? void 0 : _a2.find((option) => getSelectedState(option));
      return selected ? getText(selected) : "";
    });
    const isSearchedOptionSelected = computed(() => {
      var _a2;
      return currentSelectedOptionText.value.toLowerCase() === ((_a2 = props.search) == null ? void 0 : _a2.toLowerCase());
    });
    const filteredOptions = computed(() => {
      if (props.doShowAllOptions && isSearchedOptionSelected.value) {
        return props.options;
      }
      if (!props.search || props.search.length < minSearchCharsComputed.value) {
        return props.options;
      }
      if (props.searchFn) {
        return props.options.filter((o) => props.searchFn(props.search, o));
      }
      const search = props.search.toUpperCase().trim();
      return props.options.filter((option) => {
        const optionText = getText(option).toUpperCase();
        return optionText.includes(search);
      });
    });
    const optionGroups = computed(() => {
      if (!props.groupBy) {
        return { _noGroup: filteredOptions.value };
      }
      return filteredOptions.value.reduce((groups, option) => {
        const groupBy = getGroupBy(option);
        if (!groupBy) {
          groups._noGroup.push(option);
        } else {
          if (!groups[groupBy]) {
            groups[groupBy] = [];
          }
          groups[groupBy].push(option);
        }
        return groups;
      }, { _noGroup: [] });
    });
    const optionGroupsThrottled = useThrottleValue(optionGroups, props);
    const isValueExists = (value) => !isNilValue(value);
    const updateHoveredOption = (option) => {
      if (option === currentOptionComputed.value || isValueExists(option) && getDisabled(option)) {
        return;
      }
      updateCurrentOption(option ?? null, "mouse");
    };
    const updateFocusedOption = (option) => {
      updateCurrentOption(option ?? null, "keyboard");
    };
    const selectHoveredOption = () => {
      const previousOption = previousOptionComputed.value && typeof previousOptionComputed.value === "object" ? { ...previousOptionComputed.value } : previousOptionComputed.value;
      emit2("select-option");
      if (props.selectedTopShown) {
        updateHoveredOption(previousOption);
      }
    };
    const groupedOptions = computed(() => Object.values(optionGroupsThrottled.value).flat());
    const currentOptions = computed(() => filteredOptions.value.some((el) => getGroupBy(el)) ? groupedOptions.value : filteredOptions.value);
    const currentOptionIndex = computed(() => currentOptions.value.findIndex((option) => {
      return isValueExists(currentOptionComputed.value) && getTrackBy(option) === getTrackBy(currentOptionComputed.value);
    }));
    const selectOptionProps = computed(() => ({
      ...pick(props, ["getSelectedState", "color", "search", "highlightMatchedText"]),
      minSearchChars: minSearchCharsComputed.value,
      getText,
      getTrackBy
    }));
    const findNextActiveOption = (startSearchIndex, reversedSearch = false) => {
      const searchBase = [...currentOptions.value || []];
      const searchBaseOrdered = reversedSearch ? searchBase.reverse() : searchBase;
      const startIndex = reversedSearch ? startSearchIndex * -1 - 1 : startSearchIndex;
      return searchBaseOrdered.slice(startIndex).find((option) => !getDisabled(option));
    };
    const previousOptionComputed = computed(() => {
      const previousOptionIndex = currentOptionIndex.value - 1;
      const previousOption = currentOptions.value[previousOptionIndex];
      const previousOptionCheck = isValueExists(previousOption) && !(previousOptionIndex === 0 && getDisabled(previousOption));
      if (previousOptionCheck) {
        return findNextActiveOption(currentOptionIndex.value - 1, true);
      }
      return void 0;
    });
    const selectOption = (option) => {
      updateHoveredOption(option);
      emit2("select-option");
    };
    const handleMouseMove = (option) => {
      if (!props.selectedTopShown) {
        updateHoveredOption(option);
      }
    };
    const handleMouseEnter = (option) => {
      if (props.selectedTopShown) {
        updateHoveredOption(option);
      }
    };
    const focusPreviousOption = () => {
      if (!isValueExists(currentOptionComputed.value)) {
        updateFocusedOption(findNextActiveOption(0, true));
        return;
      }
      if (isValueExists(previousOptionComputed.value)) {
        updateFocusedOption(previousOptionComputed.value);
      } else {
        emit2("no-previous-option-to-hover");
      }
    };
    const focusNextOption = () => {
      if (!isValueExists(currentOptionComputed.value)) {
        focusFirstOption();
        return;
      }
      const nextOptionIndex = currentOptionIndex.value + 1;
      const nextOption = currentOptions.value[nextOptionIndex];
      const nextOptionCheck = isValueExists(nextOption) && !(nextOptionIndex === currentOptions.value.length - 1 && getDisabled(nextOption));
      if (nextOptionCheck) {
        updateFocusedOption(findNextActiveOption(currentOptionIndex.value + 1));
      }
    };
    const focusFirstOption = () => updateFocusedOption(findNextActiveOption(0));
    const { itemRefs, setItemRef } = useObjectRefs();
    const virtualScrollerRef = shallowRef();
    const scrollToOption = (option) => {
      var _a2;
      if (!isValueExists(option)) {
        return;
      }
      const element = unwrapEl(itemRefs.value[getTrackBy(option)]);
      if (element) {
        scrollToElement(element);
      }
      const virtualScroller = (_a2 = virtualScrollerRef.value) == null ? void 0 : _a2[0];
      if (props.virtualScroller) {
        virtualScroller.virtualScrollTo(currentOptionIndex.value);
      }
    };
    watch(() => props.hoveredOption, (newOption) => {
      (!lastInteractionSource.value || lastInteractionSource.value === "keyboard") && isValueExists(newOption) && scrollToOption(newOption);
    });
    watch(filteredOptions, () => {
      if (!props.autoSelectFirstOption) {
        return;
      }
      focusFirstOption();
    }, { immediate: true });
    __expose({
      focusPreviousOption,
      focusNextOption,
      focusFirstOption,
      scrollToOption,
      focus
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "root",
        ref: root,
        class: "va-select-option-list",
        tabindex: __props.tabindex,
        onKeydown: [
          withKeys(withModifiers(focusPreviousOption, ["stop", "prevent"]), ["up"]),
          withKeys(withModifiers(focusPreviousOption, ["stop", "prevent"]), ["left"]),
          withKeys(withModifiers(focusNextOption, ["stop", "prevent"]), ["down"]),
          withKeys(withModifiers(focusNextOption, ["stop", "prevent"]), ["right"]),
          withKeys(withModifiers(selectHoveredOption, ["stop", "prevent"]), ["enter"]),
          withKeys(withModifiers(selectHoveredOption, ["stop", "prevent"]), ["space"])
        ],
        onScrollPassive: onScroll,
        role: "listbox",
        "aria-multiselectable": _ctx.$props.multiple
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(optionGroupsThrottled), (options, groupName) => {
          return openBlock(), createElementBlock(Fragment, { key: groupName }, [
            groupName !== "_noGroup" ? (openBlock(), createElementBlock("span", _hoisted_2$9, toDisplayString(groupName), 1)) : createCommentVNode("", true),
            _ctx.$props.virtualScroller ? (openBlock(), createBlock(unref(VaVirtualScroller), {
              key: 1,
              ref_for: true,
              ref_key: "virtualScrollerRef",
              ref: virtualScrollerRef,
              items: options,
              "track-by": unref(getTrackBy),
              "wrapper-size": rootHeight.value,
              "onScroll:bottom": handleScrollToBottom
            }, {
              default: withCtx(({ item: option, index }) => [
                renderSlot(_ctx.$slots, "default", normalizeProps$1(guardReactiveProps({ option, index, selectOption: (o = option) => selectOption(o) })), () => [
                  createVNode(unref(VaSelectOption), mergeProps$1({
                    option,
                    "current-option": currentOptionComputed.value,
                    disabled: unref(getDisabled)(option)
                  }, selectOptionProps.value, {
                    onClick: withModifiers(selectHoveredOption, ["stop"]),
                    onMouseenter: ($event) => handleMouseEnter(option),
                    onMousemove: ($event) => handleMouseMove(option)
                  }), null, 16, ["option", "current-option", "disabled", "onMouseenter", "onMousemove"])
                ])
              ]),
              _: 2
            }, 1032, ["items", "track-by", "wrapper-size"])) : (openBlock(true), createElementBlock(Fragment, { key: 2 }, renderList(options, (option, index) => {
              return renderSlot(_ctx.$slots, "default", normalizeProps$1(mergeProps$1({
                key: unref(getTrackBy)(option)
              }, { option, index, selectOption })), () => [
                createVNode(unref(VaSelectOption), mergeProps$1({
                  ref_for: true,
                  ref: unref(setItemRef)(unref(getTrackBy)(option)),
                  "current-option": currentOptionComputed.value,
                  option,
                  disabled: unref(getDisabled)(option)
                }, selectOptionProps.value, {
                  onClick: withModifiers(selectHoveredOption, ["stop"]),
                  onMouseenter: ($event) => handleMouseEnter(option),
                  onMousemove: ($event) => handleMouseMove(option)
                }), {
                  "option-content": withCtx(() => [
                    renderSlot(_ctx.$slots, "option-content", normalizeProps$1(guardReactiveProps({ option, index })))
                  ]),
                  _: 2
                }, 1040, ["current-option", "option", "disabled", "onMouseenter", "onMousemove"])
              ]);
            }), 128))
          ], 64);
        }), 128)),
        !filteredOptions.value.length ? (openBlock(), createElementBlock("div", _hoisted_3$6, toDisplayString(__props.noOptionsText), 1)) : createCommentVNode("", true)
      ], 40, _hoisted_1$l);
    };
  }
});
const VaSelectOptionList = withConfigTransport$1(_sfc_main$y);
const _hoisted_1$k = {
  key: 0,
  class: "va-select-content__placeholder"
};
const _hoisted_2$8 = ["placeholder"];
const _hoisted_3$5 = {
  key: 0,
  class: "va-select-content__option"
};
const _hoisted_4$5 = {
  key: 1,
  class: "va-select-content__separator"
};
const _hoisted_5$3 = ["placeholder", "disabled", "readonly"];
const _sfc_main$x = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaSelectContent"
  },
  __name: "VaSelectContent",
  props: {
    ...useFormFieldProps,
    ariaAttributes: { type: Object },
    value: { type: Array, required: true },
    valueString: { type: String },
    separator: { type: String, default: ", " },
    placeholder: { type: String, default: "" },
    tabindex: { type: [String, Number], default: 0 },
    hiddenSelectedOptionsAmount: { type: [Number, String], default: 0 },
    isAllOptionsShown: { type: Boolean, default: false },
    autocomplete: { type: Boolean, default: false },
    focused: { type: Boolean, default: false },
    multiple: { type: Boolean, default: false },
    getText: { type: Function, required: true },
    autocompleteInputValue: { type: String, default: "" }
  },
  emits: ["toggle-hidden", "autocomplete-input", "focus-prev", "focus-next", "select-option", "delete-last-selected"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const autocompleteInput = ref();
    const isPlaceholder = computed(() => props.placeholder && !props.valueString);
    const toggleHiddenOptionsState = () => emit2("toggle-hidden");
    const { value, focused } = toRefs(props);
    const autocompleteInputValueComputed = computed({
      get: () => props.autocompleteInputValue,
      set: (v) => emit2("autocomplete-input", v)
    });
    const hiddenSelectedOptionsAmountComputed = useNumericProp("hiddenSelectedOptionsAmount");
    onMounted(() => {
      if (props.multiple) {
        return;
      }
      if (!props.autocomplete) {
        return;
      }
      autocompleteInputValueComputed.value = props.valueString;
    });
    watch(focused, (newValue) => {
      var _a2, _b;
      if (!props.autocomplete || !newValue) {
        return;
      }
      if (autocompleteInputValueComputed.value) {
        (_a2 = autocompleteInput.value) == null ? void 0 : _a2.setSelectionRange(0, autocompleteInputValueComputed.value.length);
      } else {
        (_b = autocompleteInput.value) == null ? void 0 : _b.focus();
      }
    });
    const handleBackspace = (e) => {
      if (props.multiple && value.value.length && e.key === "Backspace" && !autocompleteInputValueComputed.value) {
        emit2("delete-last-selected");
      }
    };
    const handleClick = (e) => {
      var _a2;
      if (props.autocomplete) {
        (_a2 = autocompleteInput.value) == null ? void 0 : _a2.focus();
        e.stopPropagation();
      }
    };
    const getIcon = (option) => isObject$2(option) ? option.icon : void 0;
    const slotValue = computed(() => {
      if (props.multiple) {
        return value.value;
      }
      return value.value[0];
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "va-select-content",
        onClick: handleClick
      }, [
        isPlaceholder.value && !_ctx.$props.autocomplete ? (openBlock(), createElementBlock("span", _hoisted_1$k, [
          createBaseVNode("input", mergeProps$1(__props.ariaAttributes, {
            placeholder: _ctx.$props.placeholder,
            readonly: ""
          }), null, 16, _hoisted_2$8)
        ])) : !(props.autocomplete && !props.multiple) ? renderSlot(_ctx.$slots, "content", normalizeProps$1(mergeProps$1({ key: 1 }, {
          value: slotValue.value,
          valueString: _ctx.$props.valueString,
          valueArray: _ctx.$props.value,
          tabindex: _ctx.$props.tabindex,
          ariaAttributes: __props.ariaAttributes
        })), () => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.value, (option, index) => {
            return openBlock(), createElementBlock(Fragment, { key: index }, [
              option !== "" ? (openBlock(), createElementBlock("span", _hoisted_3$5, [
                renderSlot(_ctx.$slots, "option-content", normalizeProps$1(guardReactiveProps({ option, index, selectOption: () => void 0 })), () => [
                  getIcon(option) ? (openBlock(), createBlock(unref(VaIcon), {
                    key: 0,
                    size: "small",
                    class: "va-select-option__icon",
                    name: getIcon(option)
                  }, null, 8, ["name"])) : createCommentVNode("", true),
                  createTextVNode(" " + toDisplayString(__props.getText(option)), 1)
                ])
              ])) : createCommentVNode("", true),
              index < _ctx.$props.value.length - 1 ? (openBlock(), createElementBlock("span", _hoisted_4$5, toDisplayString(_ctx.$props.separator), 1)) : createCommentVNode("", true)
            ], 64);
          }), 128))
        ]) : createCommentVNode("", true),
        _ctx.$props.autocomplete ? withDirectives((openBlock(), createElementBlock("input", mergeProps$1({ key: 2 }, __props.ariaAttributes, {
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => autocompleteInputValueComputed.value = $event),
          class: "va-select-content__autocomplete",
          ref_key: "autocompleteInput",
          ref: autocompleteInput,
          autocomplete: "off",
          "aria-autocomplete": "list",
          placeholder: _ctx.$props.placeholder,
          disabled: _ctx.$props.disabled,
          readonly: _ctx.$props.readonly,
          onKeydown: [
            _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => _ctx.$emit("focus-prev"), ["stop", "prevent"]), ["up"])),
            _cache[2] || (_cache[2] = withKeys(withModifiers(($event) => _ctx.$emit("focus-next"), ["stop", "prevent"]), ["down"])),
            _cache[3] || (_cache[3] = withKeys(withModifiers(($event) => _ctx.$emit("select-option"), ["stop", "prevent"]), ["enter"])),
            handleBackspace
          ]
        }), null, 16, _hoisted_5$3)), [
          [vModelDynamic, autocompleteInputValueComputed.value]
        ]) : createCommentVNode("", true),
        renderSlot(_ctx.$slots, "hiddenOptionsBadge", normalizeProps$1(guardReactiveProps({
          amount: __props.hiddenSelectedOptionsAmount,
          isShown: _ctx.$props.isAllOptionsShown,
          toggle: toggleHiddenOptionsState
        })), () => [
          unref(hiddenSelectedOptionsAmountComputed) && !_ctx.$props.isAllOptionsShown ? (openBlock(), createBlock(unref(VaBadge), {
            key: 0,
            class: "va-select-content__state-icon",
            color: "info",
            text: `+${unref(hiddenSelectedOptionsAmountComputed)}`,
            tabindex: _ctx.$props.tabindex,
            onClick: withModifiers(toggleHiddenOptionsState, ["stop"])
          }, null, 8, ["text", "tabindex"])) : createCommentVNode("", true)
        ]),
        renderSlot(_ctx.$slots, "hideOptionsButton", normalizeProps$1(guardReactiveProps({
          isShown: _ctx.$props.isAllOptionsShown,
          toggle: toggleHiddenOptionsState
        })), () => [
          _ctx.$props.isAllOptionsShown ? (openBlock(), createBlock(unref(VaIcon), {
            key: 0,
            role: "button",
            class: "va-select-content__state-icon",
            size: "small",
            name: "reply",
            tabindex: _ctx.$props.tabindex,
            onClick: withModifiers(toggleHiddenOptionsState, ["stop"])
          }, null, 8, ["tabindex"])) : createCommentVNode("", true)
        ])
      ]);
    };
  }
});
const VaSelectContent = withConfigTransport$1(_sfc_main$x);
const useMaxVisibleOptionsProps = {
  maxVisibleOptions: { type: Number || String, default: 0 }
};
const useMaxVisibleOptions = (props, getOptionByValue) => {
  const modelValue = toRef(props, "modelValue");
  const isAllOptionsShown = ref(false);
  const belowLimitSelectedOptions = ref([]);
  const hiddenSelectedOptions = ref([]);
  const hiddenSelectedOptionsAmount = computed(() => hiddenSelectedOptions.value.length);
  const allSelectedOptions = computed(() => [...belowLimitSelectedOptions.value, ...hiddenSelectedOptions.value]);
  const visibleSelectedOptions = computed(() => {
    if (!props.maxVisibleOptions || isAllOptionsShown.value) {
      return allSelectedOptions.value;
    }
    return belowLimitSelectedOptions.value;
  });
  watch(modelValue, () => {
    if (!Array.isArray(modelValue.value)) {
      belowLimitSelectedOptions.value = [getOptionByValue(modelValue.value)];
      hiddenSelectedOptions.value = [];
      return;
    }
    const value = modelValue.value.filter((v) => !isNilValue(v)).map(getOptionByValue);
    if (props.maxVisibleOptions) {
      belowLimitSelectedOptions.value = value.slice(0, props.maxVisibleOptions);
      hiddenSelectedOptions.value = value.slice(props.maxVisibleOptions);
    } else {
      belowLimitSelectedOptions.value = [...value];
      hiddenSelectedOptions.value = [];
    }
  }, { immediate: true });
  const toggleHiddenOptionsState = () => isAllOptionsShown.value = !isAllOptionsShown.value;
  return {
    toggleHiddenOptionsState,
    isAllOptionsShown,
    visibleSelectedOptions,
    hiddenSelectedOptionsAmount,
    allSelectedOptions
  };
};
const useToggleIconProps = {
  dropdownIcon: {
    type: [String, Object],
    default: () => ({
      open: "va-arrow-down",
      close: "va-arrow-up"
    }),
    validator: (value) => {
      if (typeof value === "string") {
        return true;
      }
      return Object.entries(value).every(([prop, propValue]) => ["open", "close"].includes(prop) && typeof propValue === "string");
    }
  }
};
const useToggleIcon = (props, showDropdownContent) => {
  const toggleIcon = computed(() => {
    if (!props.dropdownIcon) {
      return "";
    }
    if (typeof props.dropdownIcon === "string") {
      return props.dropdownIcon;
    }
    return showDropdownContent.value ? props.dropdownIcon.close : props.dropdownIcon.open;
  });
  const { getHoverColor: getHoverColor2, getColor } = useColors();
  const colorComputed = computed(() => getColor("secondary"));
  const toggleIconColor = computed(() => props.readonly ? getHoverColor2(colorComputed.value) : colorComputed.value);
  return { toggleIcon, toggleIconColor };
};
const useStringValueProps = {
  separator: { type: String, default: ", " }
};
const useStringValue = (props, visibleSelectedOptions, getText) => {
  return computed(() => {
    var _a2;
    if (!((_a2 = visibleSelectedOptions.value) == null ? void 0 : _a2.length)) {
      return "";
    }
    return visibleSelectedOptions.value.map(getText).join(props.separator) ?? "";
  });
};
const useAutocompleteProps = {
  autocomplete: { type: Boolean, default: false }
};
const useAutocomplete = (autocompleteValue, props, value, dropdownShown, getText) => {
  const getLastOptionText = (v) => (v == null ? void 0 : v.length) ? getText(v.at(-1)) : "";
  if (props.autocomplete && !props.multiple) {
    autocompleteValue.value = getLastOptionText(value.value);
  }
  watch(value, (newValue, oldValue) => {
    if (!props.autocomplete) {
      return;
    }
    const newValueStringConverted = getLastOptionText(newValue);
    const oldValueStringConverted = getLastOptionText(oldValue);
    if (newValueStringConverted !== oldValueStringConverted) {
      autocompleteValue.value = props.multiple ? "" : newValueStringConverted;
      if (!props.multiple) {
        dropdownShown.value = false;
      }
    }
  });
  watch(autocompleteValue, (newValue) => {
    if (!props.autocomplete) {
      return;
    }
    if (newValue && newValue !== getLastOptionText(value.value)) {
      dropdownShown.value = true;
    }
  });
  const onDropdownClosed = () => {
    autocompleteValue.value = props.multiple ? "" : getLastOptionText(value.value);
  };
  watch(dropdownShown, (newValue, oldValue) => {
    if (!props.autocomplete) {
      return;
    }
    if (!newValue || oldValue) {
      onDropdownClosed();
    }
  });
  return autocompleteValue;
};
const useSelectAria = () => {
  const id = useComponentUuid();
  const popupId = `combobox-controls-${id}`;
  return {
    popupId
  };
};
const useMaxSelectionsProps = {
  maxSelections: {
    type: [Number, String],
    default: void 0
  }
};
function useMaxSelections(selections, maxSelections) {
  const exceedsMaxSelections = () => {
    if (maxSelections.value === void 0 || isNaN(+maxSelections.value)) {
      return false;
    }
    return selections.value.length >= Number(maxSelections.value);
  };
  const addOption = (optionToAdd) => {
    return [...selections.value, optionToAdd];
  };
  return {
    exceedsMaxSelections,
    addOption
  };
}
const VaInputWrapperProps$2 = extractComponentProps(VaInputWrapper);
const _sfc_main$w = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaSelect"
  },
  __name: "VaSelect",
  props: {
    ...VaInputWrapperProps$2,
    ...useComponentPresetProp,
    ...useSelectableListProps,
    ...useValidationProps,
    ...useLoadingProps,
    ...useMaxSelectionsProps,
    ...useClearableProps,
    ...useFormFieldProps,
    ...useMaxVisibleOptionsProps,
    ...useToggleIconProps,
    ...useThrottleProps,
    ...useStringValueProps,
    ...useAutocompleteProps,
    ...useDropdownableProps,
    modelValue: {
      type: [String, Number, Array, Object, Boolean],
      default: void 0
    },
    // Dropdown placement
    placement: { ...useDropdownableProps.placement, default: "bottom" },
    keepAnchorWidth: { ...useDropdownableProps.keepAnchorWidth, default: true },
    offset: { ...useDropdownableProps.offset, default: [1, 0] },
    closeOnContentClick: { ...useDropdownableProps.closeOnContentClick, default: false },
    trigger: { ...useDropdownableProps.trigger, default: () => ["click", "right-click", "space", "enter"] },
    // Select options
    allowCreate: {
      type: [Boolean, String],
      default: false,
      validator: (mode) => [true, false, "unique"].includes(mode)
    },
    color: { type: String, default: "primary" },
    multiple: { type: Boolean, default: false },
    searchable: { type: Boolean, default: false },
    width: { type: String, default: "100%" },
    maxHeight: { type: String, default: "256px" },
    noOptionsText: useTranslationProp("$t:noOptions"),
    hideSelected: { type: Boolean, default: false },
    tabindex: { type: [String, Number], default: 0 },
    virtualScroller: { type: Boolean, default: false },
    selectedTopShown: { type: Boolean, default: false },
    highlightMatchedText: { type: Boolean, default: true },
    minSearchChars: { type: [Number, String], default: 0 },
    autoSelectFirstOption: { type: Boolean, default: false },
    // Input style
    placeholder: { type: String, default: "" },
    searchPlaceholderText: useTranslationProp("$t:search"),
    ariaLabel: useTranslationProp("$t:select"),
    ariaSearchLabel: useTranslationProp("$t:optionsFilter"),
    ariaClearLabel: useTranslationProp("$t:reset"),
    search: { type: String, default: void 0 },
    searchFn: { type: Function, default: void 0 },
    // useClearableProps override
    clearValue: { type: [String, Number, Array, Object, Boolean], default: "" }
  },
  emits: [
    "update:modelValue",
    "update-search",
    "create-new",
    "scroll-bottom",
    "update:search",
    ...useDropdownableEmits,
    ...useValidationEmits,
    ...useClearableEmits
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const { tp, t } = useTranslation();
    const optionList = shallowRef();
    const input = shallowRef();
    const searchBar = shallowRef();
    const isInputFocused = useFocusDeep(input);
    const { getValue: getValue2, getText, getTrackBy, tryResolveByValue } = useSelectableList(props);
    const getValueText = (option) => getText(tryResolveByValue(option));
    const onScrollBottom = () => emit2("scroll-bottom");
    const [searchVModel] = useSyncProp("search", props, emit2, "");
    const showSearchInput = computed(() => props.searchable || props.allowCreate && !props.autocomplete);
    watch(searchVModel, (value) => {
      emit2("update-search", value);
      if (!props.autocomplete) {
        hoveredOption.value = null;
      }
    });
    const getOptionByValue = (value) => {
      if (isNilValue(value) || typeof value === "object") {
        return value;
      }
      const optionByValue = props.options.find((option) => value === getValue2(option));
      if (optionByValue === void 0) {
        warn(`[VaSelect]: can not find option in options list (${JSON.stringify(props.options)}) by provided value (${JSON.stringify(value)})!`);
        return value;
      }
      return optionByValue;
    };
    const {
      toggleHiddenOptionsState,
      isAllOptionsShown,
      visibleSelectedOptions,
      hiddenSelectedOptionsAmount,
      allSelectedOptions
    } = useMaxVisibleOptions(props, getOptionByValue);
    const valueComputed = computed({
      get() {
        if (props.multiple) {
          return allSelectedOptions.value;
        }
        const value = getOptionByValue(props.modelValue);
        if (Array.isArray(value)) {
          warn("Model value should be a string, number, boolean or an object for a single Select.");
          if (value.length) {
            return value.at(-1);
          }
        }
        return value;
      },
      set(option) {
        if (Array.isArray(option)) {
          emit2("update:modelValue", option.map(getValue2));
        } else {
          emit2("update:modelValue", getValue2(option));
        }
      }
    });
    const valueString = useStringValue(props, visibleSelectedOptions, getValueText);
    const {
      canBeCleared,
      clearIconProps,
      onFocus,
      onBlur
    } = useClearable(props, valueComputed);
    const showClearIcon = computed(() => {
      if (!canBeCleared.value) {
        return false;
      }
      if (props.multiple && Array.isArray(valueComputed.value)) {
        return !!valueComputed.value.length;
      }
      return true;
    });
    const filteredOptions = computed(() => {
      if (!props.options) {
        return [];
      }
      if (props.selectedTopShown) {
        return props.options.slice().sort((a, b) => {
          const isASelected = checkIsOptionSelected(a);
          const isBSelected = checkIsOptionSelected(b);
          if (isASelected && isBSelected) {
            return 0;
          }
          if (isASelected && !isBSelected) {
            return -1;
          }
          return 1;
        });
      }
      if (props.hideSelected) {
        return props.options.filter((option) => !checkIsOptionSelected(option));
      }
      return props.options;
    });
    const normalizedOptionValue = computed(() => {
      if (Array.isArray(valueComputed.value)) {
        return valueComputed.value.map((value) => tryResolveByValue(value));
      }
      return tryResolveByValue(valueComputed.value);
    });
    const checkIsOptionSelected = (option) => {
      if (Array.isArray(normalizedOptionValue.value)) {
        return !isNilValue(normalizedOptionValue.value.find((valueItem) => compareOptions(valueItem, option)));
      }
      return compareOptions(normalizedOptionValue.value, option);
    };
    const compareOptions = (option1, option2) => {
      const one = getValue2(option1);
      const two = getValue2(option2);
      if (one === two) {
        return true;
      }
      if (typeof one === "string" && typeof two === "string") {
        return one === two;
      }
      if (one === null || two === null) {
        return false;
      }
      if (typeof one === "object" && typeof two === "object") {
        return getTrackBy(one) === getTrackBy(two);
      }
      return false;
    };
    const isValueComputedArray = (v) => Array.isArray(v.value);
    const selectOption = (option) => {
      if (hoveredOption.value === null) {
        hideAndFocus();
        return;
      }
      if (showSearchInput.value) {
        searchVModel.value = "";
      }
      if (props.multiple && isValueComputedArray(valueComputed)) {
        const { exceedsMaxSelections, addOption } = useMaxSelections(valueComputed, ref(props.maxSelections));
        const isSelected = checkIsOptionSelected(option);
        if (isSelected) {
          valueComputed.value = valueComputed.value.filter((optionSelected) => !compareOptions(option, optionSelected));
        } else {
          if (exceedsMaxSelections()) {
            return;
          }
          valueComputed.value = addOption(option);
        }
      } else {
        valueComputed.value = option;
        hideAndFocus();
      }
      focusAutocompleteInput();
    };
    const addNewOption = () => {
      var _a2;
      const hasAddedOption = (_a2 = props.options) == null ? void 0 : _a2.some((option) => [searchVModel.value, autocompleteValue.value].includes(getText(option)));
      const allowedToCreateCheck = !((props.allowCreate === "unique" || props.autocomplete) && hasAddedOption);
      if (allowedToCreateCheck) {
        emit2("create-new", searchVModel.value || autocompleteValue.value);
        searchVModel.value = "";
        autocompleteValue.value = "";
      }
    };
    const hoveredOption = ref(null);
    const selectHoveredOption = () => {
      if (!isOpenSync.value) {
        handleDropdownOpen();
        return;
      }
      selectOption(hoveredOption.value);
    };
    const selectOrAddOption = () => {
      const allowedToCreate = !!props.allowCreate && (searchVModel.value || autocompleteValue.value);
      if (hoveredOption.value !== null) {
        selectHoveredOption();
      } else if (allowedToCreate) {
        addNewOption();
      }
    };
    const focusPreviousOption = () => {
      var _a2;
      return (_a2 = optionList.value) == null ? void 0 : _a2.focusPreviousOption();
    };
    const focusNextOption = () => {
      var _a2;
      return (_a2 = optionList.value) == null ? void 0 : _a2.focusNextOption();
    };
    const { isOpenSync, dropdownProps } = useDropdownable(props, emit2, {
      defaultCloseOnValueUpdate: computed(() => !props.multiple)
    });
    const dropdownPropsComputed = computed(() => ({
      ...dropdownProps.value,
      stateful: false,
      innerAnchorSelector: ".va-input-wrapper__field"
    }));
    const showDropdownContentComputed = computed({
      get: () => isOpenSync.value,
      set: (show) => {
        show ? handleDropdownOpen() : handleDropdownClose();
      }
    });
    const handleDropdownOpen = () => {
      if (props.disabled || props.readonly) {
        return;
      }
      isOpenSync.value = true;
      scrollToSelected();
      focusSearchOrOptions();
    };
    const handleDropdownClose = () => {
      isOpenSync.value = false;
      if (!props.autocomplete) {
        searchVModel.value = "";
      }
      nextTick(() => {
        validate();
        isInputFocused.focusIfNothingIfFocused();
      });
    };
    const hideAndFocus = () => {
      handleDropdownClose();
      isInputFocused.value = true;
    };
    const focusSearchBar = () => {
      var _a2;
      (_a2 = searchBar.value) == null ? void 0 : _a2.focus();
    };
    const focusOptionList = () => {
      var _a2, _b;
      (_a2 = optionList.value) == null ? void 0 : _a2.focus();
      !props.modelValue && ((_b = optionList.value) == null ? void 0 : _b.focusFirstOption());
    };
    const focusSearchOrOptions = async () => {
      await nextTick();
      if (showSearchInput.value) {
        focusSearchBar();
      } else {
        focusOptionList();
      }
    };
    const onInputBlur = () => {
      if (showDropdownContentComputed.value) {
        return;
      }
      onBlur();
      validationListeners.onBlur();
      isInputFocused.value ? isInputFocused.value = false : validate();
    };
    const tabIndexComputed = computed(() => props.disabled ? -1 : props.tabindex);
    const openSelectButtonTabIndexComputed = computed(() => props.disabled || props.autocomplete ? -1 : 0);
    const scrollToSelected = () => {
      const selected = valueComputed.value;
      const nothingSelected = typeof selected !== "object" && Array.isArray(selected) && !selected.length;
      if (nothingSelected) {
        return;
      }
      const scrollTo = Array.isArray(selected) ? selected[selected.length - 1] : selected;
      hoveredOption.value = scrollTo;
      nextTick(() => {
        var _a2;
        return (_a2 = optionList.value) == null ? void 0 : _a2.scrollToOption(scrollTo);
      });
    };
    let hintedSearchQuery = "";
    let hintedSearchQueryTimeoutIndex;
    const navigationKeys = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Enter", " "];
    const onHintedSearch = (event) => {
      if (navigationKeys.some((key) => key === event.key)) {
        return;
      }
      const isLetter = event.key.length === 1;
      const isDeleteKey = event.key === "Backspace" || event.key === "Delete";
      clearTimeout(hintedSearchQueryTimeoutIndex);
      if (isDeleteKey) {
        hintedSearchQuery = hintedSearchQuery ? hintedSearchQuery.slice(0, -1) : "";
      } else if (isLetter) {
        hintedSearchQuery += event.key;
      }
      if (showSearchInput.value) {
        searchVModel.value = hintedSearchQuery;
        return;
      }
      if (hintedSearchQuery) {
        const appropriateOption = props.options.find((option) => getText(option).toLowerCase().startsWith(hintedSearchQuery.toLowerCase()));
        if (appropriateOption) {
          hoveredOption.value = appropriateOption;
        }
      }
      hintedSearchQueryTimeoutIndex = setTimeout(() => {
        hintedSearchQuery = "";
      }, 1e3);
    };
    const minSearchCharsComputed = useNumericProp("minSearchChars");
    const optionsListPropsComputed = computed(() => ({
      ...pick(props, ["textBy", "trackBy", "groupBy", "valueBy", "disabledBy", "color", "virtualScroller", "highlightMatchedText", "delay", "selectedTopShown"]),
      autoSelectFirstOption: props.autoSelectFirstOption || props.autocomplete,
      search: searchVModel.value || autocompleteValue.value,
      tabindex: tabIndexComputed.value,
      selectedValue: valueComputed.value,
      options: filteredOptions.value,
      getSelectedState: checkIsOptionSelected,
      noOptionsText: tp(props.noOptionsText),
      doShowAllOptions: doShowAllOptions.value,
      minSearchChars: minSearchCharsComputed.value
    }));
    const { toggleIcon, toggleIconColor } = useToggleIcon(props, isOpenSync);
    const isFocused = computed(() => isInputFocused.value || isOpenSync.value);
    const slots = useSlots();
    const inputWrapperClassComputed = useBem("va-select-anchor", () => ({
      nowrap: !!(props.maxVisibleOptions && !slots.content)
    }));
    const vaInputWrapperProps = filterComponentProps(VaInputWrapperProps$2);
    const inputWrapperPropsComputed = computed(() => ({
      ...vaInputWrapperProps.value,
      error: computedError.value,
      errorMessages: computedErrorMessages.value,
      focused: isFocused.value,
      "aria-label": props.ariaLabel || (props.modelValue ? `${t("selectedOption")}: ${props.modelValue}` : t("noSelectedOption"))
    }));
    const selectContentPropsComputed = computed(() => ({
      ...pick(props, ["placeholder", "autocomplete", "multiple", "disabled", "readonly"]),
      tabindex: tabIndexComputed.value,
      value: visibleSelectedOptions.value,
      valueString: valueString.value,
      hiddenSelectedOptionsAmount: hiddenSelectedOptionsAmount.value,
      isAllOptionsShown: isAllOptionsShown.value,
      focused: isInputFocused.value,
      autocompleteInputValue: autocompleteValue.value,
      getText: getValueText
    }));
    const autocompleteValue = useAutocomplete(searchVModel, props, visibleSelectedOptions, isOpenSync, getText);
    const setAutocompleteValue = (v) => autocompleteValue.value = v;
    const doShowAllOptions = ref(true);
    watch(showDropdownContentComputed, () => {
      doShowAllOptions.value = true;
    });
    watch(searchVModel, () => {
      doShowAllOptions.value = false;
    });
    const focus = () => {
      if (props.disabled) {
        return;
      }
      focusElement(unwrapEl(input.value));
    };
    const blur = () => {
      if (showDropdownContentComputed.value) {
        showDropdownContentComputed.value = false;
      }
      nextTick(() => {
        if (props.disabled) {
          return;
        }
        blurElement(unwrapEl(input.value));
      });
    };
    const reset = () => withoutValidation(() => {
      if (props.multiple) {
        valueComputed.value = Array.isArray(props.clearValue) ? props.clearValue : [];
      } else {
        valueComputed.value = props.clearValue;
      }
      searchVModel.value = "";
      emit2("clear");
      resetValidation();
      nextTick(() => {
        isInputFocused.value = true;
      });
    });
    const focusAutocompleteInput = (e) => {
      if (props.autocomplete && !props.disabled && !props.readonly) {
        isInputFocused.value = true;
        isOpenSync.value = true;
      }
    };
    const toggleDropdown = (e) => {
      if (props.disabled || props.readonly) {
        return;
      }
      const isInInput = e.target && "tagName" in e.target && e.target.tagName === "INPUT";
      if (e.code === "Space" && isInInput) {
        return;
      }
      e.preventDefault();
      showDropdownContentComputed.value = !showDropdownContentComputed.value;
    };
    const deleteLastSelected = () => {
      if (!Array.isArray(valueComputed.value)) {
        return;
      }
      valueComputed.value = valueComputed.value.slice(0, -1);
    };
    const {
      validate,
      computedError,
      computedErrorMessages,
      withoutValidation,
      resetValidation,
      listeners: validationListeners,
      isTouched
    } = useValidation(props, emit2, { reset, focus, value: valueComputed });
    watch(isOpenSync, (isOpen) => {
      if (!isOpen) {
        isTouched.value = true;
      }
    });
    const { popupId } = useSelectAria();
    const searchInput = searchVModel;
    const onInputFocus = onFocus;
    __expose({
      focus,
      blur,
      reset
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaDropdown), mergeProps$1({
        ref: "dropdown",
        modelValue: showDropdownContentComputed.value,
        "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => showDropdownContentComputed.value = $event),
        class: "va-select va-select__dropdown va-select-dropdown"
      }, dropdownPropsComputed.value, {
        role: "combobox",
        "inner-anchor-selector": ".va-input-wrapper__field",
        "keyboard-navigation": false
      }), {
        anchor: withCtx(() => [
          createVNode(unref(VaInputWrapper), mergeProps$1(inputWrapperPropsComputed.value, {
            ref_key: "input",
            ref: input,
            class: ["va-select__anchor va-select-anchor__input", unref(inputWrapperClassComputed)],
            "aria-haspopup": "listbox",
            "model-value": unref(valueString),
            readonly: true,
            "aria-label": _ctx.$props.ariaLabel,
            "aria-controls": unref(popupId),
            "aria-owns": unref(popupId),
            onFocus: unref(onInputFocus),
            onBlur: onInputBlur
          }), createSlots$1({
            icon: withCtx(() => [
              showClearIcon.value ? (openBlock(), createBlock(unref(VaIcon), mergeProps$1({
                key: 0,
                role: "button",
                "aria-label": unref(tp)(_ctx.$props.ariaClearLabel)
              }, unref(clearIconProps), {
                onClick: withModifiers(reset, ["stop"]),
                onKeydown: [
                  withKeys(withModifiers(reset, ["stop"]), ["enter"]),
                  withKeys(withModifiers(reset, ["stop"]), ["space"])
                ]
              }), null, 16, ["aria-label", "onKeydown"])) : createCommentVNode("", true)
            ]),
            appendInner: withCtx(() => [
              createVNode(unref(VaIcon), {
                color: unref(toggleIconColor),
                name: unref(toggleIcon),
                class: "va-select__toggle-icon",
                role: "button",
                tabindex: openSelectButtonTabIndexComputed.value,
                "aria-expanded": showDropdownContentComputed.value,
                onKeydown: withKeys(toggleDropdown, ["enter"])
              }, null, 8, ["color", "name", "tabindex", "aria-expanded"])
            ]),
            default: withCtx(({ ariaAttributes }) => [
              createVNode(unref(VaSelectContent), mergeProps$1(selectContentPropsComputed.value, {
                ariaAttributes,
                separator: _ctx.$props.separator,
                onToggleHidden: unref(toggleHiddenOptionsState),
                onAutocompleteInput: setAutocompleteValue,
                onFocusPrev: focusPreviousOption,
                onFocusNext: focusNextOption,
                onSelectOption: selectOrAddOption,
                onDeleteLastSelected: deleteLastSelected
              }), createSlots$1({ _: 2 }, [
                renderList(_ctx.$slots, (_, name) => {
                  return {
                    name,
                    fn: withCtx((slotScope) => [
                      renderSlot(_ctx.$slots, name, normalizeProps$1(guardReactiveProps(slotScope)))
                    ])
                  };
                })
              ]), 1040, ["ariaAttributes", "separator", "onToggleHidden"])
            ]),
            _: 2
          }, [
            renderList(_ctx.$slots, (_, name) => {
              return {
                name,
                fn: withCtx((slotScope) => [
                  renderSlot(_ctx.$slots, name, normalizeProps$1(guardReactiveProps(slotScope)))
                ])
              };
            })
          ]), 1040, ["class", "model-value", "aria-label", "aria-controls", "aria-owns", "onFocus"])
        ]),
        default: withCtx(() => [
          createVNode(unref(VaDropdownContent), {
            class: "va-select-dropdown__content",
            style: normalizeStyle({ width: _ctx.$props.width }),
            onKeydown: withKeys(hideAndFocus, ["esc"]),
            role: "dialog"
          }, {
            default: withCtx(() => [
              showSearchInput.value ? (openBlock(), createBlock(unref(VaInputWrapper), {
                key: 0,
                ref_key: "searchBar",
                ref: searchBar,
                class: "va-select-dropdown__content-search-input",
                modelValue: unref(searchInput),
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(searchInput) ? searchInput.value = $event : null),
                "aria-label": unref(tp)(_ctx.$props.ariaSearchLabel),
                tabindex: tabIndexComputed.value,
                placeholder: unref(tp)(_ctx.$props.searchPlaceholderText),
                preset: "bordered",
                onKeydown: [
                  withKeys(withModifiers(focusPreviousOption, ["stop", "prevent"]), ["up"]),
                  withKeys(withModifiers(focusPreviousOption, ["stop", "prevent"]), ["left"]),
                  withKeys(withModifiers(focusNextOption, ["stop", "prevent"]), ["down"]),
                  withKeys(withModifiers(focusNextOption, ["stop", "prevent"]), ["right"]),
                  withKeys(withModifiers(selectOrAddOption, ["prevent"]), ["enter"])
                ],
                onFocus: _cache[1] || (_cache[1] = ($event) => hoveredOption.value = null)
              }, null, 8, ["modelValue", "aria-label", "tabindex", "placeholder", "onKeydown"])) : createCommentVNode("", true),
              createVNode(unref(VaSelectOptionList), mergeProps$1({
                ref_key: "optionList",
                ref: optionList,
                class: "va-select-dropdown__options-wrapper",
                hoveredOption: hoveredOption.value,
                "onUpdate:hoveredOption": _cache[2] || (_cache[2] = ($event) => hoveredOption.value = $event),
                style: { maxHeight: _ctx.$props.maxHeight },
                id: unref(popupId),
                "search-fn": _ctx.$props.searchFn
              }, optionsListPropsComputed.value, {
                onSelectOption: selectHoveredOption,
                onNoPreviousOptionToHover: focusSearchBar,
                onKeydown: [
                  _cache[3] || (_cache[3] = withKeys(withModifiers(($event) => searchBar.value && searchBar.value.focus(), ["stop", "prevent"]), ["tab"])),
                  onHintedSearch
                ],
                onScrollBottom
              }), {
                default: withCtx((slotData) => [
                  renderSlot(_ctx.$slots, "option", normalizeProps$1(guardReactiveProps(slotData)))
                ]),
                "option-content": withCtx((slotData) => [
                  renderSlot(_ctx.$slots, "option-content", normalizeProps$1(guardReactiveProps(slotData)))
                ]),
                _: 3
              }, 16, ["hoveredOption", "style", "id", "search-fn"])
            ]),
            _: 3
          }, 8, ["style"])
        ]),
        _: 3
      }, 16, ["modelValue"]);
    };
  }
});
const VaSelect = withConfigTransport$1(_sfc_main$w);
const _hoisted_1$j = {
  key: 0,
  class: "va-skeleton__wave"
};
const _sfc_main$v = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaSkeleton"
  },
  __name: "VaSkeleton",
  props: {
    color: { type: String, default: "backgroundElement" },
    delay: { type: [Number, String], default: 100 },
    tag: { type: String, default: "div" },
    animation: { type: String, default: "pulse" },
    lines: { type: [String, Number], default: 1 },
    height: { type: [String], default: "5em" },
    width: { type: [String], default: "100%" },
    lineGap: { type: String, default: "8px" },
    lastLineWidth: { type: [String], default: "75%" },
    variant: { type: String, default: "squared" },
    ariaLabel: useTranslationProp("$t:loading")
  },
  setup(__props) {
    const props = __props;
    const doShow = ref(false);
    const delayComputed = useNumericProp("delay");
    let timeoutId;
    onMounted(() => {
      clearTimeout(timeoutId);
      setTimeout(() => {
        doShow.value = true;
      }, delayComputed.value);
    });
    onBeforeUnmount(() => {
      clearTimeout(timeoutId);
    });
    const heightComputed = computed(() => {
      if (props.variant === "text") {
        return `${props.lines}em`;
      }
      return props.height;
    });
    const widthComputed = computed(() => {
      if (props.variant === "circle") {
        return heightComputed.value;
      }
      return props.width;
    });
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    computed(() => `-${props.lineGap}`);
    const bem = useBem("va-skeleton", () => ({
      lines: Number(props.lines) > 1,
      text: props.variant === "text",
      circle: props.variant === "circle",
      hidden: !doShow.value,
      pulse: props.animation === "pulse",
      wave: props.animation === "wave"
    }));
    const borderRadius = computed(() => {
      if (props.variant === "circle") {
        return "50%";
      }
      if (props.variant === "rounded") {
        return `var(--va-skeleton-border-radius, calc(${heightComputed.value} / 5))`;
      }
      return "0px";
    });
    const { tp } = useTranslation();
    const attrs = useAttrs();
    const classes = computed(() => [
      ...Object.keys(bem),
      attrs.class
    ]);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(__props.tag), {
        class: normalizeClass(["va-skeleton", classes.value]),
        role: "status",
        "aria-live": "polite",
        "aria-label": unref(tp)(_ctx.$props.ariaLabel),
        "aria-atomic": "true",
        style: normalizeStyle(`--va-color-computed: ${String(colorComputed.value)};--va-height-computed: ${String(heightComputed.value)};--va-width-computed: ${String(widthComputed.value)};--va-border-radius: ${String(borderRadius.value)};--va-line-gap: ${String(__props.lineGap)};--va-last-line-width: ${String(__props.lastLineWidth)}`)
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default"),
          __props.animation === "wave" ? (openBlock(), createElementBlock("div", _hoisted_1$j)) : createCommentVNode("", true)
        ]),
        _: 3
      }, 8, ["aria-label", "class", "style"]);
    };
  }
});
const _sfc_main$u = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaSkeletonGroup"
  },
  __name: "VaSkeletonGroup",
  props: {
    color: { type: String, default: "backgroundElement" },
    delay: { type: [Number, String], default: 100 },
    animation: { type: String, default: "pulse" },
    lines: { type: [Number, String], default: 1 },
    lineGap: { type: String, default: "8px" },
    lastLineWidth: { type: [String], default: "75%" }
  },
  setup(__props) {
    const props = __props;
    const doShow = ref(false);
    const delayComputed = useNumericProp("delay");
    let timeoutId;
    onMounted(() => {
      timeoutId = setTimeout(() => {
        doShow.value = true;
      }, delayComputed.value);
    });
    onBeforeMount(() => {
      clearTimeout(timeoutId);
    });
    const bem = useBem("va-skeleton-group", () => ({
      hidden: doShow.value === false
    }));
    const config = computed(() => ({ ...props, delay: 0 }));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$1W), {
        components: { VaSkeleton: config.value }
      }, {
        default: withCtx(() => [
          createBaseVNode("div", mergeProps$1({
            class: ["va-skeleton-group", unref(bem)]
          }, _ctx.$attrs), [
            renderSlot(_ctx.$slots, "default", {}, void 0, true)
          ], 16)
        ]),
        _: 3
      }, 8, ["components"]);
    };
  }
});
const _VaSkeletonGroup = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["__scopeId", "data-v-597bab9a"]]);
const VaSkeleton = withConfigTransport$1(_sfc_main$v);
const VaSkeletonGroup = withConfigTransport$1(_VaSkeletonGroup);
const VaSidebarKey = Symbol("VaSidebar");
const useSidebar = (props) => {
  provide(VaSidebarKey, props);
};
const useSidebarItem = () => {
  return inject$1(VaSidebarKey, {
    color: "background-element"
    // activeColor: 'primary',
  });
};
const useElementWidth = (el) => {
  const width = ref(null);
  useResizeObserver([el], () => {
    var _a2;
    width.value = ((_a2 = el.value) == null ? void 0 : _a2.clientWidth) ?? null;
  });
  watchEffect(() => {
    var _a2;
    width.value = ((_a2 = el.value) == null ? void 0 : _a2.clientWidth) ?? null;
  });
  return width;
};
const _sfc_main$t = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaSidebar"
  },
  __name: "VaSidebar",
  props: {
    ...useComponentPresetProp,
    activeColor: { type: String, default: "primary" },
    hoverColor: { type: String, default: void 0 },
    hoverOpacity: {
      type: [Number, String],
      default: 0.2,
      validator: (v) => Number(v) >= 0 && Number(v) <= 1
    },
    borderColor: { type: String, default: void 0 },
    color: { type: String, default: "background-element" },
    textColor: { type: String },
    gradient: { type: Boolean, default: false },
    minimized: { type: Boolean, default: false },
    hoverable: { type: Boolean, default: false },
    width: { type: String, default: "16rem" },
    minimizedWidth: { type: String, default: "4rem" },
    modelValue: { type: Boolean, default: true },
    animated: { type: [Boolean, String], default: true },
    closeOnClickOutside: { type: Boolean, default: false }
  },
  emits: ["update:modelValue"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const { getColor } = useColors();
    useSidebar(props);
    const isHovered = ref(false);
    const isMinimized = computed(() => props.minimized || props.hoverable && !isHovered.value);
    const menu = ref();
    const currentMenuWidth = useElementWidth(menu);
    const doShowMenu = computed(() => {
      if (props.modelValue === true) {
        return true;
      }
      if (currentMenuWidth.value === null) {
        return true;
      }
      return currentMenuWidth.value > 0;
    });
    const sidebarWidth = ref();
    const getSidebarWidth = () => {
      if (!props.modelValue) {
        return 0;
      }
      return isMinimized.value ? props.minimizedWidth : props.width;
    };
    const menuWidth = computed(() => isMinimized.value ? props.minimizedWidth : props.width);
    watchEffect(() => {
      const width = getSidebarWidth();
      setTimeout(() => {
        sidebarWidth.value = width;
      });
    });
    const backgroundColorComputed = computed(() => getColor(props.color));
    const { textColorComputed } = useTextColor(backgroundColorComputed);
    const computedStyle = computed(() => {
      const backgroundColor = getColor(backgroundColorComputed.value);
      const color = textColorComputed.value;
      return {
        color,
        backgroundColor,
        backgroundImage: props.gradient ? getGradientBackground(backgroundColor) : void 0,
        overflowX: currentMenuWidth.value === sidebarWidth.value ? void 0 : "hidden",
        width: sidebarWidth.value,
        minWidth: sidebarWidth.value
      };
    });
    const computedClass = useBem("va-sidebar", () => ({
      minimized: isMinimized.value,
      animated: Boolean(props.animated),
      "animated-right": props.animated === "right",
      "animated-left": props.animated === "left" || props.animated === true
    }));
    const updateHoverState = (newHoverState) => {
      isHovered.value = props.hoverable && newHoverState;
    };
    const rootElement = shallowRef();
    useClickOutside([rootElement], () => {
      if (props.closeOnClickOutside && props.modelValue) {
        setTimeout(() => {
          emit2("update:modelValue", false);
        }, 0);
      }
    });
    const vaSidebarItemProps = computed(() => ({
      textColor: props.textColor,
      activeColor: props.activeColor,
      hoverColor: props.hoverColor,
      borderColor: props.borderColor,
      hoverOpacity: props.hoverOpacity
    }));
    __expose({
      isMinimized,
      isHovered,
      updateHoverState,
      rootElement,
      menu,
      doShowMenu,
      menuWidth,
      sidebarWidth
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("aside", {
        ref_key: "rootElement",
        ref: rootElement,
        class: normalizeClass(["va-sidebar", unref(computedClass)]),
        style: normalizeStyle(computedStyle.value),
        onMouseenter: _cache[0] || (_cache[0] = ($event) => updateHoverState(true)),
        onMouseleave: _cache[1] || (_cache[1] = ($event) => updateHoverState(false))
      }, [
        withDirectives(createBaseVNode("div", {
          class: "va-sidebar__menu",
          ref_key: "menu",
          ref: menu,
          style: normalizeStyle({
            width: menuWidth.value,
            minWidth: menuWidth.value
          })
        }, [
          createVNode(unref(_sfc_main$1W), {
            components: { VaSidebarItem: vaSidebarItemProps.value }
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["components"])
        ], 4), [
          [vShow, doShowMenu.value]
        ])
      ], 38);
    };
  }
});
const VaSidebar = withConfigTransport$1(_sfc_main$t);
const _sfc_main$s = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaSidebarItem"
  },
  __name: "VaSidebarItem",
  props: {
    ...useRouterLinkProps,
    ...useComponentPresetProp,
    active: { type: Boolean, default: false },
    textColor: { type: String, default: void 0 },
    activeColor: { type: String, default: "primary" },
    hoverColor: { type: String, default: void 0 },
    hoverOpacity: { type: [Number, String], default: 0.2 },
    borderColor: { type: String, default: void 0 },
    disabled: { type: Boolean, default: false }
  },
  setup(__props) {
    const props = __props;
    const rootElement = useElementRef();
    const sidebar = useSidebarItem();
    const { isHovered } = useHover(rootElement, toRef(props, "disabled"));
    const { getColor, getHoverColor: getHoverColor2, getFocusColor: getFocusColor2 } = useColors();
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocus();
    const backgroundColorComputed = computed(() => {
      if (props.active && !isHovered.value && !hasKeyboardFocus.value) {
        return getColor(props.activeColor);
      }
      if (hasKeyboardFocus.value) {
        return getFocusColor2(getColor(props.hoverColor || props.activeColor));
      }
      return "#ffffff00";
    });
    const textBackground = computed(() => applyColors$1(getColor(sidebar == null ? void 0 : sidebar.color), backgroundColorComputed.value));
    const { textColorComputed } = useTextColor(textBackground);
    const computedStyle = computed(() => {
      const style = { color: textColorComputed.value };
      if (props.disabled) {
        return style;
      }
      if (isHovered.value || props.active || hasKeyboardFocus.value) {
        style.backgroundColor = backgroundColorComputed.value;
      }
      if (props.active) {
        const mergedProps = { ...sidebar, ...props };
        style.borderColor = getColor(mergedProps.borderColor || mergedProps.activeColor);
      }
      if (hasKeyboardFocus.value) {
        style.backgroundColor = getFocusColor2(getColor(props.hoverColor || props.activeColor));
      }
      if (isHovered.value) {
        style.backgroundColor = getHoverColor2(
          getColor(props.hoverColor || props.activeColor),
          Number(props.hoverOpacity)
        );
      }
      return style;
    });
    const { tagComputed, linkAttributesComputed } = useRouterLink(props);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(unref(tagComputed)), mergeProps$1({
        ref_key: "rootElement",
        ref: rootElement,
        class: ["va-sidebar__item va-sidebar-item", {
          "va-sidebar-item--active": _ctx.$props.active,
          "va-sidebar-item--disabled": _ctx.$props.disabled
        }],
        tabindex: _ctx.$props.disabled ? -1 : 0,
        style: computedStyle.value
      }, unref(linkAttributesComputed), toHandlers(unref(keyboardFocusListeners))), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["tabindex", "class", "style"]);
    };
  }
});
const _hoisted_1$i = { class: "va-sidebar__item__content va-sidebar-item-content" };
const _sfc_main$r = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaSidebarItemContent"
  },
  __name: "VaSidebarItemContent",
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$i, [
        renderSlot(_ctx.$slots, "default")
      ]);
    };
  }
});
const _hoisted_1$h = { class: "va-sidebar__title va-sidebar-item-title" };
const _sfc_main$q = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaSidebarItemTitle"
  },
  __name: "VaSidebarItemTitle",
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$h, [
        renderSlot(_ctx.$slots, "default")
      ]);
    };
  }
});
const VaSidebarItemContent = withConfigTransport$1(_sfc_main$r);
const VaSidebarItemTitle = withConfigTransport$1(_sfc_main$q);
const VaSidebarItem = withConfigTransport$1(_sfc_main$s);
const validateSlider = (value, step, min2, max2, range) => {
  if (Array.isArray(value) && !range || !Array.isArray(value) && range) {
    warn(`The type "${Array.isArray(value) ? "array" : typeof value}" of prop "model-value" does not match prop "range = ${range}".`);
  }
  if (max2 < min2) {
    warn(`The maximum value (${max2}) can not be less than the minimum value (${min2}).`);
  }
  if (!isDividable(max2 - min2, step)) {
    warn(`Step ${step} is illegal. Slider is non-divisible (Min:Max ${min2}:${max2}).`);
  }
  const inRange = (v) => {
    if (v < min2) {
      warn(`The value of the slider is ${v}, the minimum value is ${min2}, the value of this slider can not be less than the minimum value`);
    } else if (v > max2) {
      warn(`The value of the slider is ${v}, the maximum value is ${max2}, the value of this slider can not be greater than the maximum value`);
    }
  };
  if (Array.isArray(value)) {
    value.map(inRange);
  } else {
    inRange(value);
  }
  return true;
};
const _hoisted_1$g = {
  key: 0,
  class: "va-slider__input-wrapper",
  "aria-hidden": "true"
};
const _hoisted_2$7 = ["id"];
const _hoisted_3$4 = {
  key: 2,
  class: "va-input__label",
  "aria-hidden": "true"
};
const _hoisted_4$4 = ["tabindex", "onFocus"];
const _hoisted_5$2 = ["tabindex"];
const _hoisted_6 = {
  key: 3,
  class: "va-input__label--inverse",
  "aria-hidden": "true"
};
const _hoisted_7 = ["id"];
const _hoisted_8 = {
  key: 5,
  class: "va-slider__input-wrapper"
};
const _sfc_main$p = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaSlider"
  },
  __name: "VaSlider",
  props: {
    ...useStatefulProps,
    ...useComponentPresetProp,
    range: { type: Boolean, default: false },
    modelValue: { type: [Number, Array], default: 0 },
    trackLabel: { type: [Function, String] },
    color: { type: String, default: "primary" },
    trackColor: { type: String, default: "" },
    labelColor: { type: String, default: "" },
    trackLabelVisible: { type: Boolean, default: false },
    min: { type: [Number, String], default: 0 },
    max: { type: [Number, String], default: 100 },
    step: { type: [Number, String], default: 1 },
    label: { type: String, default: "" },
    invertLabel: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    pins: { type: Boolean, default: false },
    iconPrepend: { type: String, default: "" },
    iconAppend: { type: String, default: "" },
    vertical: { type: Boolean, default: false },
    showTrack: { type: Boolean, default: true },
    ariaLabel: useTranslationProp("$t:sliderValue")
  },
  emits: ["drag-start", "drag-end", "change", "update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const { getColor, getHoverColor: getHoverColor2 } = useColors();
    const sliderContainer = shallowRef();
    const dot = shallowRef();
    const { setItemRefByIndex, itemRefs: dots } = useArrayRefs();
    const isFocused = ref(false);
    const flag = ref(false);
    const offset2 = ref(0);
    const size2 = ref(0);
    const defaultValue = props.range ? [0, 100] : 0;
    const { valueComputed } = useStateful(props, emit2, "modelValue", { defaultValue });
    const currentSliderDotIndex = ref(0);
    const hasMouseDown = ref(false);
    const minComputed = useNumericProp("min");
    const maxComputed = useNumericProp("max");
    const stepComputed = useNumericProp("step");
    const orders = computed(() => props.vertical ? [1, 0] : [0, 1]);
    const pinPositionStyle = computed(() => props.vertical ? "bottom" : "left");
    const trackSizeStyle = computed(() => props.vertical ? "height" : "width");
    const moreToLess = computed(() => Array.isArray(val.value) && val.value[1] - stepComputed.value < val.value[0]);
    const lessToMore = computed(() => Array.isArray(val.value) && val.value[0] + stepComputed.value > val.value[1]);
    const sliderClass = useBem("va-slider", () => ({
      ...pick(props, ["disabled", "readonly", "vertical"]),
      active: isFocused.value,
      horizontal: !props.vertical,
      grabbing: hasMouseDown.value
    }));
    const dotClass = useBem("va-slider__handler", () => ({
      onFocus: !props.range && (flag.value || isFocused.value),
      inactive: !isFocused.value
    }));
    const labelStyles = computed(() => ({
      color: props.labelColor ? getColor(props.labelColor) : getColor(props.color)
    }));
    const trackStyles = computed(() => ({
      backgroundColor: props.trackColor ? getColor(props.trackColor) : getHoverColor2(getColor(props.color))
    }));
    const calculatePercentage = (value) => {
      const min2 = minComputed.value;
      const max2 = maxComputed.value;
      return (clamp2(min2, value, max2) - min2) / (max2 - min2) * 100;
    };
    const processedStyles = computed(() => {
      if (Array.isArray(val.value)) {
        const val0 = calculatePercentage(val.value[0]);
        const val1 = calculatePercentage(val.value[1]);
        return {
          [pinPositionStyle.value]: `${val0}%`,
          [trackSizeStyle.value]: `${val1 - val0}%`,
          backgroundColor: getColor(props.color),
          visibility: props.showTrack ? "visible" : "hidden"
        };
      } else {
        const val0 = calculatePercentage(val.value);
        return {
          [trackSizeStyle.value]: `${val0 > 100 ? 100 : val0}%`,
          backgroundColor: getColor(props.color),
          visibility: props.showTrack ? "visible" : "hidden"
        };
      }
    });
    const dottedStyles = computed(() => {
      if (Array.isArray(val.value)) {
        const val0 = calculatePercentage(val.value[0]);
        const val1 = calculatePercentage(val.value[1]);
        return [
          {
            [pinPositionStyle.value]: `${val0}%`,
            backgroundColor: isActiveDot(0) ? getColor(props.color) : "#ffffff",
            borderColor: getColor(props.color)
          },
          {
            [pinPositionStyle.value]: `${val1}%`,
            backgroundColor: isActiveDot(1) ? getColor(props.color) : "#ffffff",
            borderColor: getColor(props.color)
          }
        ];
      } else {
        const val0 = calculatePercentage(val.value);
        return {
          [pinPositionStyle.value]: `${val0 > 100 ? 100 : val0}%`,
          backgroundColor: isActiveDot(0) ? getColor(props.color) : "#ffffff",
          borderColor: getColor(props.color)
        };
      }
    });
    const getDottedStyles = (index) => props.range ? dottedStyles.value[index] : dottedStyles.value;
    const val = computed({
      get: () => valueComputed.value,
      set: (val2) => {
        if (!flag.value) {
          emit2("change", val2);
        }
        valueComputed.value = val2;
      }
    });
    const getValueByOrder = (order) => props.range && order !== void 0 ? val.value[order] : val.value;
    const gap = computed(() => {
      const total = (maxComputed.value - minComputed.value) / stepComputed.value;
      return size2.value / total;
    });
    const multiple = computed(() => {
      const decimals = `${stepComputed.value}`.split(".")[1];
      return decimals ? Math.pow(10, decimals.length) : 1;
    });
    const pinsCol = computed(() => (maxComputed.value - minComputed.value) / stepComputed.value - 1);
    const position = computed(() => {
      return Array.isArray(val.value) ? [(val.value[0] - minComputed.value) / stepComputed.value * gap.value, (val.value[1] - minComputed.value) / stepComputed.value * gap.value] : (val.value - minComputed.value) / stepComputed.value * gap.value;
    });
    const limit = computed(() => [0, size2.value]);
    const valueLimit = computed(() => [minComputed.value, maxComputed.value]);
    const isActiveDot = (index) => {
      if (!isFocused.value && !flag.value || props.disabled || props.readonly) {
        return false;
      }
      return props.range ? currentSliderDotIndex.value === index : currentSliderDotIndex.value === 0;
    };
    const moveStart = (e, index = currentSliderDotIndex.value) => {
      var _a2, _b;
      e.preventDefault();
      if (!index) {
        if (!props.range) {
          index = 0;
        } else if (Array.isArray(position.value)) {
          const touch = "touches" in e ? e.touches[0] : e;
          const pos = getPos(touch);
          index = pos > (position.value[1] - position.value[0]) / 2 + position.value[0] ? 1 : 0;
        }
      }
      if (Array.isArray(val.value)) {
        currentSliderDotIndex.value = index;
      }
      Array.isArray(val.value) ? (_a2 = dots.value[index]) == null ? void 0 : _a2.focus() : (_b = dot.value) == null ? void 0 : _b.focus();
      flag.value = true;
      emit2("drag-start");
    };
    const moving = (e) => {
      if (!hasMouseDown.value || !flag.value || props.disabled || props.readonly) {
        return;
      }
      e.preventDefault();
      if ("touches" in e) {
        setValueOnPos(getPos(e.touches[0]));
      } else {
        setValueOnPos(getPos(e));
      }
    };
    const moveEnd = () => {
      if (!props.disabled && !props.readonly) {
        if (flag.value) {
          emit2("drag-end");
          emit2("change", val.value);
        }
        flag.value = false;
        hasMouseDown.value = false;
      }
    };
    const clamp2 = (min2, v, max2) => Math.max(Math.min(v, max2), min2);
    const moveWithKeys = (event) => {
      var _a2, _b;
      if (![dots.value[0], dots.value[1], dot.value].includes(document.activeElement)) {
        return;
      }
      if (props.disabled || props.readonly) {
        return;
      }
      const moveDot = (where, which) => {
        if (Array.isArray(val.value)) {
          const value = val.value[which] + (where ? stepComputed.value : -stepComputed.value);
          const limitedValue = clamp2(minComputed.value, value, maxComputed.value);
          val.value = [
            which === 0 ? limitedValue : val.value[0],
            which === 1 ? limitedValue : val.value[1]
          ];
        } else {
          const value = val.value + (where ? stepComputed.value : -stepComputed.value);
          const limitedValue = clamp2(minComputed.value, value, maxComputed.value);
          val.value = limitedValue;
        }
      };
      if (["ArrowLeft", "ArrowUp", "ArrowRight", "ArrowDown"].includes(event.key)) {
        event.preventDefault();
      }
      const isActive = (el) => el === document.activeElement;
      if (props.range && Array.isArray(val.value)) {
        const isVerticalDot0More = (event2) => props.vertical && isActive(dots.value[0]) && event2.key === "ArrowUp";
        const isVerticalDot0Less = (event2) => props.vertical && isActive(dots.value[0]) && event2.key === "ArrowDown";
        const isVerticalDot1More = (event2) => props.vertical && isActive(dots.value[1]) && event2.key === "ArrowUp";
        const isVerticalDot1Less = (event2) => props.vertical && isActive(dots.value[1]) && event2.key === "ArrowDown";
        const isHorizontalDot0Less = (event2) => !props.vertical && isActive(dots.value[0]) && event2.key === "ArrowLeft";
        const isHorizontalDot0More = (event2) => !props.vertical && isActive(dots.value[0]) && event2.key === "ArrowRight";
        const isHorizontalDot1Less = (event2) => !props.vertical && isActive(dots.value[1]) && event2.key === "ArrowLeft";
        const isHorizontalDot1More = (event2) => !props.vertical && isActive(dots.value[1]) && event2.key === "ArrowRight";
        switch (true) {
          case ((isVerticalDot1Less(event) || isHorizontalDot1Less(event)) && moreToLess.value && val.value[0] !== minComputed.value):
            (_a2 = dots.value[0]) == null ? void 0 : _a2.focus();
            moveDot(0, 0);
            break;
          case ((isVerticalDot0More(event) || isHorizontalDot0More(event)) && lessToMore.value && val.value[1] !== maxComputed.value):
            (_b = dots.value[1]) == null ? void 0 : _b.focus();
            moveDot(1, 1);
            break;
          case ((isVerticalDot0Less(event) || isHorizontalDot0Less(event)) && val.value[0] !== minComputed.value):
            moveDot(0, 0);
            break;
          case ((isVerticalDot1More(event) || isHorizontalDot1More(event)) && val.value[1] !== maxComputed.value):
            moveDot(1, 1);
            break;
          case ((isVerticalDot1Less(event) || isHorizontalDot1Less(event)) && val.value[1] !== minComputed.value):
            moveDot(0, 1);
            break;
          case ((isVerticalDot0More(event) || isHorizontalDot0More(event)) && val.value[0] !== maxComputed.value):
            moveDot(1, 0);
            break;
        }
      } else {
        if (props.vertical) {
          if (event.key === "ArrowDown") {
            moveDot(0, 0);
          }
          if (event.key === "ArrowUp") {
            moveDot(1, 0);
          }
        } else {
          if (event.key === "ArrowLeft") {
            moveDot(0, 0);
          }
          if (event.key === "ArrowRight") {
            moveDot(1, 0);
          }
        }
      }
    };
    const checkActivePin = (pin) => {
      if (Array.isArray(val.value)) {
        return pin * stepComputed.value > val.value[0] && pin * stepComputed.value < val.value[1];
      } else {
        return pin * stepComputed.value < val.value;
      }
    };
    const pinPositionStep = computed(() => stepComputed.value / (maxComputed.value - minComputed.value) * 100);
    const getPinStyles = (pin) => ({
      backgroundColor: checkActivePin(pin) ? getColor(props.color) : getHoverColor2(getColor(props.color)),
      [pinPositionStyle.value]: `${pin * pinPositionStep.value}%`,
      transition: hasMouseDown.value ? "none" : "var(--va-slider-pin-transition)"
    });
    const getPos = (e) => {
      getStaticData();
      return props.vertical ? offset2.value - e.clientY : e.clientX - offset2.value;
    };
    const getStaticData = () => {
      if (sliderContainer.value) {
        size2.value = sliderContainer.value[props.vertical ? "offsetHeight" : "offsetWidth"];
        offset2.value = sliderContainer.value.getBoundingClientRect()[pinPositionStyle.value];
      }
    };
    const getValueByIndex = (index) => {
      return (stepComputed.value * multiple.value * index + minComputed.value * multiple.value) / multiple.value;
    };
    const getTrackLabel = (val2, order) => {
      if (!props.trackLabel) {
        return val2;
      }
      return typeof props.trackLabel === "function" ? props.trackLabel(val2, order) : props.trackLabel;
    };
    const setCurrentValue = (newValue) => {
      const slider = currentSliderDotIndex.value;
      if (Array.isArray(val.value)) {
        if (isDiff(val.value[slider], newValue)) {
          if (slider === 0) {
            val.value = [newValue, val.value[1]];
          } else {
            val.value = [val.value[0], newValue];
          }
        }
      } else {
        if (newValue < minComputed.value) {
          val.value = minComputed.value;
        } else if (newValue > maxComputed.value) {
          val.value = maxComputed.value;
        } else if (isDiff(val.value, newValue)) {
          val.value = newValue;
        }
      }
    };
    const setValueOnPos = (pixelPosition) => {
      const range = limit.value;
      const valueRange = valueLimit.value;
      const dotToFocus = Array.isArray(val.value) ? dots.value[currentSliderDotIndex.value] : dot.value;
      dotToFocus == null ? void 0 : dotToFocus.focus();
      if (pixelPosition >= range[0] && pixelPosition <= range[1]) {
        const v = getValueByIndex(Math.round(pixelPosition / gap.value));
        if (currentSliderDotIndex.value) {
          if (Array.isArray(position.value) && Array.isArray(val.value) && pixelPosition <= position.value[0]) {
            val.value = [v, val.value[0]];
            currentSliderDotIndex.value = 0;
          } else {
            setCurrentValue(v);
          }
        } else {
          if (Array.isArray(position.value) && Array.isArray(val.value) && pixelPosition >= position.value[1]) {
            val.value = [val.value[1], v];
            currentSliderDotIndex.value = 1;
          } else {
            setCurrentValue(v);
          }
        }
      } else if (pixelPosition < range[0]) {
        setCurrentValue(valueRange[0]);
      } else {
        setCurrentValue(valueRange[1]);
      }
    };
    const isDiff = (a, b) => JSON.stringify(a) !== JSON.stringify(b);
    const clickOnContainer = (e) => {
      if (props.disabled || props.readonly) {
        return;
      }
      const pos = "touches" in e ? getPos(e.touches[0]) : getPos(e);
      if (Array.isArray(position.value)) {
        currentSliderDotIndex.value = pos > (position.value[1] - position.value[0]) / 2 + position.value[0] ? 1 : 0;
      }
      hasMouseDown.value = true;
      setValueOnPos(pos);
      moveStart(e, currentSliderDotIndex.value);
    };
    const bindEvents = () => {
      document.addEventListener("mousemove", moving);
      document.addEventListener("touchmove", moving, { passive: false });
      document.addEventListener("mouseup", moveEnd);
      document.addEventListener("mouseleave", moveEnd);
      document.addEventListener("touchcancel", moveEnd);
      document.addEventListener("touchend", moveEnd);
      document.addEventListener("keydown", moveWithKeys);
    };
    const unbindEvents = () => {
      document.removeEventListener("mousemove", moving);
      document.removeEventListener("touchmove", moving);
      document.removeEventListener("mouseup", moveEnd);
      document.removeEventListener("mouseleave", moveEnd);
      document.removeEventListener("touchcancel", moveEnd);
      document.removeEventListener("touchend", moveEnd);
      document.removeEventListener("keydown", moveWithKeys);
    };
    const componentId = useComponentUuid();
    const ariaLabelIdComputed = computed(() => `aria-label-id-${componentId}`);
    const { tp } = useTranslation();
    const slots = useSlots();
    const ariaAttributesComputed = computed(() => ({
      role: "slider",
      "aria-valuemin": minComputed.value,
      "aria-valuemax": maxComputed.value,
      "aria-label": !slots.label && !props.label ? tp(props.ariaLabel, { value: String(val.value) }) : void 0,
      "aria-labelledby": slots.label || props.label ? ariaLabelIdComputed.value : void 0,
      "aria-orientation": props.vertical ? "vertical" : "horizontal",
      "aria-disabled": props.disabled,
      "aria-readonly": props.readonly,
      "aria-valuenow": !Array.isArray(val.value) ? val.value : void 0,
      "aria-valuetext": Array.isArray(val.value) ? String(val.value) : void 0
    }));
    onMounted(() => {
      if (validateSlider(val.value, stepComputed.value, minComputed.value, maxComputed.value, props.range)) {
        getStaticData();
        bindEvents();
      }
    });
    onBeforeUnmount(unbindEvents);
    watch([
      val,
      () => stepComputed.value,
      () => minComputed.value,
      () => maxComputed.value,
      () => props.range
    ], ([value, step, min2, max2, range]) => {
      validateSlider(value, step, min2, max2, range);
    });
    watch(hasMouseDown, (hasMouseDown2) => {
      document.documentElement.style.cursor = hasMouseDown2 ? "grabbing" : "";
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", mergeProps$1({
        class: ["va-slider", unref(sliderClass)]
      }, ariaAttributesComputed.value), [
        (__props.vertical ? _ctx.$slots.append : _ctx.$slots.prepend) ? (openBlock(), createElementBlock("div", _hoisted_1$g, [
          renderSlot(_ctx.$slots, __props.vertical ? "append" : "prepend")
        ])) : createCommentVNode("", true),
        (_ctx.$slots.label || __props.label) && !__props.invertLabel ? (openBlock(), createElementBlock("span", {
          key: 1,
          class: "va-input__label",
          id: ariaLabelIdComputed.value,
          style: normalizeStyle(labelStyles.value)
        }, [
          renderSlot(_ctx.$slots, "label", {}, () => [
            createTextVNode(toDisplayString(__props.label), 1)
          ])
        ], 12, _hoisted_2$7)) : createCommentVNode("", true),
        (__props.vertical ? __props.iconAppend : __props.iconPrepend) ? (openBlock(), createElementBlock("span", _hoisted_3$4, [
          createVNode(unref(VaIcon), {
            name: __props.vertical ? __props.iconAppend : __props.iconPrepend,
            color: unref(getColor)(_ctx.$props.color),
            size: 16
          }, null, 8, ["name", "color"])
        ])) : createCommentVNode("", true),
        createBaseVNode("div", {
          ref_key: "sliderContainer",
          ref: sliderContainer,
          class: "va-slider__container",
          onMousedown: clickOnContainer,
          onTouchstart: clickOnContainer
        }, [
          createBaseVNode("div", {
            class: "va-slider__track",
            "aria-hidden": "true",
            style: normalizeStyle(trackStyles.value)
          }, null, 4),
          __props.pins ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(pinsCol.value, (pin, i) => {
            return openBlock(), createElementBlock("div", {
              key: i,
              class: normalizeClass(["va-slider__mark", { "va-slider__mark--active": checkActivePin(pin) }]),
              style: normalizeStyle(getPinStyles(pin))
            }, null, 6);
          }), 128)) : createCommentVNode("", true),
          _ctx.$props.range ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            createBaseVNode("div", {
              ref: "process",
              class: normalizeClass(["va-slider__track va-slider__track--selected", { "va-slider__track--active": isFocused.value }]),
              "aria-hidden": "true",
              style: normalizeStyle(processedStyles.value)
            }, null, 6),
            (openBlock(true), createElementBlock(Fragment, null, renderList(orders.value, (order) => {
              return openBlock(), createElementBlock("div", {
                key: "dot" + order,
                ref_for: true,
                ref: unref(setItemRefByIndex)(order),
                class: normalizeClass(["va-slider__handler", unref(dotClass)]),
                style: normalizeStyle(getDottedStyles(order)),
                tabindex: __props.disabled || __props.readonly ? void 0 : 0,
                onFocus: ($event) => (isFocused.value = true, currentSliderDotIndex.value = order),
                onBlur: _cache[0] || (_cache[0] = ($event) => isFocused.value = false)
              }, [
                isActiveDot(order) ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  style: normalizeStyle({ backgroundColor: unref(getColor)(_ctx.$props.color) }),
                  class: "va-slider__handler__dot--focus"
                }, null, 4)) : createCommentVNode("", true),
                __props.trackLabelVisible ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  style: normalizeStyle(labelStyles.value),
                  class: "va-slider__handler__dot--value"
                }, [
                  renderSlot(_ctx.$slots, "trackLabel", normalizeProps$1(guardReactiveProps({ value: getValueByOrder(order), order })), () => [
                    createTextVNode(toDisplayString(getTrackLabel(getValueByOrder(order), order)), 1)
                  ])
                ], 4)) : createCommentVNode("", true)
              ], 46, _hoisted_4$4);
            }), 128))
          ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
            createBaseVNode("div", {
              ref: "process",
              "aria-hidden": "true",
              class: normalizeClass(["va-slider__track va-slider__track--selected", { "va-slider__track--active": isFocused.value }]),
              style: normalizeStyle(processedStyles.value)
            }, null, 6),
            createBaseVNode("div", {
              ref_key: "dot",
              ref: dot,
              class: normalizeClass(["va-slider__handler", unref(dotClass)]),
              style: normalizeStyle(dottedStyles.value),
              tabindex: _ctx.$props.disabled || _ctx.$props.readonly ? void 0 : 0,
              onFocus: _cache[1] || (_cache[1] = ($event) => isFocused.value = true),
              onBlur: _cache[2] || (_cache[2] = ($event) => isFocused.value = false)
            }, [
              isActiveDot(0) ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "va-slider__handler__dot--focus",
                style: normalizeStyle({ backgroundColor: unref(getColor)(_ctx.$props.color) })
              }, null, 4)) : createCommentVNode("", true),
              __props.trackLabelVisible ? (openBlock(), createElementBlock("div", {
                key: 1,
                class: "va-slider__handler__dot--value",
                style: normalizeStyle(labelStyles.value)
              }, [
                renderSlot(_ctx.$slots, "trackLabel", normalizeProps$1(guardReactiveProps({ value: getValueByOrder() })), () => [
                  createTextVNode(toDisplayString(getTrackLabel(getValueByOrder())), 1)
                ])
              ], 4)) : createCommentVNode("", true)
            ], 46, _hoisted_5$2)
          ], 64))
        ], 544),
        (__props.vertical ? __props.iconPrepend : __props.iconAppend) ? (openBlock(), createElementBlock("span", _hoisted_6, [
          createVNode(unref(VaIcon), {
            name: __props.vertical ? __props.iconPrepend : __props.iconAppend,
            color: unref(getColor)(_ctx.$props.color),
            size: 16
          }, null, 8, ["name", "color"])
        ])) : createCommentVNode("", true),
        (_ctx.$slots.label || __props.label) && __props.invertLabel ? (openBlock(), createElementBlock("span", {
          key: 4,
          class: "va-input__label va-input__label--inverse",
          style: normalizeStyle(labelStyles.value),
          id: ariaLabelIdComputed.value
        }, [
          renderSlot(_ctx.$slots, "label", {}, () => [
            createTextVNode(toDisplayString(__props.label), 1)
          ])
        ], 12, _hoisted_7)) : createCommentVNode("", true),
        (__props.vertical ? _ctx.$slots.prepend : _ctx.$slots.append) ? (openBlock(), createElementBlock("div", _hoisted_8, [
          renderSlot(_ctx.$slots, __props.vertical ? "prepend" : "append")
        ])) : createCommentVNode("", true)
      ], 16);
    };
  }
});
const VaSlider = withConfigTransport$1(_sfc_main$p);
const isNumber = (value) => typeof value === "number";
const useSplitDraggerProps = {
  vertical: { type: Boolean, default: false },
  disabled: { type: Boolean, default: false }
};
const useSplitDragger = (containerSizeComputed, splitterPositionComputed, props) => {
  const isDragging = ref(false);
  const dragStartPosition = ref(0);
  const dragStartSplitterPosition = ref(0);
  const currentSplitterPosition = ref(0);
  const getEventPosition = (e, eventName) => {
    const event = e.type === eventName ? e : e.changedTouches[0];
    return props.vertical ? event.pageY : event.pageX;
  };
  const startDragging = (e) => {
    if (props.disabled || !containerSizeComputed.value) {
      return;
    }
    isDragging.value = true;
    dragStartPosition.value = getEventPosition(e, "mousedown");
    dragStartSplitterPosition.value = splitterPositionComputed.value;
  };
  const processDragging = (e) => {
    if (!isDragging.value) {
      return;
    }
    const currentPosition = getEventPosition(e, "mousemove");
    const distance = currentPosition - dragStartPosition.value;
    currentSplitterPosition.value = dragStartSplitterPosition.value + Math.floor(distance / containerSizeComputed.value * 100);
  };
  const stopDragging = () => {
    isDragging.value = false;
  };
  useEvent(["mousemove", "touchmove"], processDragging);
  useEvent(["mouseup", "touchcancel"], stopDragging);
  return { isDragging, startDragging, currentSplitterPosition };
};
const _hoisted_1$f = ["aria-label"];
const _hoisted_2$6 = { class: "va-split__dragger" };
const _sfc_main$o = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaSplit"
  },
  __name: "VaSplit",
  props: {
    ...useComponentPresetProp,
    ...useSplitDraggerProps,
    ...useStatefulProps,
    modelValue: {
      type: Number,
      default: 50,
      validator: (v) => v <= 100
    },
    maximization: { type: Boolean, default: false },
    maximizeStart: { type: Boolean, default: false },
    limits: {
      type: Array,
      default: () => [0, 0]
    },
    snapping: {
      type: Array,
      default: void 0
    },
    snappingRange: { type: [Number, String], default: 4 },
    ariaLabel: useTranslationProp("$t:splitPanels")
  },
  emits: [...useStatefulEmits],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const splitPanelsContainer = shallowRef();
    const { valueComputed } = useStateful(props, emit2);
    const containerSize = ref();
    const bodyFontSize = ref(16);
    const handleContainerResize = () => {
      var _a2;
      const { width, height } = ((_a2 = splitPanelsContainer.value) == null ? void 0 : _a2.getBoundingClientRect()) || { width: 0, height: 0 };
      containerSize.value = props.vertical ? height : width;
      bodyFontSize.value = parseFloat(getComputedStyle(document.documentElement).fontSize);
    };
    onMounted(handleContainerResize);
    useResizeObserver([splitPanelsContainer], handleContainerResize);
    const convertToPercents = (v, type) => {
      let numberValue = "";
      let measureValue = "";
      if (isNumber(v)) {
        return v;
      }
      v.split("").filter((char) => char && char !== " ").forEach((char) => {
        !isNaN(+char) ? numberValue += char : measureValue += char;
      });
      switch (measureValue) {
        case "%":
          return +numberValue;
        case "px":
          return +numberValue / containerSize.value * 100;
        case "rem":
          return +numberValue * bodyFontSize.value / containerSize.value * 100;
        case "any":
          return ["min", "snapping"].includes(type) ? 0 : 100;
        case "":
          return 100;
        default:
          warn("Invalid limits measure!");
          return 0;
      }
    };
    const getPanelMinMax = (v) => {
      if (v === "undefined" || !containerSize.value) {
        return;
      }
      let minPercents = 0;
      let maxPercents = 100;
      if (isString(v) || isNumber(v)) {
        minPercents = convertToPercents(v, "min");
      }
      if (Array.isArray(v)) {
        minPercents = convertToPercents(v[0], "min");
        maxPercents = convertToPercents(v[1], "max");
      }
      if (minPercents > maxPercents) {
        warn(`Min panels size can not be larger than max one! Passed limit: ${v}.`);
        maxPercents = minPercents;
      }
      return { min: minPercents ?? 0, max: maxPercents ?? 100 };
    };
    const startPanelMinMax = computed(() => getPanelMinMax(props.limits[0]) ?? { min: 0, max: 100 });
    const endPanelMinMax = computed(() => getPanelMinMax(props.limits[1]) ?? { min: 0, max: 100 });
    const endPanelMinChecked = computed(() => {
      const passedCheck = !(startPanelMinMax.value.min + endPanelMinMax.value.min > 100);
      if (!passedCheck) {
        warn("The sum of different panels min sizes should be lesser or equal to 100% of the container size!");
      }
      return !passedCheck ? 100 - startPanelMinMax.value.min : endPanelMinMax.value.min;
    });
    const panelsMinMax = computed(() => {
      if (Math.ceil(endPanelMinMax.value.max + startPanelMinMax.value.max) < 100) {
        warn("The sum of different panels max sizes should be equal to 100% of the container size!");
      }
      return {
        start: {
          min: startPanelMinMax.value.min,
          max: Math.min(startPanelMinMax.value.max, 100 - endPanelMinChecked.value)
        },
        end: {
          min: endPanelMinChecked.value,
          max: Math.min(endPanelMinMax.value.max, 100 - startPanelMinMax.value.min)
        }
      };
    });
    const checkSnappingLimitsCondition = (el) => el >= panelsMinMax.value.start.min && el >= panelsMinMax.value.end.min && el <= panelsMinMax.value.start.max && el <= panelsMinMax.value.end.max;
    const snappingMarksPosition = computed(() => {
      if (!Array.isArray(props.snapping) || !containerSize.value) {
        return;
      }
      let result = props.snapping.map((el) => convertToPercents(el, "snapping"));
      if (!result.every(checkSnappingLimitsCondition)) {
        const filteredMarks = result.filter(checkSnappingLimitsCondition);
        warn(`Some of the snapping marks (${result}) are not in allowed range (${Object.values(panelsMinMax.value.start).join("-")} / ${Object.values(panelsMinMax.value.end).join("-")}) and will be removed (${filteredMarks})!`);
        result = filteredMarks;
      }
      const checkSnappingRange = () => {
        return result.every((el, index, array) => {
          if (!array[index + 1]) {
            return true;
          }
          return Math.abs(el - array[index + 1]) > Number(props.snappingRange);
        });
      };
      if (!checkSnappingRange()) {
        warn("Distance between some snapping marks is lesser than snapping range!");
      }
      return result;
    });
    const snappingRangeParsed = computed(() => convertToPercents(props.snappingRange, "snapping"));
    const splitterPosition = ref(valueComputed.value);
    const splitterPositionComputed = computed(() => {
      if (snappingMarksPosition.value) {
        const nearestSnappingMark = snappingMarksPosition.value.find((el) => {
          return splitterPosition.value + snappingRangeParsed.value > el && splitterPosition.value - snappingRangeParsed.value < el;
        });
        if (nearestSnappingMark) {
          return nearestSnappingMark;
        }
      }
      return clamp$1(
        splitterPosition.value,
        Math.max(panelsMinMax.value.start.min, 100 - panelsMinMax.value.end.max),
        Math.min(panelsMinMax.value.start.max, 100 - panelsMinMax.value.end.min)
      );
    });
    const {
      isDragging,
      startDragging,
      currentSplitterPosition
    } = useSplitDragger(containerSize, splitterPositionComputed, props);
    const maximizePanel = () => {
      if (!props.maximization || props.disabled) {
        return;
      }
      splitterPosition.value = props.maximizeStart ? panelsMinMax.value.start.max : 100 - panelsMinMax.value.end.max;
    };
    watch(valueComputed, (v) => {
      if (v < panelsMinMax.value.start.min || v > 100 - panelsMinMax.value.end.min) {
        warn("Incorrect `modelValue`. Check current `limits` prop value.");
      }
      splitterPosition.value = v;
    }, { immediate: true });
    watch(currentSplitterPosition, (v) => {
      splitterPosition.value = v;
    });
    watch(isDragging, (v) => {
      if (!v) {
        valueComputed.value = splitterPositionComputed.value;
      }
      document.documentElement.style.cursor = v ? "var(--va-split-dragging-cursor)" : "";
    });
    const sizePropertyComputed = computed(() => props.vertical ? "height" : "width");
    const getPanelStyle = (position) => {
      let sizeValue = position === "start" ? splitterPositionComputed.value : 100 - splitterPositionComputed.value;
      if (sizeValue < 0) {
        sizeValue = 0;
      }
      if (sizeValue > 100) {
        sizeValue = 100;
      }
      return { [sizePropertyComputed.value]: `${sizeValue}%` };
    };
    const draggerStyleComputed = computed(() => {
      if (props.disabled) {
        return {};
      }
      if (isDragging.value) {
        return { cursor: "var(--va-split-dragging-cursor)" };
      }
      return { cursor: props.vertical ? "var(--va-split-vertical-dragger-cursor)" : "var(--va-split-horizontal-dragger-cursor)" };
    });
    const classComputed = useBem("va-split", () => ({
      horizontal: !props.vertical,
      vertical: props.vertical,
      dragging: isDragging.value
    }));
    const { tp } = useTranslation();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("section", {
        ref_key: "splitPanelsContainer",
        ref: splitPanelsContainer,
        class: normalizeClass(["va-split", unref(classComputed)]),
        "aria-label": unref(tp)(_ctx.$props.ariaLabel)
      }, [
        createBaseVNode("div", {
          class: "va-split__panel",
          style: normalizeStyle(getPanelStyle("start"))
        }, [
          renderSlot(_ctx.$slots, "start", normalizeProps$1(guardReactiveProps({ containerSize: containerSize.value })))
        ], 4),
        createBaseVNode("div", _hoisted_2$6, [
          createBaseVNode("div", {
            class: "va-split__dragger__overlay",
            style: normalizeStyle(draggerStyleComputed.value),
            onMousedown: _cache[0] || (_cache[0] = withModifiers(
              //@ts-ignore
              (...args) => unref(startDragging) && unref(startDragging)(...args),
              ["prevent"]
            )),
            onTouchstart: _cache[1] || (_cache[1] = withModifiers(
              //@ts-ignore
              (...args) => unref(startDragging) && unref(startDragging)(...args),
              ["prevent"]
            )),
            onDblclick: withModifiers(maximizePanel, ["prevent"]),
            onContextmenu: _cache[2] || (_cache[2] = withModifiers(() => {
            }, ["prevent"])),
            onDragstart: _cache[3] || (_cache[3] = withModifiers(() => {
            }, ["prevent"]))
          }, [
            renderSlot(_ctx.$slots, "grabber", {}, () => [
              createVNode(unref(VaDivider), {
                class: "va-split__dragger__default",
                vertical: !_ctx.$props.vertical
              }, null, 8, ["vertical"])
            ])
          ], 36)
        ]),
        createBaseVNode("div", {
          class: "va-split__panel",
          style: normalizeStyle(getPanelStyle("end"))
        }, [
          renderSlot(_ctx.$slots, "end", normalizeProps$1(guardReactiveProps({ containerSize: containerSize.value })))
        ], 4)
      ], 10, _hoisted_1$f);
    };
  }
});
const VaSplit = withConfigTransport$1(_sfc_main$o);
const TabsViewKey = Symbol("TabsView");
const _hoisted_1$e = ["aria-disabled"];
const _hoisted_2$5 = /* @__PURE__ */ createBaseVNode("div", { class: "va-tabs__slider" }, null, -1);
const _hoisted_3$3 = [
  _hoisted_2$5
];
const _hoisted_4$3 = { class: "va-tabs__tabs-items" };
const _hoisted_5$1 = { class: "va-tabs__content" };
const getClientWidth = (element) => (element == null ? void 0 : element.clientWidth) || 0;
const _sfc_main$n = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaTabs"
  },
  __name: "VaTabs",
  props: {
    ...useStatefulProps,
    ...useComponentPresetProp,
    modelValue: { type: [String, Number], default: null },
    left: { type: Boolean, default: true },
    right: { type: Boolean, default: false },
    center: { type: Boolean, default: false },
    grow: { type: Boolean, default: false },
    hidePagination: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    hideSlider: { type: Boolean, default: false },
    vertical: { type: Boolean, default: false },
    color: { type: String, default: "primary" },
    prevIcon: { type: String, default: "va-arrow-left" },
    nextIcon: { type: String, default: "va-arrow-right" },
    ariaMoveRightLabel: useTranslationProp("$t:movePaginationLeft"),
    ariaMoveLeftLabel: useTranslationProp("$t:movePaginationRight")
  },
  emits: ["update:modelValue", "click:next", "click:prev"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const { tp } = useTranslation();
    const props = __props;
    const emit2 = __emit;
    const wrapper = shallowRef();
    const container = shallowRef();
    const tabs = shallowRef();
    const tabsList = ref([]);
    const sliderHeight = ref(null);
    const sliderWidth = ref(null);
    const sliderOffsetX = ref(0);
    const sliderOffsetY = ref(0);
    const showPagination = ref(false);
    const tabsContentOffset = ref(0);
    const startingXPoint = ref(0);
    const animationIncluded = ref(false);
    const { valueComputed: tabSelected } = useStateful(props, emit2);
    const tabConfig = reactive({
      VaTab: {
        color: props.color
      }
    });
    const computedClass = computed(() => {
      const { left, right, center, grow, disabled } = props;
      return {
        "va-tabs__container--left": left && !right && !center && !grow,
        "va-tabs__container--right": right,
        "va-tabs__container--center": center,
        "va-tabs__container--grow": grow,
        "va-tabs__container--disabled": disabled
      };
    });
    const computedTabsClass = computed(() => ({ "va-tabs--vertical": props.vertical }));
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const sliderStyles = computed(() => {
      if (props.hideSlider) {
        return { display: "none" };
      }
      return {
        backgroundColor: colorComputed.value,
        height: props.vertical ? `${sliderHeight.value}px` : "",
        width: props.vertical ? "" : `${sliderWidth.value}px`,
        transform: `translateY(-${sliderOffsetY.value}px) translateX(${sliderOffsetX.value}px)`,
        transition: animationIncluded.value ? "var(--va-tabs-slider-wrapper-transition)" : ""
      };
    });
    const paginationControlledStyles = computed(() => {
      if (props.vertical) {
        return {
          transform: "translateX(0px)"
        };
      }
      return {
        transform: `translateX(${startingXPoint.value - tabsContentOffset.value}px)`,
        transition: animationIncluded.value ? "var(--va-tabs-slider-transition)" : "",
        position: props.hidePagination ? "unset" : "absolute"
      };
    });
    const disablePaginationLeft = computed(() => tabsContentOffset.value === 0);
    const disablePaginationRight = computed(() => {
      const lastTab = tabsList.value[tabsList.value.length - 1];
      const leftSidePosition = unref(lastTab.leftSidePosition);
      const rightSidePosition = unref(lastTab.rightSidePosition);
      const containerClientWidth = getClientWidth(container.value);
      return rightSidePosition <= tabsContentOffset.value + containerClientWidth || leftSidePosition <= tabsContentOffset.value;
    });
    const resetSliderSizes = () => {
      sliderWidth.value = 0;
      sliderHeight.value = 0;
    };
    const moveToTab = (tab) => {
      const containerClientWidth = getClientWidth(container.value);
      const leftSidePosition = unref(tab.leftSidePosition);
      const rightSidePosition = unref(tab.rightSidePosition);
      if (!showPagination.value) {
        tabsContentOffset.value = 0;
        return;
      }
      if (leftSidePosition - tabsContentOffset.value >= 0 && rightSidePosition - tabsContentOffset.value <= containerClientWidth) {
        return;
      }
      if (leftSidePosition - tabsContentOffset.value < 0) {
        tabsContentOffset.value = leftSidePosition;
        return;
      }
      if (rightSidePosition - tabsContentOffset.value > containerClientWidth) {
        tabsContentOffset.value = rightSidePosition - containerClientWidth;
        return;
      }
      tabsContentOffset.value = 0;
    };
    const updateStartingXPoint = () => {
      startingXPoint.value = 0;
      if (!showPagination.value) {
        return;
      }
      const containerClientWidth = getClientWidth(container.value);
      const tabsClientWidth = getClientWidth(tabs.value);
      if (props.right) {
        startingXPoint.value = tabsClientWidth - containerClientWidth;
      } else if (props.center) {
        startingXPoint.value = Math.floor((tabsClientWidth - containerClientWidth) / 2);
      }
    };
    const updateTabsState = () => {
      resetSliderSizes();
      tabsList.value.forEach((tab) => {
        var _a2;
        tab.updateSidePositions();
        const isTabSelected = (((_a2 = tab.name) == null ? void 0 : _a2.value) || tab.id) === tabSelected.value;
        tab.isActive = tab.isActiveRouterLink || isTabSelected;
        if (tab.isActive) {
          moveToTab(tab);
          updateSlider(tab);
        }
      });
      updateStartingXPoint();
    };
    watchEffect(() => {
      updateTabsState();
    });
    const updatePagination = () => {
      const tabsClientWidth = getClientWidth(tabs.value);
      const wrapperClientWidth = getClientWidth(wrapper.value);
      requestAnimationFrame(() => {
        showPagination.value = !!(tabs.value && wrapper.value && tabsClientWidth > wrapperClientWidth);
      });
    };
    const movePaginationLeft = () => {
      var _a2, _b;
      const containerClientWidth = getClientWidth(container.value);
      let offsetToSet = tabsContentOffset.value - containerClientWidth;
      for (let i = 0; i < tabsList.value.length - 1; i++) {
        const currentTabLeftSidePosition = unref((_a2 = tabsList.value[i]) == null ? void 0 : _a2.leftSidePosition);
        const nextTabLeftSidePosition = unref((_b = tabsList.value[i + 1]) == null ? void 0 : _b.leftSidePosition);
        if (currentTabLeftSidePosition > offsetToSet && currentTabLeftSidePosition < tabsContentOffset.value || nextTabLeftSidePosition >= tabsContentOffset.value) {
          offsetToSet = currentTabLeftSidePosition;
          break;
        }
      }
      tabsContentOffset.value = Math.max(0, offsetToSet);
      emit2("click:prev");
    };
    const movePaginationRight = () => {
      var _a2;
      const containerClientWidth = getClientWidth(container.value);
      const containerRightSide = tabsContentOffset.value + containerClientWidth;
      let offsetToSet = containerRightSide;
      for (let i = 0; i < tabsList.value.length - 1; i++) {
        const rightSidePosition2 = unref(tabsList.value[i].rightSidePosition);
        if (rightSidePosition2 > containerRightSide) {
          offsetToSet = unref(tabsList.value[i].leftSidePosition);
          if (tabsContentOffset.value < offsetToSet) {
            break;
          }
        }
      }
      const rightSidePosition = unref((_a2 = tabsList.value[tabsList.value.length - 1]) == null ? void 0 : _a2.rightSidePosition);
      const maxOffset = rightSidePosition - containerClientWidth;
      offsetToSet = Math.min(maxOffset, offsetToSet);
      tabsContentOffset.value = Math.max(0, offsetToSet);
      emit2("click:next");
    };
    const updateSlider = (tab) => {
      var _a2;
      const tabElement = unref(tab.tabElement);
      const tabOffsetTop = (tabElement == null ? void 0 : tabElement.offsetTop) || 0;
      const tabOffsetLeft = (tabElement == null ? void 0 : tabElement.offsetLeft) || 0;
      const tabClientHeight = (tabElement == null ? void 0 : tabElement.clientHeight) || 0;
      const tabClientWidth = (tabElement == null ? void 0 : tabElement.clientWidth) || 0;
      if (props.vertical) {
        const containerClientHeight = ((_a2 = container.value) == null ? void 0 : _a2.clientHeight) || 0;
        const calculatedSliderOffsetY = containerClientHeight - tabOffsetTop - tabClientHeight;
        sliderOffsetY.value = Math.max(calculatedSliderOffsetY, 0);
        sliderHeight.value = tabClientHeight;
        sliderOffsetX.value = 0;
        sliderWidth.value = 0;
      } else {
        sliderOffsetX.value = tabOffsetLeft;
        sliderWidth.value = tabClientWidth;
        sliderOffsetY.value = 0;
        sliderHeight.value = 0;
      }
    };
    const includeAnimation = () => {
      if (!animationIncluded.value) {
        requestAnimationFrame(() => {
          animationIncluded.value = true;
        });
      }
    };
    const selectTab = (tab) => {
      var _a2;
      if (!tab) {
        return;
      }
      tabSelected.value = ((_a2 = tab.name) == null ? void 0 : _a2.value) || tab.id;
      if (props.stateful) {
        updateTabsState();
      }
    };
    const registerTab = (tab) => {
      var _a2;
      const idx = tabsList.value.push(tab) - 1;
      tab.id = ((_a2 = tab.name) == null ? void 0 : _a2.value) || idx;
    };
    const unregisterTab = (tab) => {
      tabsList.value = tabsList.value.filter((filteredTab) => filteredTab.id !== tab.id);
      tabsList.value.forEach((tabListItem, idx) => {
        var _a2;
        tabListItem.id = ((_a2 = tabListItem.name) == null ? void 0 : _a2.value) || idx;
      });
    };
    provide(TabsViewKey, {
      parentDisabled: props.disabled,
      selectTab,
      moveToTab,
      registerTab,
      unregisterTab
    });
    watch(() => props.modelValue, updateTabsState);
    useResizeObserver([wrapper], updatePagination);
    useResizeObserver([container], updateTabsState);
    onMounted(() => {
      requestAnimationFrame(() => {
        includeAnimation();
      });
    });
    __expose({
      selectTab,
      moveToTab,
      movePaginationLeft,
      movePaginationRight
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["va-tabs", computedTabsClass.value])
      }, [
        createBaseVNode("div", {
          ref_key: "wrapper",
          ref: wrapper,
          class: "va-tabs__wrapper",
          role: "tablist",
          "aria-disabled": _ctx.$props.disabled
        }, [
          showPagination.value && !_ctx.$props.hidePagination ? (openBlock(), createBlock(unref(VaButton), {
            key: 0,
            class: "va-tabs__pagination",
            "aria-label": unref(tp)(_ctx.$props.ariaMoveLeftLabel),
            size: "medium",
            disabled: disablePaginationLeft.value,
            color: __props.color,
            preset: "secondary",
            icon: _ctx.$props.prevIcon,
            onClick: movePaginationLeft
          }, null, 8, ["aria-label", "disabled", "color", "icon"])) : createCommentVNode("", true),
          createBaseVNode("div", {
            ref_key: "container",
            ref: container,
            class: normalizeClass(["va-tabs__container", computedClass.value])
          }, [
            createBaseVNode("div", {
              ref_key: "tabs",
              ref: tabs,
              class: "va-tabs__tabs",
              style: normalizeStyle(paginationControlledStyles.value)
            }, [
              createBaseVNode("div", {
                class: "va-tabs__slider-wrapper",
                "aria-hidden": "true",
                style: normalizeStyle(sliderStyles.value)
              }, _hoisted_3$3, 4),
              createVNode(unref(_sfc_main$1W), { components: tabConfig }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_4$3, [
                    renderSlot(_ctx.$slots, "tabs")
                  ])
                ]),
                _: 3
              }, 8, ["components"])
            ], 4)
          ], 2),
          showPagination.value && !_ctx.$props.hidePagination ? (openBlock(), createBlock(unref(VaButton), {
            key: 1,
            class: "va-tabs__pagination",
            "aria-label": unref(tp)(_ctx.$props.ariaMoveRightLabel),
            size: "medium",
            color: __props.color,
            disabled: disablePaginationRight.value,
            preset: "secondary",
            icon: _ctx.$props.nextIcon,
            onClick: movePaginationRight
          }, null, 8, ["aria-label", "color", "disabled", "icon"])) : createCommentVNode("", true)
        ], 8, _hoisted_1$e),
        createBaseVNode("div", _hoisted_5$1, [
          renderSlot(_ctx.$slots, "default")
        ])
      ], 2);
    };
  }
});
const VaTabs = withConfigTransport$1(_sfc_main$n);
const _hoisted_1$d = { class: "va-tab__content" };
const _hoisted_2$4 = ["textContent"];
const _sfc_main$m = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaTab"
  },
  __name: "VaTab",
  props: {
    ...useRouterLinkProps,
    ...useComponentPresetProp,
    selected: { type: Boolean, default: false },
    color: { type: String, default: "" },
    icon: { type: String, default: "" },
    label: { type: String, default: "" },
    disabled: { type: Boolean },
    name: { type: [String, Number] },
    tag: { type: String, default: "div" }
  },
  emits: ["click", "keydown-enter", "focus"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const rootElement = shallowRef();
    const tabElement = computed(() => unwrapEl(rootElement.value));
    const isActive = ref(false);
    const hoverState = ref(false);
    const rightSidePosition = ref(0);
    const leftSidePosition = ref(0);
    const { keyboardFocusListeners, hasKeyboardFocus } = useKeyboardOnlyFocus();
    const { tagComputed, isActiveRouterLink, linkAttributesComputed } = useRouterLink(props);
    const classComputed = computed(() => ({ "va-tab--disabled": props.disabled }));
    const {
      parentDisabled,
      selectTab,
      moveToTab,
      registerTab,
      unregisterTab
    } = inject$1(TabsViewKey, {
      parentDisabled: false,
      tabsList: [],
      selectTab: (tab) => tab,
      moveToTab: (tab) => tab,
      registerTab: (tab) => tab,
      unregisterTab: (tab) => tab
    });
    const tabIndexComputed = computed(() => props.disabled || parentDisabled ? -1 : 0);
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    const computedStyle = computed(() => ({
      color: hoverState.value || isActive.value ? colorComputed.value : "inherit"
    }));
    const updateHoverState = (isHover) => {
      hoverState.value = isHover;
    };
    const updateSidePositions = () => {
      var _a2, _b;
      const componentOffsetLeft = ((_a2 = tabElement.value) == null ? void 0 : _a2.offsetLeft) || 0;
      const componentOffsetWidth = ((_b = tabElement.value) == null ? void 0 : _b.offsetWidth) || 0;
      rightSidePosition.value = componentOffsetLeft + componentOffsetWidth;
      leftSidePosition.value = componentOffsetLeft;
    };
    const width = useElementWidth(rootElement);
    watch(width, () => {
      updateSidePositions();
    });
    const onTabClick = async () => {
      await nextTick();
      selectTab(tabComponent);
      emit2("click");
    };
    const onTabKeydown = async () => {
      await nextTick();
      selectTab(tabComponent);
      emit2("keydown-enter");
    };
    const onFocus = () => {
      if (hasKeyboardFocus.value) {
        moveToTab(tabComponent);
      }
      emit2("focus");
    };
    const tabComponent = {
      name: computed(() => props.name),
      id: null,
      tabElement,
      isActive,
      tabIndexComputed,
      isActiveRouterLink,
      rightSidePosition,
      leftSidePosition,
      onTabClick,
      onTabKeydown,
      onFocus,
      updateSidePositions
    };
    onMounted(() => {
      registerTab(tabComponent);
    });
    onBeforeUnmount(() => {
      unregisterTab(tabComponent);
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(unref(tagComputed)), mergeProps$1({
        ref_key: "rootElement",
        ref: rootElement,
        class: ["va-tab", classComputed.value],
        role: "tab",
        "aria-selected": isActive.value,
        "aria-disabled": _ctx.$props.disabled || unref(parentDisabled),
        style: computedStyle.value,
        onMouseenter: _cache[0] || (_cache[0] = ($event) => updateHoverState(true)),
        onMouseleave: _cache[1] || (_cache[1] = ($event) => updateHoverState(false)),
        onFocus,
        onClick: onTabClick,
        onKeydown: withKeys(onTabKeydown, ["enter"]),
        tabindex: tabIndexComputed.value
      }, toHandlers(unref(keyboardFocusListeners)), unref(linkAttributesComputed)), {
        default: withCtx(() => [
          createBaseVNode("div", _hoisted_1$d, [
            renderSlot(_ctx.$slots, "default", {}, () => [
              __props.icon ? (openBlock(), createBlock(unref(VaIcon), {
                key: 0,
                class: "va-tab__icon",
                size: "small",
                name: __props.icon
              }, null, 8, ["name"])) : createCommentVNode("", true),
              createBaseVNode("span", {
                class: "va-tab__label",
                textContent: toDisplayString(__props.label)
              }, null, 8, _hoisted_2$4)
            ])
          ])
        ]),
        _: 3
      }, 16, ["aria-selected", "aria-disabled", "class", "style", "tabindex"]);
    };
  }
});
const VaTab = withConfigTransport$1(_sfc_main$m);
const unFunction = (fn, ...args) => {
  if (isFunction$2(fn)) {
    return fn(...args);
  }
  return fn;
};
const _hoisted_1$c = { class: "va-stepper__default-controls" };
const _sfc_main$l = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaStepperControls"
  },
  __name: "VaStepperControls",
  props: {
    modelValue: { type: [Number, String], required: true },
    steps: {
      type: Array,
      required: true
    },
    nextDisabled: { type: Boolean, required: true },
    stepControls: { type: Object, required: true },
    finishButtonHidden: { type: Boolean, default: false }
  },
  setup(__props) {
    const props = __props;
    const { t } = useTranslation();
    const isLoading = computed(() => {
      const currentStep = props.steps[Number(props.modelValue)];
      return unFunction(currentStep.isLoading) || false;
    });
    const isLastStep = computed(() => {
      const lastEnabledStepIndex = props.steps.length - 1;
      return Number(props.modelValue) >= lastEnabledStepIndex;
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$c, [
        createVNode(unref(VaButton), {
          preset: "primary",
          disabled: Number(_ctx.$props.modelValue) <= 0,
          loading: isLoading.value,
          onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$props.stepControls.prevStep())
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(unref(t)("back")), 1)
          ]),
          _: 1
        }, 8, ["disabled", "loading"]),
        !isLastStep.value ? (openBlock(), createBlock(unref(VaButton), {
          key: 0,
          onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$props.stepControls.nextStep()),
          disabled: _ctx.$props.nextDisabled,
          loading: isLoading.value
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(unref(t)("next")), 1)
          ]),
          _: 1
        }, 8, ["disabled", "loading"])) : !_ctx.$props.finishButtonHidden ? (openBlock(), createBlock(unref(VaButton), {
          key: 1,
          onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$props.stepControls.finish()),
          loading: isLoading.value
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(unref(t)("finish")), 1)
          ]),
          _: 1
        }, 8, ["loading"])) : createCommentVNode("", true)
      ]);
    };
  }
});
const isStepHasError = (step) => {
  return unFunction(step.hasError, step) || false;
};
const _hoisted_1$b = { class: "va-stepper__step-button__icon" };
const _sfc_main$k = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaStepperStepButton"
  },
  __name: "VaStepperStepButton",
  props: {
    modelValue: { type: Number, required: true },
    step: {
      type: Object,
      required: true
    },
    color: { type: String, required: true },
    stepIndex: { type: [Number, String], required: true },
    navigationDisabled: { type: Boolean, required: true },
    nextDisabled: { type: Boolean, required: true },
    focus: { type: Object, required: true },
    stepControls: { type: Object, required: true }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const stepElement = shallowRef();
    const hasError = computed(() => isStepHasError(props.step));
    const stepIndexComputed = useNumericProp("stepIndex");
    const displayError = computed(() => hasError.value && props.modelValue === stepIndexComputed.value);
    const isLoading = computed(() => unFunction(props.step.isLoading) || false);
    const { getColor } = useColors();
    const stepperColor = computed(() => getColor(hasError.value ? "danger" : props.color));
    const isNextStepDisabled = (index) => props.nextDisabled && index > props.modelValue;
    const { t } = useTranslation();
    const computedClass = useBem("va-stepper__step-button", () => ({
      active: props.modelValue >= stepIndexComputed.value,
      disabled: props.step.disabled || isNextStepDisabled(stepIndexComputed.value),
      "navigation-disabled": props.navigationDisabled,
      error: displayError.value
    }));
    watch(() => props.focus, () => {
      if (props.focus.trigger) {
        nextTick(() => {
          var _a2;
          return (_a2 = stepElement.value) == null ? void 0 : _a2.focus();
        });
      }
    }, { deep: true });
    const ariaAttributesComputed = computed(() => ({
      tabindex: props.focus.stepIndex === stepIndexComputed.value && !props.navigationDisabled ? 0 : void 0,
      "aria-disabled": props.step.disabled || isNextStepDisabled(stepIndexComputed.value) ? true : void 0,
      "aria-current": props.modelValue === props.stepIndex ? t("step") : void 0
    }));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("li", mergeProps$1({
        ref_key: "stepElement",
        ref: stepElement,
        class: ["va-stepper__step-button", unref(computedClass)],
        onClick: _cache[0] || (_cache[0] = ($event) => !_ctx.$props.navigationDisabled && _ctx.$props.stepControls.setStep(unref(stepIndexComputed))),
        onKeyup: [
          _cache[1] || (_cache[1] = withKeys(($event) => !_ctx.$props.navigationDisabled && _ctx.$props.stepControls.setStep(unref(stepIndexComputed)), ["enter"])),
          _cache[2] || (_cache[2] = withKeys(($event) => !_ctx.$props.navigationDisabled && _ctx.$props.stepControls.setStep(unref(stepIndexComputed)), ["space"]))
        ]
      }, ariaAttributesComputed.value, {
        style: `--va-stepper-color: ${String(stepperColor.value)}`
      }), [
        createBaseVNode("div", _hoisted_1$b, [
          isLoading.value ? (openBlock(), createBlock(unref(VaProgressCircle), {
            key: 0,
            color: "currentColor",
            indeterminate: "",
            size: "small"
          })) : __props.step.icon ? (openBlock(), createBlock(unref(VaIcon), {
            key: 1,
            name: __props.step.icon,
            size: "1.3rem"
          }, null, 8, ["name"])) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
            createTextVNode(toDisplayString(unref(stepIndexComputed) + 1), 1)
          ], 64))
        ]),
        createTextVNode(" " + toDisplayString(__props.step.label), 1)
      ], 16);
    };
  }
});
const _hoisted_1$a = { class: "va-stepper__step-content" };
const _hoisted_2$3 = { class: "va-stepper__controls" };
const _sfc_main$j = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaStepper"
  },
  __name: "VaStepper",
  props: {
    ...useStatefulProps,
    modelValue: { type: Number, default: 0 },
    steps: {
      type: Array,
      default: () => [],
      required: true
    },
    color: { type: String, default: "primary" },
    vertical: { type: Boolean, default: false },
    navigationDisabled: { type: Boolean, default: false },
    controlsHidden: { type: Boolean, default: false },
    nextDisabled: { type: Boolean, default: false },
    nextDisabledOnError: { type: Boolean, default: false },
    finishButtonHidden: { type: Boolean, default: false },
    ariaLabel: useTranslationProp("$t:progress"),
    linear: { type: Boolean, default: false },
    /** Hidden step shown when all steps complete */
    finishStep: { type: Object }
  },
  emits: ["update:modelValue", "finish", "update:steps"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const stepperNavigation = shallowRef();
    const { valueComputed: modelValue } = useStateful(props, emit2, "modelValue");
    const stepsComputed = computed(() => {
      if (!props.finishStep) {
        return props.steps;
      }
      return [...props.steps, props.finishStep];
    });
    const isFinishStep = (index) => {
      if (!props.finishStep) {
        return false;
      }
      return index === stepsComputed.value.length - 1;
    };
    const focusedStep = ref({ trigger: false, stepIndex: props.navigationDisabled ? -1 : props.modelValue });
    const { getColor } = useColors();
    const isNextStepDisabled = (index) => {
      if (props.nextDisabledOnError && isStepHasError(stepsComputed.value[index])) {
        return true;
      }
      return props.nextDisabled;
    };
    const findFirstNonDisabled = (from, direction) => {
      while (from >= 0 && from < stepsComputed.value.length) {
        from += direction;
        const step = stepsComputed.value[from];
        if (!step) {
          return;
        }
        if (!step.disabled) {
          return step;
        }
      }
    };
    const findFirstWithErrorIndex = (from, direction) => {
      while (from >= 0 && from < stepsComputed.value.length) {
        from += direction;
        const step = stepsComputed.value[from];
        if (!step) {
          return;
        }
        if (isStepHasError(step) === true) {
          return from;
        }
      }
    };
    const validateMovingToStep = async (stepIndex) => {
      var _a2;
      const newStep = stepsComputed.value[stepIndex];
      const currentStep = stepsComputed.value[modelValue.value];
      const beforeNewStep = findFirstNonDisabled(stepIndex, -1);
      if (newStep.disabled) {
        return false;
      }
      if (props.linear && stepIndex < modelValue.value) {
        return true;
      }
      const nextNonError = findFirstWithErrorIndex(modelValue.value, 1);
      if (props.linear && nextNonError !== void 0 && nextNonError < stepIndex) {
        return false;
      }
      let currentStepBeforeLeaveResult;
      try {
        currentStepBeforeLeaveResult = await ((_a2 = currentStep.beforeLeave) == null ? void 0 : _a2.call(currentStep, currentStep, newStep));
      } catch (e) {
        throw new Error(`Error in beforeLeave function: ${e}`);
      }
      if (currentStepBeforeLeaveResult === false) {
        return false;
      }
      if (currentStep.completed === void 0) {
        currentStep.completed = true;
      }
      if (props.linear && beforeNewStep && !beforeNewStep.completed) {
        return false;
      }
      if (props.linear && isStepHasError(currentStep)) {
        return false;
      }
      return true;
    };
    const setStep = async (index) => {
      if (!await validateMovingToStep(index)) {
        return;
      }
      modelValue.value = index;
    };
    const setFocus = (direction) => {
      if (props.navigationDisabled) {
        return;
      }
      if (direction === "next") {
        setFocusNextStep(1);
      } else {
        setFocusPrevStep(1);
      }
    };
    const setFocusNextStep = (idx = 1) => {
      const newValue = focusedStep.value.stepIndex + idx;
      if (isNextStepDisabled(newValue)) {
        return;
      }
      if (newValue < stepsComputed.value.length) {
        if (stepsComputed.value[newValue].disabled) {
          setFocusNextStep(idx + 1);
          return;
        }
        focusedStep.value.stepIndex = newValue;
        focusedStep.value.trigger = true;
      } else {
        for (let availableIdx = 0; availableIdx < stepsComputed.value.length; availableIdx++) {
          if (!stepsComputed.value[availableIdx].disabled) {
            focusedStep.value.stepIndex = availableIdx;
            focusedStep.value.trigger = true;
            break;
          }
        }
      }
    };
    const setFocusPrevStep = (idx = 1) => {
      const newValue = focusedStep.value.stepIndex - idx;
      if (newValue >= 0) {
        if (stepsComputed.value[newValue].disabled) {
          setFocusPrevStep(idx + 1);
          return;
        }
        focusedStep.value.stepIndex = newValue;
        focusedStep.value.trigger = true;
      } else {
        for (let availableIdx = stepsComputed.value.length - 1; availableIdx >= 0; availableIdx--) {
          if (!stepsComputed.value[availableIdx].disabled && !isNextStepDisabled(availableIdx)) {
            focusedStep.value.stepIndex = availableIdx;
            focusedStep.value.trigger = true;
            break;
          }
        }
      }
    };
    const resetFocus = () => {
      requestAnimationFrame(() => {
        var _a2;
        if (!((_a2 = stepperNavigation.value) == null ? void 0 : _a2.contains(document.activeElement))) {
          focusedStep.value.stepIndex = props.modelValue;
          focusedStep.value.trigger = false;
        }
      });
    };
    watch(() => props.modelValue, () => {
      focusedStep.value.stepIndex = props.modelValue;
      focusedStep.value.trigger = false;
    });
    const nextStep = (stepsToSkip = 0) => {
      const targetIndex = modelValue.value + 1 + stepsToSkip;
      if (!stepsComputed.value[targetIndex]) {
        return;
      }
      if (stepsComputed.value[targetIndex].disabled) {
        nextStep(stepsToSkip + 1);
      }
      setStep(targetIndex);
    };
    const prevStep = (stepsToSkip = 0) => {
      const targetIndex = modelValue.value - 1 - stepsToSkip;
      if (!stepsComputed.value[targetIndex]) {
        return;
      }
      if (stepsComputed.value[targetIndex].disabled) {
        prevStep(stepsToSkip + 1);
      }
      setStep(targetIndex);
    };
    const finish = async () => {
      if (await validateMovingToStep(props.steps.length - 1)) {
        emit2("finish");
      }
    };
    const stepControls = { setStep, nextStep, prevStep, finish };
    const getIterableSlotData = (step, index) => ({
      ...stepControls,
      focus: focusedStep,
      isActive: props.modelValue === index,
      isCompleted: props.modelValue > index,
      isLastStep: stepsComputed.value.length - 1 === index,
      isNextStepDisabled: isNextStepDisabled(index),
      isPrevStepDisabled: index === 0,
      index,
      step,
      hasError: isStepHasError(step)
    });
    const { tp } = useTranslation();
    const onValueChange = () => {
      focusedStep.value.stepIndex = props.modelValue;
      focusedStep.value.trigger = true;
    };
    const ariaAttributesComputed = computed(() => ({
      role: "group",
      "aria-label": tp(props.ariaLabel),
      "aria-orientation": props.vertical ? "vertical" : "horizontal"
    }));
    function getStepperButtonColor(index) {
      return isStepHasError(stepsComputed.value[index]) ? "danger" : getColor(props.color);
    }
    const completeStep = (shouldCompleteStep) => {
      const steps = { ...stepsComputed.value };
      if (shouldCompleteStep === true) {
        steps[props.modelValue].hasError = false;
      }
      steps[props.modelValue].completed = shouldCompleteStep ?? true;
      emit2("update:steps", steps);
    };
    const setError = (shouldSetError) => {
      const steps = { ...stepsComputed.value };
      steps[props.modelValue].hasError = shouldSetError ?? true;
      steps[props.modelValue].completed = !shouldSetError;
      emit2("update:steps", steps);
    };
    __expose({
      modelValue,
      focusedStep,
      getIterableSlotData,
      stepControls,
      nextStep,
      prevStep,
      setStep,
      setFocus,
      completeStep,
      setError
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", mergeProps$1({
        class: ["va-stepper", { "va-stepper--vertical": _ctx.$props.vertical }]
      }, ariaAttributesComputed.value), [
        createBaseVNode("ol", {
          class: normalizeClass(["va-stepper__navigation", { "va-stepper__navigation--vertical": _ctx.$props.vertical }]),
          ref_key: "stepperNavigation",
          ref: stepperNavigation,
          onClick: onValueChange,
          onKeyup: [
            withKeys(onValueChange, ["enter"]),
            withKeys(onValueChange, ["space"]),
            _cache[0] || (_cache[0] = withKeys(($event) => setFocus("prev"), ["left"])),
            _cache[1] || (_cache[1] = withKeys(($event) => setFocus("next"), ["right"]))
          ],
          onFocusout: resetFocus
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(stepsComputed.value, (step, i) => {
            return openBlock(), createElementBlock(Fragment, {
              key: i + step.label
            }, [
              !isFinishStep(i) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                i > 0 ? renderSlot(_ctx.$slots, "divider", normalizeProps$1(mergeProps$1({ key: 0 }, getIterableSlotData(step, i))), () => [
                  createBaseVNode("span", {
                    class: normalizeClass(["va-stepper__divider", { "va-stepper__divider--vertical": _ctx.$props.vertical }]),
                    "aria-hidden": "true"
                  }, null, 2)
                ]) : createCommentVNode("", true),
                renderSlot(_ctx.$slots, `step-button-${i}`, normalizeProps$1(guardReactiveProps(getIterableSlotData(step, i))), () => [
                  createVNode(_sfc_main$k, {
                    stepIndex: i,
                    color: getStepperButtonColor(i),
                    modelValue: unref(modelValue),
                    nextDisabled: __props.nextDisabled,
                    step,
                    stepControls,
                    navigationDisabled: __props.navigationDisabled,
                    focus: focusedStep.value
                  }, null, 8, ["stepIndex", "color", "modelValue", "nextDisabled", "step", "navigationDisabled", "focus"])
                ])
              ], 64)) : createCommentVNode("", true)
            ], 64);
          }), 128))
        ], 34),
        createBaseVNode("div", {
          class: normalizeClass(["va-stepper__step-content-wrapper", { "va-stepper__step-content-wrapper--vertical": _ctx.$props.vertical }])
        }, [
          createBaseVNode("div", _hoisted_1$a, [
            renderSlot(_ctx.$slots, `step-content-${isFinishStep(unref(modelValue)) ? "finish" : unref(modelValue)}`, normalizeProps$1(guardReactiveProps(getIterableSlotData(stepsComputed.value[unref(modelValue)], unref(modelValue)))))
          ]),
          createBaseVNode("div", _hoisted_2$3, [
            renderSlot(_ctx.$slots, "controls", normalizeProps$1(guardReactiveProps(getIterableSlotData(stepsComputed.value[unref(modelValue)], unref(modelValue)))), () => [
              !__props.controlsHidden ? (openBlock(), createBlock(_sfc_main$l, {
                key: 0,
                modelValue: unref(modelValue),
                nextDisabled: isNextStepDisabled(unref(modelValue)),
                steps: stepsComputed.value,
                stepControls,
                finishButtonHidden: __props.finishButtonHidden
              }, null, 8, ["modelValue", "nextDisabled", "steps", "finishButtonHidden"])) : createCommentVNode("", true)
            ])
          ])
        ], 2)
      ], 16);
    };
  }
});
const VaStepper = withConfigTransport$1(_sfc_main$j);
const parse = (text) => {
  const m = text.match(/[0-9]{1,2}/g);
  if (!m) {
    return [];
  }
  return m.map((s) => Number(s));
};
const parsePeriod = (text) => {
  const m = text.match(/pm|am/i);
  if (!m) {
    return null;
  }
  return Number(m[0].toLowerCase() === "pm");
};
const defaultParseDateFunction = (text) => {
  const d = /* @__PURE__ */ new Date();
  const [h2, m, s] = parse(text);
  const period = parsePeriod(text);
  if (!h2) {
    return null;
  }
  const is12format = period !== null && h2 <= 12;
  const isPM = is12format && !!period;
  const fh = is12format ? h2 === 12 ? 0 : h2 : h2;
  d.setHours(Math.min(fh || 0, is12format ? 12 : 24) + (isPM ? 12 : 0));
  d.setMinutes(Math.min(m || 0, 60));
  d.setSeconds(Math.min(s || 0, 60));
  return d;
};
const useTimeParser = (props) => {
  const getParseDateFn = () => props.parse || defaultParseDateFunction;
  const isValid = ref(true);
  const parseDate = (text) => {
    const parse3 = getParseDateFn();
    const result = parse3(text);
    if (!result) {
      isValid.value = false;
    }
    return result;
  };
  const parse2 = (text) => {
    isValid.value = true;
    return parseDate(text);
  };
  return {
    parse: parse2,
    isValid
  };
};
const useTimeFormatter = (props) => {
  const formatDate = (date) => {
    if (!date) {
      return "";
    }
    if (props.ampm) {
      return date.toLocaleTimeString("en-US");
    }
    return date.toLocaleTimeString("en-GB");
  };
  const sliceTime = (time, start, end) => time.split(":").slice(start, end).join(":");
  const formatWithView = (date) => {
    if (props.view === "seconds") {
      return formatDate(date);
    }
    const [time, period] = formatDate(date).split(" ");
    if (props.view === "minutes") {
      if (!period) {
        return sliceTime(time, 0, 2);
      }
      return [sliceTime(time, 0, 2), period].join(" ");
    }
    if (props.view === "hours") {
      if (!period) {
        return sliceTime(time, 0, 1);
      }
      return [sliceTime(time, 0, 1), period].join(" ");
    }
    return "";
  };
  return {
    format: (date) => props.format ? props.format(date) : formatWithView(date)
  };
};
const safeModelValue = (m) => m.value ? m.value : new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0));
const createNumbersArray = (length) => Array.from(Array(length).keys());
const from24to12 = (h2) => (h2 === 0 ? 12 : h2) - Number(h2 > 12) * 12;
const from12to24 = (h2, isAM = false) => (h2 === 12 ? 0 : h2) + Number(isAM) * 12;
const createHoursColumn = (props, modelValue, isPM) => {
  const computedSize = computed(() => props.ampm ? 12 : 24);
  const items2 = computed(() => {
    let array = createNumbersArray(computedSize.value);
    if (props.hoursFilter) {
      array = array.filter((i) => props.hoursFilter(props.ampm ? i + 12 * Number(isPM.value) : i));
    }
    return array.map((n) => {
      return props.ampm ? from24to12(n) : n;
    });
  });
  const activeItem = computed({
    get: () => {
      if (!modelValue.value) {
        return -1;
      }
      if (props.ampm) {
        const h22 = from24to12(modelValue.value.getHours() - 12 * Number(isPM.value));
        return items2.value.findIndex((i) => i === h22);
      }
      const h2 = modelValue.value.getHours();
      return items2.value.findIndex((i) => i === h2);
    },
    set: (newIndex) => {
      if (props.readonly) {
        return;
      }
      const hours = props.ampm ? from12to24(items2.value[newIndex], isPM.value) : items2.value[newIndex];
      modelValue.value = new Date(safeModelValue(modelValue).setHours(hours));
    }
  });
  return computed(() => ({
    items: items2.value,
    activeItem
  }));
};
const createMinutesColumn = (props, modelValue) => {
  const items2 = computed(() => {
    const array = createNumbersArray(60);
    if (!props.minutesFilter) {
      return array;
    }
    return array.filter(props.minutesFilter);
  });
  const activeItem = computed({
    get: () => {
      if (!modelValue.value) {
        return -1;
      }
      const m = modelValue.value.getMinutes();
      return items2.value.findIndex((i) => i === m);
    },
    set: (newIndex) => {
      if (props.readonly) {
        return;
      }
      const v = items2.value[newIndex];
      modelValue.value = new Date(safeModelValue(modelValue).setMinutes(v));
    }
  });
  return computed(() => ({
    items: items2.value,
    activeItem
  }));
};
const createSecondsColumn = (props, modelValue) => {
  const items2 = computed(() => {
    const array = createNumbersArray(60);
    if (!props.secondsFilter) {
      return array;
    }
    return array.filter(props.secondsFilter);
  });
  const activeItem = computed({
    get: () => {
      if (!modelValue.value) {
        return -1;
      }
      const s = modelValue.value.getSeconds();
      return items2.value.findIndex((i) => i === s);
    },
    set: (newIndex) => {
      if (props.readonly) {
        return;
      }
      const v = items2.value[newIndex];
      modelValue.value = new Date(safeModelValue(modelValue).setSeconds(v));
    }
  });
  return computed(() => ({
    items: items2.value,
    activeItem
  }));
};
const createPeriodColumn = (props, modelValue, isPM) => {
  return computed(() => ({
    items: ["AM", "PM"],
    activeItem: computed({
      get: () => {
        if (!modelValue.value) {
          return -1;
        }
        return Number(isPM.value);
      },
      set: (val) => {
        isPM.value = Boolean(val);
        const h2 = safeModelValue(modelValue).getHours();
        let h24 = isPM.value ? h2 + 12 : h2;
        if (isPM.value && h2 <= 12) {
          h24 = h2 + 12;
        }
        if (!isPM.value && h2 >= 12) {
          h24 = h2 - 12;
        }
        const isValidFilteredHour = !props.hoursFilter || props.hoursFilter(h24);
        if (props.periodUpdatesModelValue && isValidFilteredHour) {
          modelValue.value = new Date(safeModelValue(modelValue).setHours(h24));
        }
      }
    })
  }));
};
const useTimePicker = (props, modelValue) => {
  const { view } = toRefs(props);
  const isPM = ref(false);
  watch(modelValue, () => {
    isPM.value = safeModelValue(modelValue).getHours() >= 12;
  }, { immediate: true });
  const hoursColumn = createHoursColumn(props, modelValue, isPM);
  const minutesColumn = createMinutesColumn(props, modelValue);
  const secondsColumn = createSecondsColumn(props, modelValue);
  const periodColumn = createPeriodColumn(props, modelValue, isPM);
  const columns = computed(() => {
    const array = [];
    if (view.value === "hours") {
      array.push(hoursColumn.value);
    } else if (view.value === "minutes") {
      array.push(hoursColumn.value, minutesColumn.value);
    } else if (view.value === "seconds") {
      array.push(hoursColumn.value, minutesColumn.value, secondsColumn.value);
    }
    if (props.ampm && !props.hidePeriodSwitch) {
      array.push(periodColumn.value);
    }
    return array;
  });
  return {
    columns,
    isPM
  };
};
const _sfc_main$i = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaTimePickerColumnCell"
  },
  __name: "VaTimePickerColumnCell",
  setup(__props) {
    const { isHovered, onMouseEnter, onMouseLeave } = useHover();
    const { getTextColor, getColor } = useColors();
    const styleComputed = computed(() => isHovered.value ? {
      color: getColor(getTextColor(getColor("background-secondary"))),
      background: getColor("background-secondary")
    } : void 0);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        onMouseenter: _cache[0] || (_cache[0] = //@ts-ignore
        (...args) => unref(onMouseEnter) && unref(onMouseEnter)(...args)),
        onMouseleave: _cache[1] || (_cache[1] = //@ts-ignore
        (...args) => unref(onMouseLeave) && unref(onMouseLeave)(...args)),
        style: normalizeStyle(styleComputed.value)
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 36);
    };
  }
});
const _hoisted_1$9 = ["onClick"];
const _sfc_main$h = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaTimePickerColumn"
  },
  __name: "VaTimePickerColumn",
  props: {
    items: { type: Array, default: () => [] },
    activeItemIndex: { type: Number, default: 0 },
    cellHeight: { type: [Number, String], default: 30 }
  },
  emits: ["item-selected", "update:activeItemIndex", ...useFocusEmits],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const rootElement = shallowRef();
    const { focus, blur } = useFocus(rootElement, emit2);
    const [syncActiveItemIndex] = useSyncProp("activeItemIndex", props, emit2);
    const cellHeightComputed = useNumericProp("cellHeight");
    watch(syncActiveItemIndex, (newVal) => {
      scrollTo(newVal);
    });
    onMounted(() => scrollTo(syncActiveItemIndex.value, false));
    const scrollTo = (index, animated = true) => {
      nextTick(() => {
        var _a2, _b;
        (_b = (_a2 = rootElement.value) == null ? void 0 : _a2.scrollTo) == null ? void 0 : _b.call(_a2, {
          behavior: animated ? "smooth" : "auto",
          top: index * cellHeightComputed.value
        });
      });
    };
    const makeActiveNext = (times) => {
      syncActiveItemIndex.value = (syncActiveItemIndex.value + (times || 1)) % props.items.length;
      nextTick(() => scrollTo(syncActiveItemIndex.value));
    };
    const makeActivePrev = (times) => {
      syncActiveItemIndex.value = (syncActiveItemIndex.value - 1 + props.items.length) % props.items.length;
      nextTick(() => scrollTo(syncActiveItemIndex.value));
    };
    const onCellClick = (index) => {
      syncActiveItemIndex.value = index;
    };
    const formatCell = (n) => {
      if (!Number.isInteger(n)) {
        return n;
      }
      return Number(n) < 10 ? `0${n}` : `${n}`;
    };
    const getIndex = () => {
      const scrollTop = rootElement.value.scrollTop;
      const calculatedIndex = Math.max(
        (scrollTop - scrollTop % cellHeightComputed.value) / cellHeightComputed.value,
        scrollTop / cellHeightComputed.value
      );
      if (calculatedIndex >= props.items.length) {
        return props.items.length - 1;
      }
      if (calculatedIndex < 0) {
        return 0;
      }
      if (syncActiveItemIndex.value * cellHeightComputed.value < scrollTop) {
        return Math.ceil(calculatedIndex);
      } else if (syncActiveItemIndex.value * cellHeightComputed.value > scrollTop) {
        return Math.floor(calculatedIndex);
      } else {
        return Math.round(calculatedIndex);
      }
    };
    const onScroll = debounce(() => {
      if (rootElement.value && syncActiveItemIndex.value !== -1) {
        syncActiveItemIndex.value = getIndex();
      }
    }, 200);
    __expose({
      focus,
      blur
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "rootElement",
        ref: rootElement,
        tabindex: "0",
        class: "va-time-picker-column",
        onKeydown: [
          _cache[0] || (_cache[0] = withKeys(withModifiers(($event) => makeActiveNext(), ["stop", "prevent"]), ["down"])),
          _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => makeActiveNext(5), ["stop", "prevent"]), ["space"])),
          _cache[2] || (_cache[2] = withKeys(withModifiers(($event) => makeActivePrev(), ["stop", "prevent"]), ["up"]))
        ]
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(__props.items, (item, index) => {
          return openBlock(), createBlock(_sfc_main$i, {
            key: item,
            onScrollPassive: unref(onScroll),
            onTouchmovePassive: unref(onScroll),
            onMousewheelPassive: unref(onScroll)
          }, {
            default: withCtx(() => [
              createBaseVNode("div", {
                class: normalizeClass(["va-time-picker-cell", { "va-time-picker-cell--active": index === _ctx.$props.activeItemIndex }]),
                onClick: ($event) => onCellClick(index)
              }, [
                renderSlot(_ctx.$slots, "cell", normalizeProps$1(guardReactiveProps({ item, index, activeItemIndex: __props.activeItemIndex, items: __props.items, formattedItem: formatCell(item) })), () => [
                  createTextVNode(toDisplayString(formatCell(item)), 1)
                ])
              ], 10, _hoisted_1$9)
            ]),
            _: 2
          }, 1032, ["onScrollPassive", "onTouchmovePassive", "onMousewheelPassive"]);
        }), 128))
      ], 544);
    };
  }
});
const VaTimePickerColumn = withConfigTransport$1(_sfc_main$h);
const useCSSVariables = (prefix2, cb) => {
  return computed(() => Object.entries(cb()).reduce((acc, [key, value]) => {
    acc[`--${prefix2}-${camelCaseToKebabCase(key)}`] = value;
    return acc;
  }, {}));
};
const _sfc_main$g = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaTimePicker"
  },
  __name: "VaTimePicker",
  props: {
    ...useStatefulProps,
    ...useFormFieldProps,
    ...useComponentPresetProp,
    modelValue: { type: Date, required: false },
    ampm: { type: Boolean, default: false },
    hidePeriodSwitch: { type: Boolean, default: false },
    periodUpdatesModelValue: { type: Boolean, default: true },
    // Update model value when switching period automatically
    view: { type: String, default: "minutes" },
    hoursFilter: { type: Function },
    minutesFilter: { type: Function },
    secondsFilter: { type: Function },
    framed: { type: Boolean, default: false },
    cellHeight: { type: [Number, String], default: 30 },
    visibleCellsCount: { type: [Number, String], default: 7 }
  },
  emits: [...useStatefulEmits],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const { valueComputed } = useStateful(props, emit2);
    const { columns } = useTimePicker(props, valueComputed);
    const cellHeightComputed = useNumericProp("cellHeight");
    const visibleCellsCountComputed = useNumericProp("visibleCellsCount");
    const { setItemRef, itemRefs: pickers } = useArrayRefs();
    const activeColumnIndex = ref();
    const focus = (idx = 0) => {
      var _a2;
      (_a2 = pickers.value[idx]) == null ? void 0 : _a2.focus();
    };
    const blur = (idx) => {
      var _a2;
      idx ? (_a2 = pickers.value[idx]) == null ? void 0 : _a2.blur() : pickers.value.forEach((el) => el == null ? void 0 : el.blur());
    };
    const { computedClasses: computedFormClasses } = useFormField("va-time-picker", props);
    const focusNext = () => {
      const nextIndex = ((activeColumnIndex == null ? void 0 : activeColumnIndex.value) || 0) + 1;
      activeColumnIndex.value = nextIndex % columns.value.length;
      focus(activeColumnIndex.value);
    };
    const focusPrev = () => {
      const nextIndex = ((activeColumnIndex == null ? void 0 : activeColumnIndex.value) || 0) - 1 + columns.value.length;
      activeColumnIndex.value = nextIndex % columns.value.length;
      focus(activeColumnIndex.value);
    };
    const computedClasses = computed(() => ({
      ...computedFormClasses,
      "va-time-picker--framed": props.framed
    }));
    const computedStyles = useCSSVariables("va-time-picker", () => {
      const gapHeight = (visibleCellsCountComputed.value - 1) / 2 * cellHeightComputed.value;
      return {
        height: `${cellHeightComputed.value * visibleCellsCountComputed.value}px`,
        "cell-height": `${cellHeightComputed.value}px`,
        "column-gap-height": `${gapHeight}px`
      };
    });
    __expose({
      focus,
      blur,
      focusNext,
      focusPrev
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["va-time-picker", computedClasses.value]),
        style: normalizeStyle(unref(computedStyles))
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(columns), (column, idx) => {
          return openBlock(), createBlock(unref(VaTimePickerColumn), {
            key: idx,
            ref_for: true,
            ref: unref(setItemRef),
            items: column.items,
            tabindex: _ctx.disabled ? -1 : 0,
            "cell-height": unref(cellHeightComputed),
            activeItemIndex: column.activeItem.value,
            "onUpdate:activeItemIndex": ($event) => column.activeItem.value = $event,
            onKeydown: [
              _cache[0] || (_cache[0] = withKeys(withModifiers(($event) => focusNext(), ["stop", "prevent"]), ["right"])),
              _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => focusNext(), ["exact", "stop", "prevent"]), ["tab"])),
              _cache[2] || (_cache[2] = withKeys(withModifiers(($event) => focusPrev(), ["stop", "prevent"]), ["left"])),
              _cache[3] || (_cache[3] = withKeys(withModifiers(($event) => focusPrev(), ["shift", "stop", "prevent"]), ["tab"]))
            ],
            onFocus: ($event) => activeColumnIndex.value = idx
          }, null, 8, ["items", "tabindex", "cell-height", "activeItemIndex", "onUpdate:activeItemIndex", "onFocus"]);
        }), 128))
      ], 6);
    };
  }
});
function useLongPressKey(el, options) {
  let timeoutId = -1;
  let intervalId = -1;
  const handleMouseDown = (e) => {
    var _a2;
    (_a2 = options.onStart) == null ? void 0 : _a2.call(options, e);
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      intervalId = setInterval(() => {
        var _a22;
        return (_a22 = options.onUpdate) == null ? void 0 : _a22.call(options, e);
      }, options.interval || 100);
    }, unref(options.delay) || 500);
  };
  const handleMouseUp = (e) => {
    var _a2;
    clearTimeout(timeoutId);
    clearInterval(intervalId);
    (_a2 = options.onEnd) == null ? void 0 : _a2.call(options, e);
  };
  const htmlElement = useHTMLElement(el);
  useEvent(["keydown"], handleMouseDown, htmlElement);
  useEvent([
    "keyup",
    "blur"
  ], handleMouseUp, true);
}
const VaInputWrapperProps$1 = extractComponentProps(VaInputWrapper, ["focused", "maxLength", "counterValue"]);
const _sfc_main$f = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaTimeInput",
    inheritAttrs: false
  },
  __name: "VaTimeInput",
  props: {
    ...VaInputWrapperProps$1,
    ...useDropdownableProps,
    ...useComponentPresetProp,
    ...useClearableProps,
    ...extractComponentProps(_sfc_main$g),
    ...useValidationProps,
    ...useStatefulProps,
    closeOnContentClick: { type: Boolean, default: false },
    offset: { ...useDropdownableProps.offset, default: () => [2, 0] },
    placement: { ...useDropdownableProps.placement, default: "bottom-end" },
    modelValue: { type: Date, default: void 0 },
    clearValue: { type: Date, default: null },
    format: { type: Function },
    parse: { type: Function },
    manualInput: { type: Boolean, default: false },
    leftIcon: { type: Boolean, default: false },
    icon: { type: String, default: "schedule" },
    ariaLabel: useTranslationProp("$t:selectedTime"),
    ariaResetLabel: useTranslationProp("$t:resetTime"),
    ariaToggleDropdownLabel: useTranslationProp("$t:toggleDropdown")
  },
  emits: [
    ...useFocusEmits,
    ...useValidationEmits,
    ...useClearableEmits,
    ...useStatefulEmits,
    ...useDropdownableEmits,
    "update:modelValue"
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const input = shallowRef();
    const timePicker = shallowRef();
    const { isOpenSync, dropdownProps } = useDropdownable(props, emit2, {
      defaultCloseOnValueUpdate: computed(() => Array.isArray(props.view) && props.view.length === 1)
    });
    const { valueComputed } = useStateful(props, emit2);
    const { parse: parse2, isValid } = useTimeParser(props);
    const { format } = useTimeFormatter(props);
    const valueText = computed(() => format(valueComputed.value || props.clearValue));
    const doShowDropdown = computed({
      get() {
        if (props.disabled || props.readonly) {
          return false;
        }
        return isOpenSync.value;
      },
      set(v) {
        isOpenSync.value = v;
        if (v) {
          nextTick(() => {
            var _a2;
            return (_a2 = timePicker.value) == null ? void 0 : _a2.focus();
          });
        } else {
          nextTick(() => {
            var _a2;
            return (_a2 = input.value) == null ? void 0 : _a2.focus();
          });
        }
      }
    });
    const { isFocused, focus, blur, onFocus: focusListener, onBlur: blurListener } = useFocus(input);
    const onInputTextChanged = (e) => {
      var _a2;
      if (props.disabled) {
        return;
      }
      const val = (_a2 = e.target) == null ? void 0 : _a2.value;
      if (!val) {
        return reset();
      }
      const v = parse2(val);
      if (isValid.value && v) {
        valueComputed.value = v;
      } else {
        valueComputed.value = void 0;
        isValid.value = true;
      }
    };
    const reset = () => withoutValidation(() => {
      emit2("update:modelValue", props.clearValue);
      emit2("clear");
      resetValidation();
      hideDropdown();
    });
    const {
      computedError,
      computedErrorMessages,
      listeners,
      validationAriaAttributes,
      withoutValidation,
      resetValidation,
      isDirty: isDirty2,
      isTouched
    } = useValidation(props, emit2, { reset, focus, value: valueComputed });
    watch(doShowDropdown, (v) => {
      if (!v) {
        isTouched.value = true;
      }
    });
    const {
      canBeCleared,
      clearIconProps,
      onFocus,
      onBlur
    } = useClearable(props, valueText);
    const canBeClearedComputed = computed(() => canBeCleared.value && valueText.value !== format(props.clearValue));
    const filteredWrapperProps = filterComponentProps(VaInputWrapperProps$1);
    const computedInputWrapperProps = computed(() => ({
      ...filteredWrapperProps.value,
      focused: isFocused.value,
      error: computedError.value,
      errorMessages: computedErrorMessages.value,
      readonly: props.readonly || !props.manualInput,
      modelValue: valueText.value
    }));
    const viewToNumber = {
      seconds: 1e3,
      minutes: 1e3 * 60,
      hours: 1e3 * 60 * 60
    };
    const onKeyPress = (e) => {
      if (!("key" in e)) {
        return;
      }
      if (e.key === "ArrowDown") {
        valueComputed.value = new Date(Number(valueComputed.value) - viewToNumber[props.view]);
        e.preventDefault();
      }
      if (e.key === "ArrowUp") {
        valueComputed.value = new Date(Number(valueComputed.value) + viewToNumber[props.view]);
        e.preventDefault();
      }
    };
    useLongPressKey(input, {
      onStart: onKeyPress,
      onUpdate: onKeyPress
    });
    const computedInputListeners = {
      onFocus: () => {
        if (props.disabled) {
          return;
        }
        focusListener();
        if (props.readonly) {
          return;
        }
        onFocus();
      },
      onBlur: () => {
        if (props.disabled) {
          return;
        }
        blurListener();
        if (props.readonly) {
          return;
        }
        onBlur();
        listeners.onBlur();
      }
    };
    const slots = useSlots();
    const filteredSlots = computed(() => {
      const slotsWithIcons = [
        props.leftIcon && "prependInner",
        (!props.leftIcon || props.clearable) && "icon"
      ];
      return Object.keys(slots).filter((slot) => !slotsWithIcons.includes(slot));
    });
    const hideDropdown = () => {
      doShowDropdown.value = false;
    };
    const showDropdown = (event, cancel, prevent) => {
      doShowDropdown.value = true;
    };
    const checkProhibitedDropdownOpening = (e) => {
      if (isOpenSync.value) {
        return false;
      }
      if (props.disabled || props.readonly) {
        return true;
      }
      if (e === void 0) {
        return false;
      }
      return props.manualInput && (e == null ? void 0 : e.code) !== "Space";
    };
    const toggleDropdown = (event) => {
      if (checkProhibitedDropdownOpening(event instanceof KeyboardEvent ? event : void 0)) {
        return;
      }
      doShowDropdown.value = !doShowDropdown.value;
    };
    const cursorStyleComputed = computed(() => {
      if (props.disabled) {
        return {};
      }
      if (props.manualInput) {
        return { cursor: "text" };
      }
      return { cursor: "pointer" };
    });
    const iconTabindexComputed = computed(() => {
      if (!props.manualInput) {
        return -1;
      }
      return props.disabled || props.readonly ? -1 : 0;
    });
    const iconProps = computed(() => ({
      role: "button",
      "aria-hidden": false,
      name: props.icon,
      color: "secondary",
      tabindex: iconTabindexComputed.value
    }));
    const { tp } = useTranslation();
    useAttrs();
    const dropdownPropsComputed = computed(() => ({
      ...dropdownProps.value,
      innerAnchorSelector: ".va-input-wrapper__field",
      trigger: ["click", "right-click", "space", "enter"]
    }));
    const timePickerProps = filterComponentProps(extractComponentProps(_sfc_main$g));
    __expose({
      isFocused,
      isValid,
      value: valueComputed,
      isDirty: isDirty2,
      isTouched,
      focus,
      blur,
      reset,
      withoutValidation,
      resetValidation,
      toggleDropdown,
      showDropdown,
      hideDropdown
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaDropdown), mergeProps$1({
        modelValue: doShowDropdown.value,
        "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => doShowDropdown.value = $event),
        class: ["va-time-input", _ctx.$attrs.class],
        style: _ctx.$attrs.style
      }, dropdownPropsComputed.value), {
        anchor: withCtx(() => [
          createVNode(unref(VaInputWrapper), mergeProps$1({
            class: "va-time-input__anchor",
            ref_key: "input",
            ref: input,
            style: cursorStyleComputed.value
          }, { ...computedInputWrapperProps.value, ...unref(validationAriaAttributes), ...computedInputListeners }, { onChange: onInputTextChanged }), createSlots$1({
            icon: withCtx(() => [
              canBeClearedComputed.value ? (openBlock(), createBlock(unref(VaIcon), mergeProps$1({
                key: 0,
                class: "va-time-input__clear-button"
              }, { ...iconProps.value, ...unref(clearIconProps) }, {
                "aria-label": unref(tp)(_ctx.$props.ariaResetLabel),
                onClick: withModifiers(reset, ["stop"]),
                onKeydown: [
                  withKeys(withModifiers(reset, ["stop"]), ["enter"]),
                  withKeys(withModifiers(reset, ["stop"]), ["space"])
                ]
              }), null, 16, ["aria-label", "onKeydown"])) : createCommentVNode("", true),
              !_ctx.$props.leftIcon && _ctx.$props.icon ? (openBlock(), createBlock(unref(VaIcon), mergeProps$1({
                key: 1,
                class: "va-time-input__right-button va-time-input__side-button",
                "aria-label": unref(tp)(_ctx.$props.ariaToggleDropdownLabel)
              }, iconProps.value), null, 16, ["aria-label"])) : createCommentVNode("", true)
            ]),
            _: 2
          }, [
            renderList(filteredSlots.value, (name) => {
              return {
                name,
                fn: withCtx((slotScope) => [
                  renderSlot(_ctx.$slots, name, normalizeProps$1(guardReactiveProps({ ...slotScope, toggleDropdown, showDropdown, hideDropdown, isOpen: unref(isOpenSync), focus: unref(focus) })))
                ])
              };
            }),
            _ctx.$slots.prependInner || _ctx.$props.leftIcon ? {
              name: "prependInner",
              fn: withCtx((slotScope) => [
                renderSlot(_ctx.$slots, "prependInner", normalizeProps$1(guardReactiveProps({ ...slotScope, toggleDropdown, showDropdown, hideDropdown, isOpen: unref(isOpenSync), focus: unref(focus) }))),
                _ctx.$props.leftIcon ? (openBlock(), createBlock(unref(VaIcon), mergeProps$1({
                  key: 0,
                  class: "va-time-input__left-button va-time-input__side-button",
                  "aria-label": unref(tp)(_ctx.$props.ariaToggleDropdownLabel)
                }, iconProps.value), null, 16, ["aria-label"])) : createCommentVNode("", true)
              ]),
              key: "0"
            } : void 0
          ]), 1040, ["style"])
        ]),
        default: withCtx(() => [
          createVNode(unref(VaDropdownContent), {
            "no-padding": "",
            onKeydown: [
              withKeys(withModifiers(hideDropdown, ["prevent"]), ["esc"]),
              withKeys(withModifiers(hideDropdown, ["prevent"]), ["enter"])
            ]
          }, {
            default: withCtx(() => [
              createVNode(_sfc_main$g, mergeProps$1({
                ref_key: "timePicker",
                ref: timePicker
              }, unref(timePickerProps), {
                modelValue: unref(valueComputed),
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(valueComputed) ? valueComputed.value = $event : null)
              }), null, 16, ["modelValue"])
            ]),
            _: 1
          }, 8, ["onKeydown"])
        ]),
        _: 3
      }, 16, ["modelValue", "class", "style"]);
    };
  }
});
const VaTimeInput = withConfigTransport$1(_sfc_main$f);
const getPropsData = (slot) => slot == null ? void 0 : slot.props;
const getIsActive = (slot) => {
  var _a2;
  return !!((_a2 = slot == null ? void 0 : slot.props) == null ? void 0 : _a2.active) || false;
};
const isVueFragment = (slot) => slot.type === Fragment;
const isEmptyArray = (arr) => arr && arr.length === 0;
function getSlots(slots) {
  var _a2;
  const defaultSlots = (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
  if (!defaultSlots || isEmptyArray(defaultSlots)) {
    return [];
  }
  if (isVueFragment(defaultSlots[0])) {
    return defaultSlots[0].children;
  }
  return defaultSlots;
}
const processSlots = (context) => {
  const slots = getSlots(context.slots);
  slots.forEach((slot, index) => {
    if (!getPropsData(slot)) {
      slot.props = {};
    }
    const propsData = getPropsData(slot);
    propsData.vertical = context.props.vertical;
    if (context.props.centered) {
      propsData.inverted = !!(index % 2);
    }
    if (index === 0) {
      propsData.isFirst = true;
    }
    if (index === slots.length - 1) {
      propsData.isLast = true;
    }
    const currentSlotActive = propsData.active;
    if (!currentSlotActive) {
      return;
    }
    if (index === 0) {
      propsData.activePrevious = currentSlotActive;
    }
    if (index === slots.length - 1) {
      propsData.activeNext = currentSlotActive;
    }
    const previousSlotActive = getIsActive(slots[index - 1]);
    if (previousSlotActive) {
      propsData.activePrevious = true;
    }
    const nextSlotActive = getIsActive(slots[index + 1]);
    if (nextSlotActive) {
      propsData.activeNext = true;
    }
  });
  return slots;
};
const COMPONENT_NAME$1 = "va-timeline";
const _sfc_main$e = {
  name: COMPONENT_NAME$1,
  props: {
    ...useComponentPresetProp,
    vertical: { type: Boolean },
    centered: { type: Boolean },
    alignTop: { type: Boolean }
  },
  setup(props, { slots }) {
    return () => h(
      "div",
      {
        class: {
          [COMPONENT_NAME$1]: true,
          [`${COMPONENT_NAME$1}--vertical`]: props.vertical,
          [`${COMPONENT_NAME$1}--align-top`]: props.alignTop
        }
      },
      processSlots({ props, slots })
    );
  }
};
const VaTimeline = withConfigTransport$1(_sfc_main$e);
const componentName = "va-timeline-separator";
const _sfc_main$d = /* @__PURE__ */ defineComponent({
  name: componentName,
  props: {
    ...useComponentPresetProp,
    color: { type: String, default: "primary" },
    vertical: { type: Boolean },
    active: { type: Boolean },
    activePrevious: { type: Boolean },
    activeNext: { type: Boolean }
  },
  setup(props) {
    const { getColor } = useColors();
    return () => h(
      "div",
      {
        class: {
          [componentName]: true,
          [`${componentName}--vertical`]: props.vertical
        }
      },
      [
        h("div", {
          class: {
            [`${componentName}__line`]: true,
            [`${componentName}__line--active`]: props.activePrevious
          },
          style: {
            backgroundColor: getColor(props.activePrevious ? props.color : "divider")
          }
        }),
        h("div", {
          class: {
            [`${componentName}__center`]: true,
            [`${componentName}__center--active`]: props.active
          },
          style: {
            backgroundColor: getColor(props.active ? props.color : "divider")
          }
        }),
        h("div", {
          class: {
            [`${componentName}__line`]: true,
            [`${componentName}__line--active`]: props.activeNext
          },
          style: {
            backgroundColor: getColor(props.activeNext ? props.color : "divider")
          }
        })
      ]
    );
  }
});
const VaTimelineSeparator = withConfigTransport$1(_sfc_main$d);
const COMPONENT_NAME = "va-timeline-item";
const VaTimelineSeparatorProps = extractComponentProps(VaTimelineSeparator);
const _sfc_main$c = /* @__PURE__ */ defineComponent({
  name: COMPONENT_NAME,
  props: {
    ...useComponentPresetProp,
    ...VaTimelineSeparatorProps,
    color: { type: String, default: "primary" },
    isFirst: { type: Boolean },
    isLast: { type: Boolean },
    inverted: { type: Boolean }
  },
  setup(props, { slots }) {
    const children = [
      h(
        VaTimelineSeparator,
        { ...filterComponentProps(VaTimelineSeparatorProps).value }
      )
    ];
    const before = props.inverted ? slots.after : slots.before;
    if (before) {
      children.unshift(
        h(
          "div",
          { class: `${COMPONENT_NAME}__before` },
          before()
        )
      );
    }
    const after = props.inverted ? slots.before : slots.after;
    if (after) {
      children.push(
        h(
          "div",
          { class: `${COMPONENT_NAME}__after` },
          after()
        )
      );
    }
    return () => h(
      "div",
      {
        class: [
          { [COMPONENT_NAME]: true },
          { [`${COMPONENT_NAME}--vertical`]: props.vertical },
          { [`${COMPONENT_NAME}--is-first`]: props.isFirst },
          { [`${COMPONENT_NAME}--is-last`]: props.isLast }
        ]
      },
      children
    );
  }
});
const VaTimelineItem = withConfigTransport$1(_sfc_main$c);
const VaTimePicker = withConfigTransport$1(_sfc_main$g);
const useTreeViewProps = {
  nodes: {
    type: Array,
    default: []
  },
  stateful: {
    type: Boolean,
    default: true
  },
  selectable: {
    type: Boolean,
    default: false
  },
  selectionType: {
    type: String,
    default: "leaf",
    validator: (v) => ["leaf", "independent"].includes(v)
  },
  valueBy: {
    type: [String, Function],
    default: "id"
  },
  textBy: {
    type: [String, Function],
    default: "label"
  },
  trackBy: {
    type: [String, Function],
    default: "id"
  },
  iconBy: {
    type: [String, Function],
    default: "icon"
  },
  disabledBy: {
    type: [String, Function],
    default: "disabled"
  },
  expandedBy: {
    type: [String, Function],
    default: "expanded"
  },
  checkedBy: {
    type: [String, Function],
    default: "checked"
  },
  childrenBy: {
    type: [String, Function],
    default: "children"
  },
  expandAll: {
    type: Boolean,
    default: false
  },
  expanded: {
    type: Array,
    default: []
  },
  expandNodeBy: {
    type: String,
    default: "leaf"
  },
  filter: {
    type: String,
    default: ""
  },
  filterMethod: {
    type: Function,
    default: void 0
  },
  checked: {
    type: Array,
    default: []
  },
  color: {
    type: String,
    default: "primary"
  }
};
const useTreeViewEmits = ["update:modelValue", "update:checked", "update:expanded", "update:selected"];
const useTreeHelpers = (props) => {
  const isStringOrNumber = (node) => {
    const typeOfNode = typeof node;
    return typeOfNode === "string" || typeOfNode === "number";
  };
  const getNodeProperty = (node, key) => !key || isStringOrNumber(node) ? node : getValueByKey(node, key);
  const getValue2 = (node) => getNodeProperty(node, props.valueBy);
  const getNodeByValue = (value) => {
    if (!props.valueBy) {
      return value;
    }
    return props.nodes.find((node) => value === getValue2(node)) || value;
  };
  const getText = (node) => getNodeProperty(node, props.textBy);
  const getChecked = (node) => getNodeProperty(node, props.checkedBy);
  const getDisabled = (node) => getNodeProperty(node, props.disabledBy);
  const getExpanded = (node) => getNodeProperty(node, props.expandedBy);
  const getTrackBy = (node) => getNodeProperty(node, props.trackBy);
  const getChildren = (node) => getNodeProperty(node, props.childrenBy) ?? [];
  const iterateNodes = (nodes, cb) => {
    nodes.forEach((node) => {
      const children = node.children || [];
      if (children.length) {
        iterateNodes(children, cb);
      }
      cb(node);
    });
  };
  return {
    getText,
    getValue: getValue2,
    getChecked,
    getTrackBy,
    getChildren,
    getDisabled,
    getExpanded,
    iterateNodes,
    getNodeByValue,
    getNodeProperty
  };
};
const TreeViewKey = Symbol("TreeView");
const useTreeKeyboardNavigation = (props, methods) => {
  const { emit: emit2, toggleNode, toggleCheckbox } = methods;
  const isElementExpanded = (currentElement) => (currentElement == null ? void 0 : currentElement.getAttribute("aria-expanded")) === "true";
  const getParentElement = (currentElement) => {
    var _a2;
    return ((_a2 = currentElement == null ? void 0 : currentElement.parentElement) == null ? void 0 : _a2.closest(".va-tree-node")) || null;
  };
  const getPreviousElement = (currentElement) => currentElement == null ? void 0 : currentElement.previousElementSibling;
  const findPreviousElement = (currentElement) => {
    if (!currentElement) {
      return null;
    }
    let previousElement = getPreviousElement(currentElement);
    let lastChildElement = isElementExpanded(previousElement) && getLastChildElement(previousElement);
    if (lastChildElement) {
      do {
        if (isElementExpanded(lastChildElement)) {
          lastChildElement = getLastChildElement(lastChildElement);
          if (lastChildElement) {
            continue;
          } else {
            break;
          }
        } else {
          previousElement = lastChildElement;
          break;
        }
      } while (true);
    }
    if (!previousElement) {
      return getParentElement(currentElement);
    }
    return previousElement;
  };
  const getNextElement = (currentElement) => currentElement == null ? void 0 : currentElement.nextElementSibling;
  const findNextElement = (currentElement) => {
    if (!currentElement) {
      return null;
    }
    let nextElement = getNextElement(currentElement);
    const isCurrentExpanded = isElementExpanded(currentElement);
    if (!nextElement) {
      let parentElement = getParentElement(currentElement);
      do {
        if (!getNextElement(parentElement)) {
          parentElement = getParentElement(parentElement);
          if (!parentElement) {
            break;
          } else {
            continue;
          }
        } else {
          nextElement = getNextElement(parentElement);
          break;
        }
      } while (true);
    }
    if (isCurrentExpanded) {
      return getFirstChildElement(currentElement);
    }
    return nextElement;
  };
  const getFirstChildElement = (currentElement) => {
    var _a2;
    return ((_a2 = currentElement == null ? void 0 : currentElement.querySelector(".va-tree-node-children")) == null ? void 0 : _a2.firstElementChild) || null;
  };
  const getLastChildElement = (currentElement) => {
    var _a2;
    return ((_a2 = currentElement == null ? void 0 : currentElement.querySelector(".va-tree-node-children")) == null ? void 0 : _a2.lastElementChild) || null;
  };
  const onHorizontalMove = (currentElement, dir, node) => {
    var _a2, _b;
    const isCurrentElementExpanded = isElementExpanded(currentElement);
    if (dir === "left") {
      if (isCurrentElementExpanded) {
        toggleNode(node);
      } else {
        (_a2 = getParentElement(currentElement)) == null ? void 0 : _a2.focus();
      }
    } else {
      if (!isCurrentElementExpanded) {
        toggleNode(node);
      } else {
        (_b = getFirstChildElement(currentElement)) == null ? void 0 : _b.focus();
      }
    }
  };
  const onVerticalMove = (currentElement, dir) => {
    var _a2, _b;
    if (dir === "up") {
      (_a2 = findPreviousElement(currentElement)) == null ? void 0 : _a2.focus();
    } else {
      (_b = findNextElement(currentElement)) == null ? void 0 : _b.focus();
    }
  };
  const handleKeyboardNavigation = (event, node) => {
    const currentElement = event.target;
    switch (event.code) {
      case "ArrowUp":
        onVerticalMove(currentElement, "up");
        break;
      case "ArrowRight":
        onHorizontalMove(currentElement, "right", node);
        break;
      case "ArrowDown":
        onVerticalMove(currentElement, "down");
        break;
      case "ArrowLeft":
        onHorizontalMove(currentElement, "left", node);
        break;
      case "Space":
        if (props.selectable) {
          const state = typeof node.checked !== "undefined" ? !node.checked : null;
          toggleCheckbox(node, state);
        } else {
          emit2("update:selected", node);
        }
        break;
      case "Escape":
        if (!props.selectable) {
          emit2("update:selected", null);
        }
        currentElement.blur();
        break;
      default:
        currentElement.blur();
    }
  };
  return { handleKeyboardNavigation };
};
const useTreeKeyboardNavigation$1 = useTreeKeyboardNavigation;
const useTreeView = (props, emit2) => {
  const { getColor } = useColors();
  const colorComputed = computed(() => getColor(props.color));
  const isLeafSelectionComputed = computed(() => props.selectionType === "leaf");
  const {
    getText,
    getValue: getValue2,
    getChecked,
    getTrackBy,
    getChildren,
    getDisabled,
    getExpanded,
    iterateNodes,
    getNodeProperty
  } = useTreeHelpers(props);
  const { nodes, expandAll, filter, filterMethod, textBy } = toRefs(props);
  const { valueComputed: expandedList } = useStateful(props, emit2, "expanded");
  const { valueComputed: checkedList } = useStateful(props, emit2, "checked");
  const selectedNode = ref();
  const selectedNodeComputed = computed({
    get: () => selectedNode.value,
    set: (node) => {
      const value = getValue2(node);
      if (selectedNode.value !== value) {
        selectedNode.value = value;
        emit2("update:selected", node);
      }
    }
  });
  const updateModel = (model, values, state) => {
    if (state) {
      model.value = model.value.concat(values).filter((value, idx, self2) => self2.indexOf(value) === idx);
    } else {
      model.value = model.value.filter((v) => !values.includes(v));
    }
  };
  const toggleCheckbox = (node, state) => {
    let stateValue = state === null ? true : state;
    if (state && node.indeterminate) {
      stateValue = false;
    }
    const values = [getValue2(node)];
    if (isLeafSelectionComputed.value && node.hasChildren) {
      const toggleChildren = (nodes2) => {
        nodes2.forEach((node2) => {
          if (node2.disabled) {
            return;
          }
          const children = getChildren(node2);
          if (children.length) {
            toggleChildren(children);
          }
          values.push(getValue2(node2));
        });
      };
      toggleChildren(getChildren(node));
    }
    updateModel(checkedList, values, stateValue);
  };
  const toggleNode = (node) => {
    node.expanded = !node.expanded;
  };
  const createNode = ({ node, level, children = [], computedFilterMethod: computedFilterMethod2 }) => {
    var _a2;
    const valueBy = getValue2(node);
    let matchesFilter = true;
    const hasChildren = !!children.length;
    let indeterminate = false;
    let checked = checkedList.value.includes(valueBy) || false;
    if (isLeafSelectionComputed.value && hasChildren) {
      const isAllChildrenChecked = children.every((c) => c.checked);
      checked = isAllChildrenChecked;
      indeterminate = !isAllChildrenChecked && children.some((c) => c.indeterminate || c.checked);
      if (indeterminate) {
        checked = null;
      }
    }
    if (filter.value) {
      matchesFilter = (children == null ? void 0 : children.some((c) => c.matchesFilter)) || ((_a2 = computedFilterMethod2.value) == null ? void 0 : _a2.call(computedFilterMethod2, node, filter.value, textBy.value));
    }
    return {
      ...node,
      level,
      checked,
      children,
      get disabled() {
        return getDisabled(node) || false;
      },
      get expanded() {
        const expandKey = props.expandedBy;
        return expandKey in node ? node[expandKey] : expandedList.value.includes(valueBy) || false;
      },
      set expanded(value) {
        const expandKey = props.expandedBy;
        node[expandKey] = value;
        if (hasChildren) {
          updateModel(expandedList, [getValue2(node)], value);
        }
      },
      hasChildren,
      matchesFilter,
      indeterminate
    };
  };
  const computedFilterMethod = computed(() => {
    if (filterMethod == null ? void 0 : filterMethod.value) {
      return filterMethod.value;
    }
    return (node, filter2) => getText(node).toLowerCase().includes(filter2.toLowerCase());
  });
  const buildTree = (nodes2, level = 0) => nodes2.map((node) => {
    const treeItemChildren = getChildren(node);
    if (treeItemChildren.length) {
      const children = buildTree(treeItemChildren, level + 1);
      return createNode({ node, level, children, computedFilterMethod });
    }
    return createNode({ node, level, computedFilterMethod });
  });
  const getFilteredNodes = (nodes2) => nodes2.filter((node) => {
    if (node.children) {
      node.children = getFilteredNodes(node.children);
    }
    if (node.children.length === 0) {
      node.hasChildren = false;
    }
    return node.matchesFilter;
  });
  const { handleKeyboardNavigation } = useTreeKeyboardNavigation$1(props, { emit: emit2, toggleCheckbox, toggleNode });
  provide(TreeViewKey, {
    selectedNodeComputed,
    colorComputed,
    iconBy: props.iconBy,
    selectable: props.selectable,
    expandNodeBy: props.expandNodeBy,
    getText,
    getValue: getValue2,
    getTrackBy,
    toggleNode,
    toggleCheckbox,
    getNodeProperty,
    handleKeyboardNavigation
  });
  const treeItems = computed(() => buildTree(nodes.value));
  const checkForInitialValues = () => {
    const expandedValues = [];
    const checkedValues = [];
    iterateNodes(nodes.value, (node) => {
      if (expandAll.value) {
        expandedValues.push(getValue2(node));
      } else {
        getExpanded(node) && expandedValues.push(getValue2(node));
      }
      if (getChecked(node)) {
        checkedValues.push(getValue2(node));
      }
    });
    if (expandedValues.length) {
      updateModel(expandedList, expandedValues, true);
    }
    if (checkedValues.length) {
      updateModel(checkedList, checkedValues, true);
    }
  };
  checkForInitialValues();
  return {
    treeItems: computed(() => getFilteredNodes(treeItems.value)),
    getText,
    getTrackBy,
    toggleCheckbox
  };
};
const useTreeView$1 = useTreeView;
const _hoisted_1$8 = ["role", "aria-expanded", "aria-disabled", "aria-checked", "tabindex"];
const _hoisted_2$2 = { class: "va-tree-node-root" };
const _hoisted_3$2 = {
  key: 2,
  class: "va-tree-node-content__item"
};
const _hoisted_4$2 = ["aria-hidden"];
const INJECTION_ERROR_MESSAGE = "The VaTreeNode component should be used in the context of VaTreeView component";
const _sfc_main$b = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaTreeNode"
  },
  __name: "VaTreeNode",
  props: {
    node: {
      type: Object,
      required: true
    }
  },
  setup(__props) {
    const props = __props;
    const {
      iconBy,
      selectable,
      expandNodeBy,
      colorComputed,
      selectedNodeComputed,
      getText,
      getTrackBy,
      toggleNode,
      toggleCheckbox,
      getNodeProperty,
      handleKeyboardNavigation
    } = useStrictInject(TreeViewKey, INJECTION_ERROR_MESSAGE);
    const labelComputed = computed(() => getText(props.node) || "");
    const isExpandedComputed = computed(() => props.node.hasChildren ? !!props.node.expanded : void 0);
    const iconComputed = computed(() => getNodeProperty(props.node, iconBy));
    const roleComputed = computed(() => props.node.hasChildren ? "group" : "treeitem");
    const treeNodeClassComputed = useBem("va-tree-node", () => ({
      disabled: Boolean(props.node.disabled),
      checked: Boolean(props.node.checked),
      hasChildren: Boolean(props.node.hasChildren),
      [`level-${props.node.level}`]: true,
      [`expand-by-${expandNodeBy}`]: true
    }));
    const expandedClassComputed = useBem("va-tree-node-children", () => ({
      expanded: !!isExpandedComputed.value
    }));
    const indentClassComputed = useBem("va-tree-node-content", () => ({
      indent: props.node.hasChildren === false
    }));
    const cursorClassComputed = useBem("va-tree-node-content", () => ({
      clickable: props.node.hasChildren === true && expandNodeBy === "node"
    }));
    const tabIndexComputed = computed(() => props.node.disabled ? -1 : 0);
    const onNodeClick = (type) => {
      const nodeType = expandNodeBy === "node" && type === "leaf" ? "node" : type;
      if (expandNodeBy === nodeType) {
        toggleNode(props.node);
      }
      selectedNodeComputed.value = props.node;
    };
    return (_ctx, _cache) => {
      const _component_va_tree_node = resolveComponent("va-tree-node", true);
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["va-tree-node", unref(treeNodeClassComputed)]),
        role: roleComputed.value,
        "aria-expanded": isExpandedComputed.value,
        "aria-disabled": _ctx.$props.node.disabled,
        "aria-checked": !!_ctx.$props.node.checked,
        tabindex: tabIndexComputed.value,
        onKeydown: [
          _cache[4] || (_cache[4] = withKeys(withModifiers(($event) => unref(handleKeyboardNavigation)($event, _ctx.$props.node), ["stop", "prevent"]), ["up"])),
          _cache[5] || (_cache[5] = withKeys(withModifiers(($event) => unref(handleKeyboardNavigation)($event, _ctx.$props.node), ["stop", "prevent"]), ["right"])),
          _cache[6] || (_cache[6] = withKeys(withModifiers(($event) => unref(handleKeyboardNavigation)($event, _ctx.$props.node), ["stop", "prevent"]), ["down"])),
          _cache[7] || (_cache[7] = withKeys(withModifiers(($event) => unref(handleKeyboardNavigation)($event, _ctx.$props.node), ["stop", "prevent"]), ["left"])),
          _cache[8] || (_cache[8] = withKeys(withModifiers(($event) => unref(handleKeyboardNavigation)($event, _ctx.$props.node), ["stop", "prevent"]), ["space"])),
          _cache[9] || (_cache[9] = withKeys(withModifiers(($event) => unref(handleKeyboardNavigation)($event, _ctx.$props.node), ["stop", "prevent"]), ["esc"]))
        ]
      }, [
        createBaseVNode("div", _hoisted_2$2, [
          createBaseVNode("div", {
            class: normalizeClass(["va-tree-node-content", unref(indentClassComputed)]),
            onClick: _cache[3] || (_cache[3] = ($event) => onNodeClick("node"))
          }, [
            _ctx.$props.node.hasChildren ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "va-tree-node-content__item va-tree-node-content__item--leaf",
              onClick: _cache[0] || (_cache[0] = withModifiers(($event) => onNodeClick("leaf"), ["stop"]))
            }, [
              renderSlot(_ctx.$slots, "icon-toggle", normalizeProps$1(guardReactiveProps(_ctx.$props.node)), () => [
                createVNode(unref(VaIcon), {
                  name: isExpandedComputed.value ? "keyboard_arrow_down" : "keyboard_arrow_right",
                  size: "20px"
                }, null, 8, ["name"])
              ])
            ])) : createCommentVNode("", true),
            unref(selectable) ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: "va-tree-node-content__item",
              onClick: _cache[2] || (_cache[2] = withModifiers(() => {
              }, ["stop"]))
            }, [
              renderSlot(_ctx.$slots, "checkbox", normalizeProps$1(guardReactiveProps(_ctx.$props.node)), () => [
                createVNode(unref(VaCheckbox), {
                  "model-value": _ctx.$props.node.checked,
                  color: unref(colorComputed),
                  indeterminate: "",
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = (v) => unref(toggleCheckbox)(_ctx.$props.node, v)),
                  class: "va-tree-node__checkbox"
                }, null, 8, ["model-value", "color"])
              ])
            ])) : createCommentVNode("", true),
            iconComputed.value ? (openBlock(), createElementBlock("div", _hoisted_3$2, [
              renderSlot(_ctx.$slots, "icon", normalizeProps$1(guardReactiveProps(_ctx.$props.node)), () => [
                createVNode(unref(VaIcon), {
                  name: iconComputed.value,
                  size: "small"
                }, null, 8, ["name"])
              ])
            ])) : createCommentVNode("", true),
            createBaseVNode("div", {
              class: normalizeClass(["va-tree-node-content__body", unref(cursorClassComputed)])
            }, [
              renderSlot(_ctx.$slots, "content", normalizeProps$1(guardReactiveProps(_ctx.$props.node)), () => [
                createTextVNode(toDisplayString(labelComputed.value), 1)
              ])
            ], 2)
          ], 2)
        ]),
        withDirectives(createBaseVNode("div", {
          "aria-hidden": !_ctx.$props.node.expanded,
          class: normalizeClass(["va-tree-node-children", unref(expandedClassComputed)])
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.node.children, (childNode) => {
            return openBlock(), createBlock(_component_va_tree_node, {
              key: unref(getTrackBy)(childNode),
              node: childNode
            }, createSlots$1({ _: 2 }, [
              renderList(_ctx.$slots, (_, name) => {
                return {
                  name,
                  fn: withCtx((slotScope) => [
                    renderSlot(_ctx.$slots, name, normalizeProps$1(guardReactiveProps(slotScope)))
                  ])
                };
              })
            ]), 1032, ["node"]);
          }), 128))
        ], 10, _hoisted_4$2), [
          [vShow, _ctx.$props.node.hasChildren]
        ])
      ], 42, _hoisted_1$8);
    };
  }
});
const VaTreeNode = withConfigTransport$1(_sfc_main$b);
const _hoisted_1$7 = {
  class: "va-tree-view",
  role: "tree"
};
const _sfc_main$a = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaTreeView"
  },
  __name: "VaTreeView",
  props: { ...useTreeViewProps },
  emits: [...useTreeViewEmits],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const { treeItems, getTrackBy } = useTreeView$1(props, emit2);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$7, [
        _ctx.$props.filter && !unref(treeItems).length ? renderSlot(_ctx.$slots, "not-found", { key: 0 }, () => [
          createTextVNode("No matching nodes found")
        ]) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(unref(treeItems), (nodeItem) => {
          return openBlock(), createBlock(unref(VaTreeNode), {
            key: unref(getTrackBy)(nodeItem),
            node: nodeItem
          }, createSlots$1({ _: 2 }, [
            renderList(_ctx.$slots, (_, name) => {
              return {
                name,
                fn: withCtx((slotScope) => [
                  renderSlot(_ctx.$slots, name, normalizeProps$1(guardReactiveProps(slotScope)))
                ])
              };
            })
          ]), 1032, ["node"]);
        }), 128))
      ]);
    };
  }
});
const VaTreeView = withConfigTransport$1(_sfc_main$a);
const _hoisted_1$6 = { class: "va-scroll-container__content" };
const _sfc_main$9 = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaScrollContainer"
  },
  __name: "VaScrollContainer",
  props: {
    ...useSizeProps,
    vertical: { type: Boolean, default: false },
    horizontal: { type: Boolean, default: false },
    color: { type: String, default: "secondary" },
    rtl: { type: Boolean, default: false },
    gradient: { type: Boolean, default: false },
    sizesConfig: {
      type: Object,
      default: () => ({
        defaultSize: 4,
        sizes: { small: 4, medium: 6, large: 8 }
      })
    },
    size: {
      type: String,
      default: "small",
      validator: (v) => ["small", "medium", "large"].includes(v)
    }
  },
  setup(__props) {
    const props = __props;
    const { getColor } = useColors();
    const { sizeComputed } = useSize(props);
    const overflowX = computed(() => props.horizontal ? "auto" : "hidden");
    const overflowY = computed(() => props.vertical ? "auto" : "hidden");
    const scrollColor = computed(() => {
      const color = getColor(props.color);
      return props.gradient ? `linear-gradient(0deg, var(--va-scroll-container-scrollbar-gradient-to) 0%, ${color} 100%)` : color;
    });
    const scrollbarSize = computed(() => sizeComputed.value);
    const scrollbarPosition = computed(() => props.rtl ? "rtl" : "ltr");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "va-scroll-container",
        style: normalizeStyle(`--va-scroll-color: ${String(scrollColor.value)};--va-scrollbar-size: ${String(scrollbarSize.value)};--va-overflow-x: ${String(overflowX.value)};--va-overflow-y: ${String(overflowY.value)};--va-scrollbar-position: ${String(scrollbarPosition.value)}`)
      }, [
        createBaseVNode("div", _hoisted_1$6, [
          renderSlot(_ctx.$slots, "default")
        ])
      ], 4);
    };
  }
});
const VaScrollContainer = withConfigTransport$1(_sfc_main$9);
const _hoisted_1$5 = { class: "va-viewer-content" };
const _sfc_main$8 = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaViewer",
    inheritAttrs: false
  },
  __name: "VaViewer",
  setup(__props, { expose: __expose }) {
    const content = ref();
    const controls = ref();
    const isMounted = useIsMounted();
    const isClosed = ref(true);
    const isOpened = computed(() => isMounted.value && !isClosed.value);
    const openViewer = () => isClosed.value = false;
    const closeViewer = () => isClosed.value = true;
    const slots = useSlots();
    const handleAnchorClick = () => {
      if (!slots.anchor) {
        openViewer();
      }
    };
    useClickOutside([content, controls], closeViewer);
    const document2 = useDocument();
    const teleportTarget = computed(() => {
      var _a2;
      return (_a2 = document2.value) == null ? void 0 : _a2.body;
    });
    __expose({
      openViewer,
      closeViewer
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createBaseVNode("div", mergeProps$1({ class: "va-viewer" }, _ctx.$attrs, { onClick: handleAnchorClick }), [
          renderSlot(_ctx.$slots, "anchor", normalizeProps$1(guardReactiveProps({ openViewer }))),
          !_ctx.$slots.anchor ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("", true)
        ], 16),
        isOpened.value ? (openBlock(), createBlock(Teleport, {
          key: 0,
          to: teleportTarget.value
        }, [
          createBaseVNode("div", _hoisted_1$5, [
            createBaseVNode("div", {
              ref_key: "content",
              ref: content,
              class: "va-viewer-content__main-area"
            }, [
              !_ctx.$slots.image ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("", true),
              renderSlot(_ctx.$slots, "image")
            ], 512),
            createBaseVNode("div", {
              ref_key: "controls",
              ref: controls,
              class: "va-viewer-content__controls-panel"
            }, [
              renderSlot(_ctx.$slots, "controls"),
              renderSlot(_ctx.$slots, "close", normalizeProps$1(guardReactiveProps({ close: closeViewer })), () => [
                createBaseVNode("button", {
                  class: "va-viewer-content__close-button",
                  onClick: closeViewer
                }, [
                  createVNode(unref(VaIcon), {
                    name: "close",
                    color: "backgroundPrimary"
                  })
                ])
              ])
            ], 512)
          ])
        ], 8, ["to"])) : createCommentVNode("", true)
      ], 64);
    };
  }
});
const VaViewer = withConfigTransport$1(_sfc_main$8);
const _sfc_main$7 = /* @__PURE__ */ defineComponent({
  name: "VaValue",
  props: {
    defaultValue: { type: null, required: false, default: false }
  },
  setup(props, { slots }) {
    const value = ref(props.defaultValue);
    const slotBind = new Proxy(value, {
      get(target, prop) {
        if (prop === "value") {
          return target.value;
        }
        return target[prop];
      },
      set(target, prop, value2) {
        if (prop === "value") {
          target.value = value2;
        }
        return true;
      }
    });
    return () => {
      return h(Fragment, [renderSlotNodes(slots.default, slotBind)]);
    };
  }
});
const VaValue = withConfigTransport$1(_sfc_main$7);
const makeTextElement = (textarea) => {
  const div = document.createElement("div");
  div.style.position = "absolute";
  div.style.top = "0";
  div.style.left = "0";
  div.style.width = "auto";
  const { font } = window.getComputedStyle(textarea);
  div.style.font = font;
  div.textContent = "Vuestic";
  div.style.zIndex = "-1";
  div.style.pointerEvents = "none";
  div.style.opacity = "0";
  div.ariaHidden = "true";
  div.innerText = textarea.value;
  return div;
};
const useTextHeight = (textarea, text) => {
  const textElement = ref();
  const textHeight = ref();
  watch(textarea, (el) => {
    var _a2, _b;
    if (el) {
      textElement.value = makeTextElement(el);
      (_b = (_a2 = textarea.value) == null ? void 0 : _a2.parentElement) == null ? void 0 : _b.appendChild(textElement.value);
    }
  });
  useResizeObserver(textElement, (newElement) => {
    if (!newElement || !textarea.value) {
      return;
    }
    textHeight.value = newElement[0].contentRect.height;
  });
  watch(text, (newText) => {
    if (!textElement.value) {
      return;
    }
    textElement.value.innerText = String(newText);
    textElement.value.innerHTML += "&nbsp;;";
  });
  return textHeight;
};
const _hoisted_1$4 = ["rows", "loading", "ariaLabel"];
const positiveNumberValidator = (val) => {
  if (val > 0) {
    return true;
  }
  throw new Error(
    `\`minRows|maxRows\` must be a positive integer greater than 0, but ${val} is provided`
  );
};
const { createEmits, createListeners } = useEmitProxy([
  "input",
  "change",
  "click",
  "update:modelValue"
]);
const VaInputWrapperProps = extractComponentProps(VaInputWrapper);
const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaTextarea"
  },
  __name: "VaTextarea",
  props: {
    ...useFormFieldProps,
    ...VaInputWrapperProps,
    ...useStatefulProps,
    ...useValidationProps,
    modelValue: { type: [String, Number], default: "" },
    placeholder: { type: String },
    autosize: { type: Boolean, default: false },
    minRows: {
      type: [Number, String],
      default: 1,
      validator: positiveNumberValidator
    },
    maxRows: {
      type: [Number, String],
      validator: positiveNumberValidator
    },
    resize: {
      type: Boolean,
      default: true
    },
    clearValue: {
      type: [String],
      default: ""
    }
  },
  emits: [...createEmits(), ...useValidationEmits],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const attrs = useAttrs();
    const textarea = shallowRef();
    const { valueComputed } = useStateful(props, emit2, "modelValue", {
      defaultValue: ""
    });
    const focus = () => {
      focusElement(textarea.value);
    };
    const blur = () => {
      blurElement(textarea.value);
    };
    const reset = () => withoutValidation(() => {
      emit2("update:modelValue", props.clearValue);
      emit2("clear");
      resetValidation();
    });
    const {
      isDirty: isDirty2,
      isTouched,
      computedError,
      computedErrorMessages,
      listeners: validationListeners,
      validationAriaAttributes,
      isLoading,
      resetValidation,
      withoutValidation
    } = useValidation(props, emit2, {
      value: valueComputed,
      focus,
      reset
    });
    const isResizable = computed(() => {
      return props.resize && !props.autosize;
    });
    const rows = ref(props.minRows);
    const textHeight = useTextHeight(textarea, valueComputed);
    function calculateInputHeight() {
      let minRows = parseFloat(String(props.minRows));
      let maxRows = parseFloat(String(props.maxRows));
      minRows = isNaN(minRows) ? 1 : minRows;
      maxRows = isNaN(maxRows) ? Infinity : maxRows;
      if (!props.autosize) {
        rows.value = Math.max(maxRows, Math.min(minRows, maxRows ?? 0));
        return;
      }
      if (!textHeight.value || !textarea.value) {
        return;
      }
      const style = getComputedStyle(textarea.value);
      const height = textHeight.value;
      const lineHeight = parseFloat(style.lineHeight);
      const minHeight = Math.max(
        minRows * lineHeight,
        minRows + Math.round(lineHeight)
      );
      const maxHeight = maxRows * lineHeight || Infinity;
      const newHeight = Math.max(minHeight, Math.min(maxHeight, height ?? 0));
      rows.value = Math.round(newHeight / lineHeight);
      textarea.value.style.height = `${newHeight + 1}px`;
    }
    watchEffect(() => {
      calculateInputHeight();
    });
    const computedStyle = computed(
      () => ({
        resize: isResizable.value ? void 0 : "none"
      })
    );
    const computedProps = computed(() => ({
      ...pick(props, ["disabled", "readonly", "placeholder", "name"])
    }));
    const computedInputAttributes = computed(() => ({
      ...validationAriaAttributes.value,
      ...omit(attrs, ["class", "style"])
    }));
    const vaInputWrapperProps = filterComponentProps(VaInputWrapperProps);
    const listeners = createListeners(emit2);
    __expose({
      isDirty: isDirty2,
      isTouched,
      isLoading,
      computedError,
      computedErrorMessages,
      reset,
      focus,
      blur,
      value: valueComputed,
      withoutValidation,
      resetValidation
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaInputWrapper), mergeProps$1({ class: "va-textarea" }, unref(vaInputWrapperProps), {
        error: unref(computedError),
        "error-messages": unref(computedErrorMessages)
      }), {
        default: withCtx(() => [
          createBaseVNode("div", {
            class: normalizeClass(["va-textarea__resize-wrapper", {
              "va-textarea__resize-wrapper--resizable": isResizable.value
            }])
          }, [
            withDirectives(createBaseVNode("textarea", mergeProps$1({
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => isRef(valueComputed) ? valueComputed.value = $event : null)
            }, { ...computedProps.value, ...unref(listeners), ...computedInputAttributes.value, ...unref(validationListeners) }, {
              class: ["va-textarea__textarea", {
                "va-textarea__textarea--autosize": __props.autosize
              }],
              ref_key: "textarea",
              ref: textarea,
              rows: rows.value,
              style: computedStyle.value,
              loading: unref(isLoading),
              ariaLabel: _ctx.$props.label
            }), null, 16, _hoisted_1$4), [
              [vModelText, unref(valueComputed)]
            ])
          ], 2)
        ]),
        _: 1
      }, 16, ["error", "error-messages"]);
    };
  }
});
const VaTextarea = withConfigTransport(_sfc_main$6);
const NON_DISABLED_MENU_ITEM_SELECTOR = '[role="menuitem"]:not([aria-disabled="true"])';
const FOCUSED_MENU_ITEM_SELECTOR = '[role="menuitem"]:focus';
const makeMenuItemAttributes = (options) => ({
  role: "menuitem",
  tabindex: -1,
  "aria-disabled": Boolean(options.disabled)
});
const makeMenuContainerAttributes = () => ({
  role: "menu",
  tabindex: 0
});
const useMenuKeyboardNavigation = (container) => {
  useEvent("keydown", ({ key }) => {
    if (!container.value) {
      return;
    }
    const items2 = container.value.querySelectorAll(NON_DISABLED_MENU_ITEM_SELECTOR);
    const focusedItem = container.value.querySelector(FOCUSED_MENU_ITEM_SELECTOR);
    if (!items2.length) {
      return;
    }
    if (!focusedItem) {
      const firstItem = container.value.querySelector(NON_DISABLED_MENU_ITEM_SELECTOR);
      if (firstItem) {
        focusElement(firstItem);
      }
      return;
    }
    if (key === "ArrowDown" || key === "ArrowRight") {
      const focusedElementIndex = Array.from(items2).indexOf(focusedItem);
      focusElement(items2[focusedElementIndex + 1]);
    }
    if (key === "ArrowUp" || key === "ArrowLeft") {
      const focusedElementIndex = Array.from(items2).indexOf(focusedItem);
      focusElement(items2[focusedElementIndex - 1]);
    }
  }, container);
};
const _hoisted_1$3 = { class: "va-menu-item__cell va-menu-item__cell--left" };
const _hoisted_2$1 = { class: "va-menu-item__cell va-menu-item__cell--center" };
const _hoisted_3$1 = { class: "va-menu-item__content" };
const _hoisted_4$1 = { class: "va-menu-item__cell va-menu-item__cell--right" };
const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaMenuItem"
  },
  __name: "VaMenuItem",
  props: {
    name: { type: String, default: "" },
    icon: { type: String, defatult: "" },
    rightIcon: { type: String, defatult: "" },
    disabled: { type: Boolean, default: false }
  },
  emits: ["selected"],
  setup(__props, { emit: __emit }) {
    const { hasKeyboardFocus, keyboardFocusListeners } = useKeyboardOnlyFocusGlobal();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("tr", mergeProps$1({ class: "va-menu-item" }, unref(makeMenuItemAttributes)({ disabled: __props.disabled }), toHandlers(unref(keyboardFocusListeners), true), {
        class: {
          "va-menu-item--disabled": __props.disabled,
          "va-menu-item--keyboard-focus": unref(hasKeyboardFocus)
        },
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("selected")),
        onKeydown: _cache[1] || (_cache[1] = withKeys(($event) => _ctx.$emit("selected"), ["enter", "space"]))
      }), [
        createBaseVNode("td", _hoisted_1$3, [
          renderSlot(_ctx.$slots, "left-icon", {}, () => [
            __props.icon ? (openBlock(), createBlock(unref(VaIcon), {
              key: 0,
              class: "va-menu-item__icon--left",
              name: __props.icon
            }, null, 8, ["name"])) : createCommentVNode("", true)
          ])
        ]),
        createBaseVNode("td", _hoisted_2$1, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createBaseVNode("a", _hoisted_3$1, toDisplayString(__props.name), 1)
          ])
        ]),
        createBaseVNode("td", _hoisted_4$1, [
          renderSlot(_ctx.$slots, "right-icon", {}, () => [
            __props.rightIcon ? (openBlock(), createBlock(unref(VaIcon), {
              key: 0,
              class: "va-menu-item__icon--right",
              name: __props.rightIcon
            }, null, 8, ["name"])) : createCommentVNode("", true)
          ])
        ])
      ], 16);
    };
  }
});
const _hoisted_1$2 = { class: "va-menu-list__group-name" };
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaMenuGroup"
  },
  __name: "VaMenuGroup",
  props: {
    groupName: {
      type: String,
      required: true
    },
    color: {
      type: String,
      default: "secondary"
    }
  },
  setup(__props) {
    const props = __props;
    const { getColor } = useColors();
    const colorComputed = computed(() => getColor(props.color));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createBaseVNode("div", {
          class: "va-menu-list__group-name-wrapper",
          colspan: "99999",
          style: normalizeStyle(`--va-color-computed: ${String(colorComputed.value)}`)
        }, [
          createBaseVNode("span", _hoisted_1$2, toDisplayString(__props.groupName), 1)
        ], 4),
        renderSlot(_ctx.$slots, "default", {
          style: normalizeStyle(`--va-color-computed: ${String(colorComputed.value)}`)
        }, void 0, true)
      ], 64);
    };
  }
});
const _VaMenuGroup = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["__scopeId", "data-v-4dd1ae9a"]]);
const _hoisted_1$1 = { colspan: "9999" };
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaMenuList"
  },
  __name: "VaMenuList",
  props: {
    ...useSelectableListProps,
    options: { type: Array, default: () => [] }
  },
  emits: ["selected"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const container = ref();
    useMenuKeyboardNavigation(container);
    const { getText, getValue: getValue2, getDisabled, getGroupBy, getTrackBy } = useSelectableList(props);
    const optionGroups = computed(() => props.options.reduce((groups, option) => {
      const groupBy = getGroupBy(option);
      if (!groupBy) {
        groups._noGroup.push(option);
      } else {
        if (!groups[groupBy]) {
          groups[groupBy] = [];
        }
        groups[groupBy].push(option);
      }
      return groups;
    }, { _noGroup: [] }));
    const getUnSlottedVNodes = (nodes) => {
      if (Array.isArray(nodes) && nodes[0].type === Fragment) {
        return nodes[0].children;
      }
      return nodes;
    };
    const getVNodeComponentName = (node) => {
      if (typeof node.type === "object" && "name" in node.type && typeof node.type.name === "string") {
        return node.type.name;
      }
      return "";
    };
    const getVNodeKey = (node) => {
      if (typeof node.type === "string") {
        return node.type;
      }
      if (typeof node.type === "object" && "name" in node.type && typeof node.type.name === "string") {
        return node.type.name;
      }
      return String(node.key);
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("table", mergeProps$1({
        class: "va-menu-list",
        ref_key: "container",
        ref: container
      }, unref(makeMenuContainerAttributes)()), [
        createBaseVNode("tbody", null, [
          _ctx.$slots.default ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(getUnSlottedVNodes(_ctx.$slots.default()), (child) => {
            return openBlock(), createElementBlock(Fragment, null, [
              getVNodeComponentName(child) === "VaMenuItem" ? (openBlock(), createBlock(resolveDynamicComponent(child), {
                key: getVNodeKey(child) + "menuitem"
              })) : getVNodeComponentName(child) === "VaDropdown" ? (openBlock(), createBlock(resolveDynamicComponent(child), {
                key: getVNodeKey(child) + "menu-dropdown"
              })) : (openBlock(), createElementBlock("td", {
                colspan: "999",
                key: getVNodeKey(child),
                class: "va-menu-list__virtual-td"
              }, [
                (openBlock(), createBlock(resolveDynamicComponent(child)))
              ]))
            ], 64);
          }), 256)) : renderSlot(_ctx.$slots, "default", { key: 1 }, () => [
            (openBlock(true), createElementBlock(Fragment, null, renderList(optionGroups.value, (options, groupName) => {
              return openBlock(), createElementBlock(Fragment, { key: groupName }, [
                groupName !== "_noGroup" ? renderSlot(_ctx.$slots, "group", { key: 0 }, () => [
                  createBaseVNode("tr", null, [
                    createBaseVNode("td", _hoisted_1$1, [
                      createVNode(_VaMenuGroup, { "group-name": groupName }, null, 8, ["group-name"])
                    ])
                  ])
                ]) : createCommentVNode("", true),
                (openBlock(true), createElementBlock(Fragment, null, renderList(options, (option) => {
                  return openBlock(), createBlock(_sfc_main$5, {
                    key: unref(getTrackBy)(option),
                    name: unref(getText)(option),
                    icon: option.icon,
                    "right-icon": option.rightIcon,
                    disabled: unref(getDisabled)(option),
                    onSelected: ($event) => _ctx.$emit("selected", unref(getValue2)(option), option)
                  }, {
                    "left-icon": withCtx((bind) => [
                      renderSlot(_ctx.$slots, "left-icon", normalizeProps$1(guardReactiveProps(bind)))
                    ]),
                    "right-icon": withCtx((bind) => [
                      renderSlot(_ctx.$slots, "right-icon", normalizeProps$1(guardReactiveProps(bind)))
                    ]),
                    _: 2
                  }, 1032, ["name", "icon", "right-icon", "disabled", "onSelected"]);
                }), 128))
              ], 64);
            }), 128))
          ])
        ])
      ], 16);
    };
  }
});
const VaMenuList = withConfigTransport(_sfc_main$3);
const VaMenuItem = withConfigTransport(_sfc_main$5);
const VaMenuGroup = withConfigTransport(_VaMenuGroup);
const useImmediateFocus = (el) => {
  watchEffect(() => {
    if (el.value) {
      nextTick(() => {
        focusElement(unwrapEl(el.value));
      });
    }
  });
};
const VaMenuListProps = extractComponentProps(VaMenuList);
const VaMenuListEmits = extractComponentEmits(VaMenuList);
const VaDropdownProps = extractComponentProps(VaDropdown);
const VaDropdownEmits = extractComponentEmits(VaDropdown);
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  ...{
    name: "VaMenu"
  },
  __name: "VaMenu",
  props: {
    ...useComponentPresetProp,
    ...VaMenuListProps,
    ...VaDropdownProps,
    stickToEdges: { type: Boolean, default: true }
  },
  emits: [
    ...VaDropdownEmits,
    ...VaMenuListEmits
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const menuList = ref();
    const dropdown = ref();
    useImmediateFocus(menuList);
    const close = () => {
      var _a2;
      (_a2 = dropdown.value) == null ? void 0 : _a2.hide();
      nextTick(() => {
        var _a22;
        const el = unwrapEl((_a22 = dropdown.value) == null ? void 0 : _a22.anchorRef);
        if (el) {
          focusFirstFocusableChild(el);
        }
      });
    };
    const onKeydown = (event) => {
      if (event.key === "Escape") {
        close();
      }
      if (event.key === "ArrowDown" || event.key === "ArrowUp") {
        event.preventDefault();
      }
    };
    const menuListProps = filterComponentProps(VaMenuListProps);
    const dropdownProps = filterComponentProps(VaDropdownProps);
    __expose({
      close
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaDropdown), mergeProps$1(unref(dropdownProps), {
        ref_key: "dropdown",
        ref: dropdown
      }), {
        anchor: withCtx(() => [
          renderSlot(_ctx.$slots, "anchor")
        ]),
        default: withCtx(() => [
          createVNode(unref(VaDropdownContent), { onKeydown }, {
            default: withCtx(() => [
              createVNode(unref(VaMenuList), mergeProps$1({
                onKeydown: _cache[0] || (_cache[0] = withKeys(withModifiers(() => {
                }, ["prevent", "stop"]), ["enter", "space"]))
              }, unref(menuListProps), {
                ref_key: "menuList",
                ref: menuList,
                onSelected: _cache[1] || (_cache[1] = ($event) => {
                  _ctx.$emit("selected", $event);
                  close();
                })
              }), createSlots$1({ _: 2 }, [
                _ctx.$slots.default ? {
                  name: "default",
                  fn: withCtx(() => [
                    renderSlot(_ctx.$slots, "default")
                  ]),
                  key: "0"
                } : void 0
              ]), 1040)
            ]),
            _: 3
          })
        ]),
        _: 3
      }, 16);
    };
  }
});
const VaMenu = withConfigTransport(_sfc_main$2);
const validationPropsDefaults = {
  rules: () => [],
  dirty: false,
  errorCount: 1,
  success: false,
  messages: () => [],
  immediateValidation: false
};
const statefulPropsDefaults = {
  stateful: false
};
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "VaFormField",
  props: /* @__PURE__ */ mergeDefaults({
    stateful: { type: Boolean },
    modelValue: {},
    name: {},
    rules: {},
    dirty: { type: Boolean },
    error: { type: Boolean },
    errorMessages: {},
    errorCount: {},
    success: { type: Boolean },
    messages: {},
    immediateValidation: { type: Boolean },
    clearValue: {}
  }, {
    ...statefulPropsDefaults,
    ...validationPropsDefaults
  }),
  emits: ["update:error", "update:errorMessages", "update:dirty", "update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const { valueComputed } = useStateful(props, emit2, "modelValue");
    const reset = () => {
      valueComputed.value = props.clearValue;
    };
    const focus = () => {
    };
    const {
      computedError,
      computedErrorMessages,
      validate,
      isDirty: isDirty2,
      isLoading,
      isValid,
      resetValidation,
      validationAriaAttributes,
      listeners
    } = useValidation(props, emit2, {
      reset,
      focus,
      value: valueComputed
    });
    const messagesComputed = computed(() => computedError.value ? computedErrorMessages.value : props.messages);
    const messagesColor = computed(() => {
      if (!isValid.value) {
        return "danger";
      }
      if (props.success) {
        return "success";
      }
      return "";
    });
    const errorLimit = computed(() => props.error ? Number(props.errorCount) : 99);
    const innerValue = ref(valueComputed.value);
    watchEffect(() => {
      innerValue.value = valueComputed.value;
    });
    const makeSlotRef = () => {
      return new Proxy(innerValue, {
        get(v, key) {
          if (key === "ref") {
            return innerValue.value;
          }
          return Reflect.get(v, key);
        },
        set(_, key, value) {
          if (key === "ref") {
            innerValue.value = value;
            valueComputed.value = value;
            return true;
          }
          return Reflect.set(valueComputed, key, value);
        }
      });
    };
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VaMessageList), {
        "model-value": messagesComputed.value,
        "has-error": !unref(isValid),
        color: messagesColor.value,
        limit: errorLimit.value
      }, createSlots$1({
        default: withCtx(({ ariaAttributes, attrs }) => [
          renderSlot(_ctx.$slots, "default", normalizeProps$1(guardReactiveProps({
            error: unref(computedError),
            errorMessages: messagesComputed.value,
            messages: messagesComputed.value,
            validate: unref(validate),
            isDirty: unref(isDirty2),
            isLoading: unref(isLoading),
            isValid: unref(isValid),
            resetValidation: unref(resetValidation),
            validationAriaAttributes: unref(validationAriaAttributes),
            ...unref(listeners),
            value: makeSlotRef(),
            modelValue: makeSlotRef(),
            ariaAttributes,
            bind: {
              ...attrs,
              ...ariaAttributes,
              ...unref(listeners)
            }
          })))
        ]),
        _: 2
      }, [
        renderList(["message", "messages"], (name) => {
          return {
            name,
            fn: withCtx((slotScope) => [
              renderSlot(_ctx.$slots, name, normalizeProps$1(guardReactiveProps(slotScope)))
            ])
          };
        })
      ]), 1032, ["model-value", "has-error", "color", "limit"]);
    };
  }
});
const VaFormField = withConfigTransport(_sfc_main$1);
const vuesticComponents = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  VaAccordion,
  VaAffix,
  VaAlert,
  VaAppBar,
  VaAspectRatio,
  VaAvatar,
  VaAvatarGroup,
  VaBacktop,
  VaBadge,
  VaBreadcrumbs,
  VaBreadcrumbsItem,
  VaButton,
  VaButtonDropdown,
  VaButtonGroup,
  VaButtonToggle,
  VaCard,
  VaCardActions,
  VaCardBlock,
  VaCardContent,
  VaCardTitle,
  VaCarousel,
  VaCheckbox,
  VaChip,
  VaCollapse,
  VaColorIndicator,
  VaColorInput,
  VaColorPalette,
  VaConfig: _sfc_main$1W,
  VaContent,
  VaCounter,
  VaDataTable,
  VaDateInput,
  VaDatePicker,
  VaDivider,
  VaDropdown,
  VaDropdownContent,
  VaFallback,
  VaFileUpload,
  VaForm,
  VaFormField,
  VaHover,
  VaIcon,
  VaImage,
  VaInfiniteScroll,
  VaInnerLoading,
  VaInput,
  VaInputWrapper,
  VaLayout,
  VaList,
  VaListItem,
  VaListItemLabel,
  VaListItemSection,
  VaListLabel,
  VaListSeparator,
  VaMenu,
  VaMenuGroup,
  VaMenuItem,
  VaMenuList,
  VaMessageList,
  VaModal,
  VaNavbar,
  VaNavbarItem,
  VaOptionList,
  VaPagination,
  VaParallax,
  VaPopover,
  VaProgressBar,
  VaProgressCircle,
  VaRadio,
  VaRating,
  VaScrollContainer,
  VaSelect,
  VaSeparator: _sfc_main$1V,
  VaSidebar,
  VaSidebarItem,
  VaSidebarItemContent,
  VaSidebarItemTitle,
  VaSkeleton,
  VaSkeletonGroup,
  VaSlider,
  VaSpacer: _sfc_main$1U,
  VaSplit,
  VaStepper,
  VaStickyScrollbar: _sfc_main$1T,
  VaSwitch,
  VaTab,
  VaTabs,
  VaTextarea,
  VaTimeInput,
  VaTimePicker,
  VaTimeline,
  VaTimelineItem,
  VaToast,
  VaTreeView,
  VaValue,
  VaViewer,
  VaVirtualScroller
}, Symbol.toStringTag, { value: "Module" }));
const isPluginFabric = (plugin) => typeof plugin === "function";
const usePlugin = (app, plugin, ...options) => {
  if (isPluginFabric(plugin)) {
    app.use(plugin(...options));
  } else {
    app.use(plugin);
  }
};
const createVuestic = defineVuesticPlugin((options = {}) => ({
  install(app) {
    const { config } = options;
    setCurrentApp(app);
    Object.entries(vuesticComponents).forEach(([name, component]) => {
      app.component(name, component);
    });
    usePlugin(app, GlobalConfigPlugin(config));
    usePlugin(app, CachePlugin);
    usePlugin(app, ColorConfigPlugin(config));
    usePlugin(app, ColorsClassesPlugin);
    usePlugin(app, BreakpointConfigPlugin);
    usePlugin(app, VaDropdownPlugin);
    usePlugin(app, VaToastPlugin);
    usePlugin(app, VaModalPlugin);
    setCurrentApp(null);
  }
}));
const useAppContext = () => {
  const currentInstance2 = getCurrentInstance();
  return computed(() => {
    var _a2;
    return ((_a2 = getCurrentApp()) == null ? void 0 : _a2._context) || (currentInstance2 == null ? void 0 : currentInstance2.appContext);
  });
};
const useToast = () => {
  const appContext = useAppContext();
  const createdInThisSetupContext = [];
  const notify = (options) => {
    const id = createToastInstance(options, appContext.value);
    if (id) {
      createdInThisSetupContext.push(id);
    }
    return id;
  };
  const init = (options) => {
    return notify(options);
  };
  const close = (id) => closeById(id);
  const closeAll = (allApps = false) => closeAllNotifications(allApps ? void 0 : appContext.value);
  const closeAllCreatedInThisHook = () => {
    createdInThisSetupContext.forEach((id) => closeById(id));
  };
  return {
    init,
    notify,
    close,
    closeAll,
    closeAllCreatedInThisHook
  };
};
const _hoisted_1 = { class: "translation-card-wrapper" };
const _hoisted_2 = { class: "translation-title" };
const _hoisted_3 = { class: "form-content" };
const _hoisted_4 = ["for"];
const _hoisted_5 = { class: "form-send" };
const _sfc_main = {
  __name: "App",
  setup(__props) {
    const toast = useToast();
    const selectedTab = ref(0);
    const isTranslating = ref(false);
    const data = shallowRef(window.wpData || {});
    data.value.langs = data.value.langs.filter((l) => l !== "pt_BR");
    data.value.translations = reactive(data.value.translations || {});
    const keys = Object.keys(data.value.translations);
    data.value.langs.forEach((l) => {
      if (!keys.includes(l) || typeof data.value.translations[l] !== "object") {
        data.value.translations[l] = {};
      }
    });
    const translation_keys = computed(() => {
      return [...data.value.translation_keys];
    });
    watch(() => selectedTab.value, () => console.log("mudou", selectedTab.value));
    async function translateAll() {
      const lang = data.value.langs[selectedTab.value];
      if (!lang) {
        toast.init({ message: "Error: No language selected!", color: "danger" });
        return;
      }
      if (!data.value.translations[lang]) {
        data.value.translations[lang] = {};
      }
      const keysToTranslate = translation_keys.value.filter(
        (key) => !data.value.translations[lang][key]
      );
      if (keysToTranslate.length === 0) {
        toast.init({ message: "Todas as chaves já estão traduzidas!", color: "info" });
        return;
      }
      toast.init({ message: `Traduzindo ${keysToTranslate.length} itens...`, color: "info" });
      isTranslating.value = true;
      const jsonToTranslate = {};
      keysToTranslate.forEach((key) => {
        jsonToTranslate[key] = key;
      });
      try {
        let response = await fetch(data.value.ajaxurl, {
          method: "POST",
          headers: { "Content-Type": "application/x-www-form-urlencoded" },
          body: new URLSearchParams({
            action: "etus_translate_json",
            etus_nonce: data.value.etus_nonce,
            lang,
            json: JSON.stringify(jsonToTranslate)
          })
        });
        let result = await response.json();
        if (result.success) {
          let translations = result.data.translations;
          Object.keys(translations).forEach((key) => {
            data.value.translations[lang][key] = translations[key];
          });
          toast.init({ message: "Tradução concluída!", color: "success" });
        } else {
          toast.init({ message: "Erro na tradução!", color: "danger" });
        }
      } catch (error) {
        console.error("Erro na requisição:", error);
        toast.init({ message: "Erro ao se conectar ao servidor!", color: "danger" });
      } finally {
        isTranslating.value = false;
      }
    }
    async function submit() {
      try {
        let response = await fetch(data.value.ajaxurl, {
          method: "POST",
          headers: { "Content-Type": "application/x-www-form-urlencoded" },
          body: new URLSearchParams({
            action: "etus_update_translations",
            etus_nonce: data.value.etus_nonce,
            data: JSON.stringify({ "translations": data.value.translations })
          })
        });
        let result = await response.json();
        if (!!result) toast.init({ message: "Dados atualizados com sucesso!" });
      } catch (error) {
        console.error("Erro na requisição:", error);
      }
    }
    return (_ctx, _cache) => {
      const _component_VaTab = resolveComponent("VaTab");
      const _component_VaTabs = resolveComponent("VaTabs");
      const _component_VaTextarea = resolveComponent("VaTextarea");
      const _component_VaForm = resolveComponent("VaForm");
      const _component_VaButton = resolveComponent("VaButton");
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode(_component_VaTabs, {
          modelValue: selectedTab.value,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => selectedTab.value = $event)
        }, {
          tabs: withCtx(() => [
            (openBlock(true), createElementBlock(Fragment, null, renderList(data.value.langs, (title, index) => {
              return openBlock(), createBlock(_component_VaTab, {
                key: index,
                name: index
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(title), 1)
                ]),
                _: 2
              }, 1032, ["name"]);
            }), 128))
          ]),
          _: 1
        }, 8, ["modelValue"]),
        createBaseVNode("div", _hoisted_1, [
          createBaseVNode("div", _hoisted_2, [
            _cache[2] || (_cache[2] = createTextVNode("Traduções para a língua: ")),
            createBaseVNode("b", null, toDisplayString(data.value.langs[selectedTab.value]), 1)
          ]),
          createVNode(_component_VaForm, {
            ref: "formRef",
            class: "translate-form"
          }, {
            default: withCtx(() => [
              createBaseVNode("div", _hoisted_3, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(translation_keys.value, (translate_key) => {
                  return openBlock(), createElementBlock("div", {
                    key: translate_key,
                    class: "form-row"
                  }, [
                    createBaseVNode("label", { for: translate_key }, toDisplayString(translate_key), 9, _hoisted_4),
                    createVNode(_component_VaTextarea, {
                      modelValue: data.value.translations[data.value.langs[selectedTab.value]][translate_key],
                      "onUpdate:modelValue": ($event) => data.value.translations[data.value.langs[selectedTab.value]][translate_key] = $event,
                      style: { "max-width": "300px" },
                      "auto-grow": ""
                    }, null, 8, ["modelValue", "onUpdate:modelValue"])
                  ]);
                }), 128))
              ])
            ]),
            _: 1
          }, 512),
          createBaseVNode("div", _hoisted_5, [
            createVNode(_component_VaButton, {
              loading: isTranslating.value,
              color: "success",
              onClick: translateAll,
              disabled: isTranslating.value
            }, {
              default: withCtx(() => [
                createTextVNode(" Traduzir tudo automaticamente para: " + toDisplayString(data.value.langs[selectedTab.value]), 1)
              ]),
              _: 1
            }, 8, ["loading", "disabled"]),
            createVNode(_component_VaButton, {
              onClick: _cache[1] || (_cache[1] = ($event) => submit())
            }, {
              default: withCtx(() => _cache[3] || (_cache[3] = [
                createTextVNode(" Salvar Traduções ")
              ])),
              _: 1,
              __: [3]
            })
          ])
        ])
      ], 64);
    };
  }
};
createApp(_sfc_main).use(createVuestic()).mount("#app");
//# sourceMappingURL=app.js.map
